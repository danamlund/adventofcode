* advent of code
 - http://adventofcode.com/

* day 1
** text
--- Day 1: Not Quite Lisp ---

Santa was hoping for a white Christmas, but his weather machine's "snow" function is powered by stars, and he's fresh out! To save Christmas, he needs you to collect fifty stars by December 25th.

Collect stars by helping Santa solve puzzles. Two puzzles will be made available on each day in the advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!

Here's an easy puzzle to warm you up.

Santa is trying to deliver presents in a large apartment building, but he can't find the right floor - the directions he got are a little confusing. He starts on the ground floor (floor 0) and then follows the instructions one character at a time.

An opening parenthesis, (, means he should go up one floor, and a closing parenthesis, ), means he should go down one floor.

The apartment building is very tall, and the basement is very deep; he will never find the top or bottom floors.

For example:

    (()) and ()() both result in floor 0.
    ((( and (()(()( both result in floor 3.
    ))((((( also results in floor 3.
    ()) and ))( both result in floor -1 (the first basement level).
    ))) and )())()) both result in floor -3.

To what floor do the instructions take Santa?

Your puzzle answer was 280.
--- Part Two ---

Now, given the same instructions, find the position of the first character that causes him to enter the basement (floor -1). The first character in the instructions has position 1, the second character has position 2, and so on.

For example:

    ) causes him to enter the basement at character position 1.
    ()()) causes him to enter the basement at character position 5.

What is the position of the character that causes Santa to first enter the basement?

Your puzzle answer was 1797.
** data
#+BEGIN_SRC text :tangle d1.txt :padline no
()()(()()()(()()((()((()))((()((((()()((((()))()((((())(((((((()(((((((((()(((())(()()(()((()()(()(())(()((((()((()()()((((())((((((()(()(((()())(()((((()))())(())(()(()()))))))))((((((((((((()())()())())(())))(((()()()((((()(((()(()(()()(()(()()(()(((((((())(())(())())))((()())()((((()()((()))(((()()()())))(())))((((())(((()())(())(()))(()((((()())))())((()(())(((()((((()((()(())())))((()))()()(()(()))))((((((((()())((((()()((((()(()())(((((()(()())()))())(((()))()(()(()(()((((()(())(()))(((((()()(()()()(()(((())())(((()()(()()))(((()()(((())())(()(())())()()(())()()()((()(((()(())((()()((())()))((()()))((()()())((((()(()()(()(((()))()(()))))((()(((()()()))(()(((())()(()((()())(()(()()(()())(())()(((()(()())()((((()((()))))())()))((()()()()(())()())()()()((((()))))(()(((()()(((((((())()))()((((()((())()(()())(())()))(()(()())(((((((())))(((()))())))))()))())((())(()()((())()())()))))()((()()())(())((())((((()())())()()()(((()))())))()()))())(()()()(()((((((()()))())()))()(((()(((())((((()()()(()))())()()))))())()))())((())()())(((((())())((())())))(((())(((())(((((()(((((())(()(()())())(()(())(()))(()((((()))())()))))())))((()(()))))())))(((((())()))())()))))()))))(((()))()))))((()))((()((()(()(())()())))(()()()(())()))()((((())))))))(())(()((()()))(()))(()))(()((()))))))()()((((()()))()())()))))))()()()))(()((())(()))((()()()())()(((()((((())())))()((((()(()))))))())))()()())()))(()))))(()())()))))))((())))))))())()))()((())())))(()((()))()))(())))))(()))()())()()))((()(()))()()()()))))())()()))())(())()()))()))((()))))()()(()())))))()()()))((((()))()))))(()(())))(()())))((())())(()))()))))()())))()())()())))))))))()()))))())))((())((()))))())))(((()())))))))(()))()()))(()))()))))()())))))())((((()())))))))())))()()))))))))()))()))))()))))))(())))))))))())))))))))))))))())())((())))))))))()))((())))()))))))))())()(()))))))())))))()()()())()(()()()(()())(()))()()()(()())))())())))()))))())))))))()()()()())(())())()())()))))(()()()()()))))()))())())))((()())()())))()))()))))(()())))()))))))))(((()))()()))))))))))))))))))))(()))(()((()))())))())(()))(()(()(())))))()(()))()))()()))))))))))))()((()())(())())()(())))))())()())((()()))))(()()))))())()(())()))))))))))))))))))))()))(()(()())))))))()()((()))()))))))((())))()))))))))((()))())()()))())()()))((()))())))))))))))(()())()))(())((()(()()))(()())(())))()())(()(())()()))))()))()(()))))))(()))))))))))(()))())))))))))())))))())))(())))))()))))(())())))))))))()(()))))()())))())(()))()())))))))))))))())()()))))()))))))())))))()))))(())(()()()()((())()))())(()))((())()))())())(())(()()))))()))(())()()((())(())))(())))()))())))))))))()(((((())())))(())()))))(())))((()))()(((((((()))))()()))(())))))()(()))))(()()))()))())))))))(()())()))))))))())))(()))())()))(())()((())())()())())(()(()))))()))))))((()())(())()()(()())))()()))(())(())(()))())))()))(()))()()))((((()))))()))((()()()))))()))()))())))(()))()))))(())))()))())()(()))()())))())))))))())))())))()()))))))(()))())())))()))()()())())))))))))))))())))()))(()()))))())))())()(())))())))))))))))))))))()()())())))))()()()((()(()))()()(())()())()))()))))()()()))))))((()))))))))()(()(()((((((()()((()())))))))))))()))())))))((())())(()))())))())))))())()()())(())))())))()())())(())))))))()()(())))()))())))())())())()))))))))()))(()()()())())())))(())())))))))()()())()))))())))())()(())())))))))()())()))(()()(())())))()(()((()()((()()(((((())(()())()))(())()))(())))(())))))))()))()))((()))()))()))))))))()))))))))((()()())(()))(((()))(())))()))((())(((())))()())))())))))((())))))(())())((((((())())()(()))()(()((()())))((())()(()(()))))(())(()()())(())))())((()(((())())))(((()())())))())()(())())((((()()))))())((()))()()()()(())(((((((()()()((()))())(()())))(())())((((()()(()))))()((())))((())()))()(((()))())))()))((()(()))(())(()((((())((((()()(()()))(((())(()))))((((()(()))(())))))((()))(()))((()(((()(()))(()(()((()(())(()(()(()(()()((()))())(((())(()(()))))(()))()()))(())))(())()(((())(()))()((((()()))))())(()))))((())()((((()(((()))())())(((()))()())((())(())())(())()(())()(()()((((((()()))))()()(((()()))))()())()(((()(()))(()(()())(()(()))))(((((()(((())())))))(((((()((()()((())())((((((()(())(()()((()()()()()()()(()()))()(((()))()))(((((((())(((()((()())()((((())(((()(())))()((()(()()()((())((()())()))()))())))())((((((()))(()(()()()))(()((()(()(()))()((()(((()()()((())(((((())()(()))())())((()(())))(()(()())(())((())())())(((()()()(())))))())(()))))))()))))))())((()()()))((()((((((()))(((()((((()()()(((()))())()(()()(((()((()()()()())()()))()()()(()(())((()))))(()))())))))))()(()()(((((())()(()(((((()((()(()()())(()((((((((()((((((())()((((()()()((()((()((((((()))((())))))))())()))((()(()))()(()()(()((())((()()((((((((((((()())(()()()))((((()((((((())(()))())(()()((()()))()(((((((()((()()((((((()(((())))((())))((((((((()()(((((((())(((((()())(((())((())()((((()(((((((()(()(((()((((((()(((()(((((((((((()()((()()(()))((()()(((()(((())))((((())()(()(((())()(()(((())(((((((((((()))())))((((((())((()()((((()())())((((()()))((())(((((()(()()(()()()((())(()((()()((((()(((((()((()(()((((()())((((((()(((((()()(()(()((((())))(())(())(())((((()(()()((((()((((()()((()((((((())))(((((()))))()))(()((((((((()(((())())(((())))(()(()((())(((()((()()(((((()((()()(((())()(()))(((((((())(()(((((()))((()((()((()))(())())((((()((((())()(()))(((()(((((((((((((((())(((((((((()))(((()(()()()()((((((()((())()((((((((()(())(((((((((((()(()((())()((()()(()(()()((((()()((())(()((()()(()()((((()(((((((())))((((())(())()(((()()((()()((((()((()(((()((())(((()()()((((()((((()()(()(()((((((((())(()(((((())(()())(((((((()())()(()((((()((())(()()())((((()()(((()((((())(())(()()(((((((((()()))()(((())(()(()((((((())(()()())(()))()()(((()(((()((())(()(((((((()(()(()((()(((((()(()((()(()((((((()((((()()((((()(((()((())(()(()((()()((((()()(())()(())(((())(()((((((((()())(((((((((()(())()((((())))()))()()(((((()()((((((())(()()(((()(()(((((((()(()(((((((())(())((((()((()(())))((((()()())(()))((()())((((()(((((()(()(())(()(()()())(((((()(((((()((((()()((((((((()()))(()((((((())((((())()(()(((()()()(((()(()(())(())(((((()(())())((((())(())(()(((()(((((())((((())())((()(((((((()(((())(()(()))(((((((((()((()((()()(()((((())(((()((())((((())(()(((()(((()(()((((()(((())(()(((()(()()(()(()((()()(()())(())())((()(()(((()(((()(((()()(((((((((()(((((((((()()(((()(((()())((((()(()(((()()()((())((((((((((())(()(((()((((()())((((()((()))(((()()()(((((()(((((((())((()())(()((((())((((((((())(()((()((((((((((()()((()((()()))(((()())()())()(((()())()()(()(()(((((((())()))(())()))())()()((())()((()((((()((()((())(((((()((((((()(())))(()))())(((()))((()()(()(((()))((((())()(((()))))()(()(())()(((((())(()(()(())(())()((()()()((((()(())((()())(()(()))(()(()(()()(())()()(()((())()((()))))()))((()(()()()()((()())(()))())()(()(((((((((())())((()((()((((((())()((((())(((())((()(()()()((())(()((())(((()((((()()((()(()(((((())()))()((((((()))((())(((()()))(((())(())()))(((((((())(())())()(())(((((()))()((()))()(()()((()()()()()())(((((((
#+END_SRC
** puzzle 1
#+BEGIN_SRC cpp :includes <stdio.h>
  FILE *f = fopen("d1.txt", "r");
  char d[1000000] = { '\0' };
  fread(d, 1, 1000000, f);

  
  int floor = 0;
  for (int i = 0; d[i] != '\0'; i++) {
    if (d[i] == '(') {
      floor++;
    } else if (d[i] == ')') {
      floor--;
    }
  }
  printf("%d", floor);
#+END_SRC

#+RESULTS:
: 280
** puzzle 2
#+BEGIN_SRC cpp :includes <stdio.h>
  FILE *f = fopen("d1.txt", "r");
  char d[1000000] = { '\0' };
  fread(d, 1, 1000000, f);
  
  int floor = 0;
  for (int i = 0; d[i] != '\0'; i++) {
    if (d[i] == '(') {
      floor++;
    } else if (d[i] == ')') {
      floor--;
    }
    if (floor == -1) {
      printf("%d", (i+1));
      return 0;
    }
  }
#+END_SRC

#+RESULTS:
: 1797
* day 2
** text
--- Day 2: I Was Told There Would Be No Math ---

The elves are running low on wrapping paper, and so they need to submit an order for more. They have a list of the dimensions (length l, width w, and height h) of each present, and only want to order exactly as much as they need.

Fortunately, every present is a box (a perfect right rectangular prism), which makes calculating the required wrapping paper for each gift a little easier: find the surface area of the box, which is 2*l*w + 2*w*h + 2*h*l. The elves also need a little extra paper for each present: the area of the smallest side.

For example:

    A present with dimensions 2x3x4 requires 2*6 + 2*12 + 2*8 = 52 square feet of wrapping paper plus 6 square feet of slack, for a total of 58 square feet.
    A present with dimensions 1x1x10 requires 2*1 + 2*10 + 2*10 = 42 square feet of wrapping paper plus 1 square foot of slack, for a total of 43 square feet.

All numbers in the elves' list are in feet. How many total square feet of wrapping paper should they order?

Your puzzle answer was 1588178.
--- Part Two ---

The elves are also running low on ribbon. Ribbon is all the same width, so they only have to worry about the length they need to order, which they would again like to be exact.

The ribbon required to wrap a present is the shortest distance around its sides, or the smallest perimeter of any one face. Each present also requires a bow made out of ribbon as well; the feet of ribbon required for the perfect bow is equal to the cubic feet of volume of the present. Don't ask how they tie the bow, though; they'll never tell.

For example:

    A present with dimensions 2x3x4 requires 2+2+3+3 = 10 feet of ribbon to wrap the present plus 2*3*4 = 24 feet of ribbon for the bow, for a total of 34 feet.
    A present with dimensions 1x1x10 requires 1+1+1+1 = 4 feet of ribbon to wrap the present plus 1*1*10 = 10 feet of ribbon for the bow, for a total of 14 feet.

How many total feet of ribbon should they order?

Your puzzle answer was 3783758.
** data
#+BEGIN_SRC text :tangle d2.txt :padline no
3x11x24
13x5x19
1x9x27
24x8x21
6x8x17
19x18x22
10x9x12
12x2x5
26x6x11
9x23x15
12x8x17
13x29x10
28x18x6
22x28x26
1x5x11
29x26x12
8x28x29
27x4x21
12x7x16
7x4x23
15x24x8
15x14x2
11x6x29
28x19x9
10x3x1
5x20x13
10x25x1
22x17x7
16x29x3
18x22x8
18x11x19
21x24x20
4x7x17
22x27x12
1x26x6
5x27x24
29x21x3
25x30x2
21x26x2
10x24x27
10x16x28
18x16x23
6x5x26
19x12x20
6x24x25
11x20x7
4x8x5
2x13x11
11x17x1
13x24x6
22x29x16
4x24x20
10x25x10
12x29x23
23x27x12
11x21x9
13x2x6
15x30x2
8x26x24
24x7x30
22x22x8
29x27x8
28x23x27
13x16x14
9x28x20
21x4x30
21x20x20
11x17x30
9x14x22
20x2x6
10x11x14
1x8x23
23x19x19
26x10x13
21x12x12
25x7x24
1x28x17
20x23x9
2x24x27
20x24x29
1x3x10
5x20x14
25x21x3
15x5x22
14x17x19
27x3x18
29x23x19
14x21x19
20x8x3
22x27x12
24x15x18
9x10x19
29x25x28
14x22x6
4x19x28
4x24x14
17x19x17
7x19x29
28x8x26
7x20x16
11x26x29
2x18x3
12x7x18
11x15x21
24x7x26
2x22x23
2x30x5
1x19x8
15x29x10
15x26x22
20x16x14
25x29x22
3x13x19
1x12x30
3x15x27
19x9x11
30x8x21
26x12x20
11x17x19
17x25x1
19x24x12
30x6x20
11x19x18
18x15x29
18x8x9
25x15x5
15x6x26
13x27x19
23x24x12
3x15x28
17x10x10
15x4x7
15x27x7
21x8x11
9x18x2
7x20x20
17x23x12
2x19x1
7x26x26
13x23x8
10x3x12
11x1x9
1x11x19
25x14x26
16x10x15
7x6x11
8x1x27
20x28x17
3x25x9
30x7x5
17x17x4
23x25x27
23x8x5
13x11x1
15x10x21
22x16x1
12x15x28
27x18x26
25x18x5
21x3x27
15x25x5
29x27x19
11x10x12
22x16x21
11x8x18
6x10x23
21x21x2
13x27x28
2x5x20
23x16x20
1x21x7
22x2x13
11x10x4
7x3x4
19x2x5
21x11x1
7x27x26
12x4x23
12x3x15
25x7x4
20x7x15
16x5x11
1x18x26
11x27x10
17x6x24
19x13x16
6x3x11
4x19x18
16x15x15
1x11x17
19x11x29
18x19x1
1x25x7
8x22x14
15x6x19
5x30x18
30x24x22
11x16x2
21x29x19
20x29x11
27x1x18
20x5x30
12x4x28
3x9x30
26x20x15
18x25x18
20x28x28
21x5x3
20x21x25
19x27x22
8x27x9
1x5x15
30x6x19
16x5x15
18x30x21
4x15x8
9x3x28
18x15x27
25x11x6
17x22x15
18x12x18
14x30x30
1x7x23
27x21x12
15x7x18
16x17x24
11x12x19
18x15x21
6x18x15
2x21x4
12x9x14
19x7x25
22x3x1
29x19x7
30x25x7
6x27x27
5x13x9
21x4x18
13x1x16
11x21x25
27x20x27
14x25x9
23x11x15
22x10x26
15x16x4
14x16x21
1x1x24
17x27x3
25x28x16
12x2x29
9x19x28
12x7x17
6x9x19
15x14x24
25x21x23
26x27x25
7x18x13
15x10x6
22x28x2
15x2x14
3x24x18
30x22x7
18x27x17
29x18x7
20x2x4
4x20x26
23x30x15
5x7x3
4x24x12
24x30x20
26x18x17
6x28x3
29x19x29
14x10x4
15x5x23
12x25x4
7x15x19
26x21x19
18x2x23
19x20x3
3x13x9
29x21x24
26x13x29
30x27x4
20x10x29
21x18x8
7x26x10
29x16x21
22x5x11
17x15x2
7x29x5
6x18x15
23x6x14
10x30x14
26x6x16
24x13x25
17x29x20
4x27x19
28x12x11
23x20x3
22x6x20
29x9x19
10x16x22
30x26x4
29x26x11
2x11x15
1x3x30
30x30x29
9x1x3
30x13x16
20x4x5
23x28x11
24x27x1
4x25x10
9x3x6
14x4x15
4x5x25
27x14x13
20x30x3
28x15x25
5x19x2
10x24x29
29x30x18
30x1x25
7x7x15
1x13x16
23x18x4
1x28x8
24x11x8
22x26x19
30x30x14
2x4x13
27x20x26
16x20x17
11x12x13
28x2x17
15x26x13
29x15x25
30x27x9
2x6x25
10x26x19
16x8x23
12x17x18
26x14x22
13x17x4
27x27x29
17x13x22
9x8x3
25x15x20
14x13x16
8x7x13
12x4x21
27x16x15
6x14x5
28x29x17
23x17x25
10x27x28
1x28x21
18x2x30
25x30x16
25x21x7
2x3x4
9x6x13
19x6x10
28x17x8
13x24x28
24x12x7
5x19x5
18x10x27
16x1x6
12x14x30
1x2x28
23x21x2
13x3x23
9x22x10
10x17x2
24x20x11
30x6x14
28x1x16
24x20x1
28x7x7
1x24x21
14x9x7
22x8x15
20x1x21
6x3x7
7x26x14
5x7x28
5x4x4
15x7x28
30x16x23
7x26x2
1x2x30
24x28x20
5x17x28
4x15x20
15x26x2
1x3x23
22x30x24
9x20x16
7x15x2
6x21x18
21x21x29
29x10x10
4x3x23
23x2x18
29x24x14
29x29x16
22x28x24
21x18x24
16x21x6
3x9x22
9x18x4
22x9x9
12x9x13
18x21x14
7x8x29
28x28x14
1x6x24
11x11x3
8x28x6
11x16x10
9x16x16
6x6x19
21x5x12
15x17x12
3x6x29
19x1x26
10x30x25
24x26x21
1x10x18
6x1x16
4x17x27
17x11x27
15x15x21
14x23x1
8x9x30
22x22x25
20x27x22
12x7x9
9x26x19
26x25x12
8x8x16
28x15x10
29x18x2
25x22x6
4x6x15
12x18x4
10x3x20
17x28x17
14x25x13
14x10x3
14x5x10
7x7x22
21x2x14
1x21x5
27x29x1
6x20x4
7x19x23
28x19x27
3x9x18
13x17x17
18x8x15
26x23x17
10x10x13
11x5x21
25x15x29
6x23x24
10x7x2
19x10x30
4x3x23
22x12x6
11x17x16
6x8x12
18x20x11
6x2x2
17x4x11
20x23x22
29x23x24
25x11x21
22x11x15
29x3x9
13x30x5
17x10x12
10x30x8
21x16x17
1x5x26
22x15x16
27x7x11
16x8x18
29x9x7
25x4x17
10x21x25
2x19x21
29x11x16
18x26x21
2x8x20
17x29x27
25x27x4
14x3x14
25x29x29
26x18x11
8x24x28
7x30x24
12x30x22
29x20x6
3x17x1
6x15x14
6x22x20
13x26x26
12x2x1
7x14x12
15x16x11
3x21x4
30x17x29
9x18x27
11x28x16
22x3x25
18x15x15
2x30x12
3x27x22
10x8x8
26x16x14
15x2x29
12x10x7
21x20x15
2x15x25
4x14x13
3x15x13
29x8x3
7x7x28
15x10x24
23x15x5
5x7x14
24x1x22
1x11x13
26x4x19
19x16x26
5x25x5
17x25x14
23x7x14
24x6x17
5x13x12
20x20x5
22x29x17
11x17x29
25x6x4
29x8x16
28x22x24
24x23x17
16x17x4
17x8x25
22x9x13
24x4x8
18x10x20
21x23x21
13x14x12
23x26x4
4x10x29
2x18x18
19x5x21
2x27x23
6x29x30
21x9x20
6x5x16
25x10x27
5x29x21
24x14x19
19x11x8
2x28x6
19x25x6
27x1x11
6x8x29
18x25x30
4x27x26
8x12x1
7x17x25
7x14x27
12x9x5
14x29x13
18x17x5
23x1x3
28x5x13
3x2x26
3x7x11
1x8x7
12x5x4
2x30x21
16x30x11
3x26x4
16x9x4
11x9x22
23x5x6
13x20x3
4x3x2
14x10x29
11x8x12
26x15x16
7x17x29
18x19x18
8x28x4
22x6x13
9x23x7
11x23x20
13x11x26
15x30x13
1x5x8
5x10x24
22x25x17
27x20x25
30x10x21
16x28x24
20x12x8
17x25x1
30x14x9
14x18x6
8x28x29
12x18x29
9x7x18
6x12x25
20x13x24
22x3x12
5x23x22
8x10x17
7x23x5
10x26x27
14x26x19
10x18x24
8x4x4
16x15x11
3x14x9
18x5x30
29x12x26
16x13x12
15x10x7
18x5x26
14x1x6
10x8x29
3x4x9
19x4x23
28x17x23
30x7x17
19x5x9
26x29x28
22x13x17
28x2x1
20x30x8
15x13x21
25x23x19
27x23x1
4x6x23
29x29x24
5x18x7
4x6x30
17x15x2
27x4x2
25x24x14
28x8x30
24x29x5
14x30x14
10x18x19
15x26x22
24x19x21
29x23x27
21x10x16
7x4x29
14x21x3
21x4x28
17x16x15
24x7x13
21x24x15
25x11x16
10x26x13
23x20x14
20x29x27
14x24x14
14x23x12
18x6x5
3x18x9
8x18x19
20x26x15
16x14x13
30x16x3
17x13x4
15x19x30
20x3x8
13x4x5
12x10x15
8x23x26
16x8x15
22x8x11
12x11x18
28x3x30
15x8x4
13x22x13
21x26x21
29x1x15
28x9x5
27x3x26
22x19x30
4x11x22
21x27x20
22x26x7
19x28x20
24x23x16
26x12x9
13x22x9
5x6x23
20x7x2
18x26x30
3x6x28
24x18x13
28x19x16
25x21x25
25x19x23
22x29x10
29x19x30
4x7x27
5x12x28
8x26x6
14x14x25
17x17x2
5x27x11
8x2x2
3x20x24
26x10x9
22x28x27
18x15x20
12x11x1
5x14x30
7x3x16
2x16x16
18x20x15
13x14x29
1x17x12
13x5x23
19x4x10
25x19x11
15x17x14
1x28x27
11x9x28
9x10x18
30x11x22
21x21x20
2x1x5
2x25x1
7x3x4
22x15x29
21x28x15
12x12x4
21x30x6
15x10x7
10x14x6
21x26x18
14x25x6
9x7x11
22x3x1
1x16x27
1x14x23
2x13x8
14x19x11
21x26x1
4x28x13
12x16x20
21x13x9
3x4x13
14x9x8
21x21x12
27x10x17
6x20x6
28x23x23
2x28x12
8x10x10
3x9x2
20x3x29
19x4x16
29x24x9
26x20x8
15x28x26
18x17x10
7x22x10
20x15x9
6x10x8
7x26x21
8x8x16
15x6x29
22x30x11
18x25x8
6x21x20
7x23x25
8x25x26
11x25x27
22x18x23
3x2x14
16x16x1
15x13x11
3x9x25
29x25x24
9x15x1
12x4x1
23x30x20
3x1x23
6x10x29
28x13x24
4x19x17
6x6x25
27x29x17
12x13x2
10x7x13
14x15x8
22x2x3
27x17x19
23x10x16
5x9x25
9x25x14
11x18x6
18x10x12
9x4x15
7x16x14
17x24x10
11x4x6
12x9x17
22x18x12
6x24x24
6x22x23
5x17x30
6x9x5
17x20x10
6x8x12
14x17x13
29x10x17
22x4x5
10x19x30
22x29x11
10x12x29
21x22x26
16x6x25
1x26x24
30x17x16
27x28x5
30x13x22
7x26x12
11x24x30
1x17x25
22x1x3
29x24x6
4x8x24
13x9x20
8x12x9
21x25x4
23x23x28
5x2x19
29x3x15
22x1x14
3x23x30
8x25x3
15x8x14
30x14x6
23x27x24
19x1x2
10x9x13
13x8x7
8x13x22
5x15x20
17x14x8
5x11x20
5x10x27
24x17x19
21x2x3
15x30x26
21x19x15
2x7x23
13x17x25
30x15x19
26x4x10
2x25x8
9x9x10
2x25x8
19x21x30
17x26x12
7x5x10
2x22x14
10x17x30
1x8x5
23x2x25
22x29x8
13x26x1
26x3x30
25x17x8
25x18x26
26x19x15
8x28x10
12x16x29
30x6x29
28x19x4
27x26x18
15x23x17
5x21x30
8x11x13
2x26x7
19x9x24
3x22x23
6x7x18
4x26x30
13x25x20
17x3x15
8x20x18
23x18x23
28x23x9
16x3x4
1x29x14
20x26x22
3x2x22
23x8x17
19x5x17
21x18x20
17x21x8
30x28x1
29x19x23
12x12x11
24x18x7
21x18x14
14x26x25
9x11x3
10x7x15
27x6x28
14x26x4
28x4x1
22x25x29
6x26x6
1x3x13
26x22x12
6x21x26
23x4x27
26x13x24
5x24x28
22x16x7
3x27x24
19x28x2
11x13x9
29x16x22
30x10x24
14x14x22
22x23x16
14x8x3
20x5x14
28x6x13
3x15x25
4x12x22
15x12x25
10x11x24
7x7x6
8x11x9
21x10x29
23x28x30
8x29x26
16x27x11
1x10x2
24x20x16
7x12x28
28x8x20
14x10x30
1x19x6
4x12x20
18x2x7
24x18x17
16x11x10
1x12x22
30x16x28
18x12x11
28x9x8
23x6x17
10x3x11
5x12x8
22x2x23
9x19x14
15x28x13
27x20x23
19x16x12
19x30x15
8x17x4
10x22x18
13x22x4
3x12x19
22x16x23
11x8x19
8x11x6
7x14x7
29x17x29
21x8x12
21x9x11
20x1x27
1x22x11
5x28x4
26x7x26
30x12x18
29x11x20
3x12x15
24x25x17
14x6x11
#+END_SRC

** puzzle 1
#+BEGIN_SRC cpp :includes <stdio.h>
  FILE *f = fopen("d2.txt", "r");
  
  int l, w, h;
  int total_area = 0;
  
  while (fscanf(f, "%dx%dx%d", &l, &w, &h) != EOF) {
    int side1 = l * w;
    int side2 = w * h;
    int side3 = h * l;
  
    int area = 2 * side1 + 2 * side2 + 2 * side3;
    if (side1 <= side2 && side1 <= side3) {
      area += side1;
    } else if (side2 <= side1 && side2 <= side3) {
      area += side2;
    } else {
      area += side3;
    }
    total_area += area;
  }
  
  printf("%d", total_area);
#+END_SRC


#+RESULTS:
: 1588178

- too high: 1816561
- too high: 1588236
- 1588178
** puzzle 2
#+BEGIN_SRC cpp :includes <stdio.h>
  FILE *f = fopen("d2.txt", "r");
  
  int l, w, h;
  int total_ribbon = 0;
  
  while (fscanf(f, "%dx%dx%d", &l, &w, &h) != EOF) {
    int ribbon = l * w * h;

    if (l >= w && l >= h) {
      ribbon += 2 * w + 2 * h;
    } else if (w >= l && w >= h) {
      ribbon += 2 * l + 2 * h;
    } else {
      ribbon += 2 * l + 2 * w;
    }
    total_ribbon += ribbon;
  }
  
  printf("%d", total_ribbon);
#+END_SRC


#+RESULTS:
: 3783758

- too high 3784094
- 3783758

* day 3
** text
--- Day 3: Perfectly Spherical Houses in a Vacuum ---

Santa is delivering presents to an infinite two-dimensional grid of houses.

He begins by delivering a present to the house at his starting location, and then an elf at the North Pole calls him via radio and tells him where to move next. Moves are always exactly one house to the north (^), south (v), east (>), or west (<). After each move, he delivers another present to the house at his new location.

However, the elf back at the north pole has had a little too much eggnog, and so his directions are a little off, and Santa ends up visiting some houses more than once. How many houses receive at least one present?

For example:

    > delivers presents to 2 houses: one at the starting location, and one to the east.
    ^>v< delivers presents to 4 houses in a square, including twice to the house at his starting/ending location.
    ^v^v^v^v^v delivers a bunch of presents to some very lucky children at only 2 houses.

Your puzzle answer was 2572.
--- Part Two ---

The next year, to speed up the process, Santa creates a robot version of himself, Robo-Santa, to deliver presents with him.

Santa and Robo-Santa start at the same location (delivering two presents to the same starting house), then take turns moving based on instructions from the elf, who is eggnoggedly reading from the same script as the previous year.

This year, how many houses receive at least one present?

For example:

    ^v delivers presents to 3 houses, because Santa goes north, and then Robo-Santa goes south.
    ^>v< now delivers presents to 3 houses, and Santa and Robo-Santa end up back where they started.
    ^v^v^v^v^v now delivers presents to 11 houses, with Santa going one direction and Robo-Santa going the other.

Your puzzle answer was 2631.
** data
#+BEGIN_SRC text :tangle d3.txt :padline n
v>v<vvv<<vv^v<v>vv>v<<<^^^^^<<^<vv>^>v^>^>^>^>^><vvvv<^>^<<^><<<^vvvv>^>^><^v^><^<>^^>^vvv^<vv>>^>^^<>><>^>vvv>>^vv>^<><>^<v^>^>^><vv^vv^>><<^><<v>><>^<^>>vvv>v>>>v<<^<><^<v<>v>^^v^^^<^v^^>>><^>^>v<>^<>>^>^^v^><v<v>>><>v<v^v>^v<>>^><v>^<>v^>^<>^v^^^v^^>>vv<<^^><^<vvv>^>^^<^>>^^^^^v^<v>vv<>>v^v<^v^^<><^<^vv^><>><><>v>vvv^vv^^<<><<vvv><<^v^><v<>vvv^<^>vvvv^>^>>^v^<v^vv<^^v<>v>vv^<>><v<<<^v^<<><v<^<^<><^^^>^>>v>^>v^<>v><^<^<v^>^^vv<^^<>v^v^vv<>>>>v^v<>><^^v>vv^^>v^v>v<vv>>v>><v^v^v>vv>^^>^v><<vv^v^^vv<^v><^<<v<v^>vv^^^<v^>v>v^^^>><^^<v^<^>>v><vv<v^^>^^v>>v^^^<^^v>^v>><^<^<>>v<<^^vv>^^^v<^<^<v<v^^vv>^vv^>>v^><v>><<<>^vv^<^<>v^^<<<v<^>^><><v^^>>^^^<^vv<^^^>><^^v>^^v^<v^v^>^^<v>^<^v<^<<<<^<v^>v^<^^<>^^>^><<>>^v><>><^<v><^^^>>vv>^><vv>^^^^^v^vvv><><^<^>v>v^v^>^><><^<^><>v<<vv<^>><>^v^^v>^<<<>^v^>^<<v^vv<>v^<v^^vv><<v^<>>>^<v>vv>v>>>^<^>><vv<>>>>v<v>>>^v>v><>>vvv<^^><<^>^>v<^vvvv<v><vv<><^^^v^^^>v^v<>v<^^v>>><>v<v^>>v><v^>>^^<v<<<^<v<><^^v><<v^><<<<^vv<^<>^><vv<<<<^>>>^v>^v>vv>^v<>v>v<v><^>>v>>^>^><^<v^v^>^v<><><^^>^<vvvv^^<>^^^>vv^v^v>^v^^v^^v><v^<^<>><^<v>v>>vv<<v>>vvvv<vv><>>^v^>^>>v^v^<<<vv<><v<<>>>^v<<v>^^vv^><>v>^>v><<<<<<<^>^^v^<<^^>>vvv^<><>><>^^v<<vv><^^v<^^><vv>v^>>>v^v><v^v<^>v^><>v<<>v>^^v><<<<><^v^v>>^<>^<<>^<v<<>>v<<>><^<<<<^v>^<^v>v>vv<v<v<<>^>v<^<<>v^<vvvv^>v>><<v><v<>v>v>>v^vvv^^>>>v^<^<<^^<<<><v>v^<<v<<<>v<^^<><v<v^^<v>^>v>>v<>^>^^>>^v<<>v^^^>>>^vv<^v<v>^>v>^><>v^^<>^^v^^vv^<^>^<<>><<^>^v>>><<<vvvv><<><v<^v^v<vvv^<><<^<vv><v^v^v^>v>v^<vvv^><^><^<vv><>>v^>^^^<>><v^<^^^<>v<<v<^v>>>^>>v^><<>vvv><^>>v><v><>v>>^>v><<><<>^<>^^^vv><v^>v^^>>^>^<^v<v<^^<^vvvv>v<v>^>v^>^><^<vvvv><^><><<v<>v<v^><^<v^>^v^^<<<<^><^^<^><>>^v<<^<<^vv>v>>v<^<^vv>><v<vv>v<v<v>^v<>^>v<>^v<<<v>>^^v>>><vvv>v^>^v^v>^^^v<vvvv>><^>vvv^<vv^^vv><<<>v<>v>^<vvv^<^<v<v<^vv^^>>vv^<^^v^><^^^^^v<^<v<^>>>vv^v^>^<v>^<><v^<^v>>><^v^<<v<<v<>v>^v<v^v>>^^v<<v<v<<>>>vv>>^v>>^<<<<^><<<><^^>>v<>^vvvv>v^^^>^^^>^<vvvv><^^v<v<>v<^v^v<<v^^^v^<v<^v>v^^<>^>^<^v>vv<v^vv<^<<>v><<^><><^^v<<><^^><>^v>^<><<^<^^<<>vv<>^^<<^>><<<>>vvv>^>v^^v^><<^>v>^>^<^<<>v<^>vv^v^v<>vv<<v>vv<vv><^>v^<>^vv^v^<v<^>>>>v^v><^<><<>vv^<vvv^>>vvv^>v>>><^^vv<vvvv>v<^<^>>^^>^^vv>>><^v<>^v^<<>v^^^<v>^>>^<^<v>>^v<^^^<v>^v>^>>v<vv>>^<v^<<>>^>>><v>v^<<^<v>>^<<^^<>v<^v<^<>v^v>^^v<vvvv>^vv>vvv>v^<^>><v^^vv<<<^>vvvv<>>^^<>v^<><>v<^<>v<>^>v<>vv<v^v>>v<v<^<v^^v^vv^vvv><^^>v>><>>^<^^<>>^>^<v^>>vvv^v><v>>^>^>v><><<><vv^v>v<>^v<^vv^^^<>^^<<^^^v<>><v<^<^<^<^^><v^v<^>v^>vvvv>^^v^>^<v<^^^>>^<<vv^<><><^^^^<<>^<><v>vv^<><^>^^<>v^<>>>v><>vvvvv>v>v^^>^<<vvvv<>vv>>v<<^<>^^^v^<><>>^<<<v<v<>>>><><v>v<v<>>^>^^^^vv^^<<><^^<<vv<^<>v>vv<v<><<<^<<v<<<<>v<>>^<^>^>><v>v>><^^<>><<<><<><v^^v<<><^<^v<v^><^^v<<>><<<<^>v^<v>><v^><v<vvv>v^v^<v><<>>v<><<v>^<>><>>^><>v^v>v<<>v<>v^^><<>>>v<<>>>>^>v>><v<<>>>vv>v>^<^^^<>v<v>^<^^v^vvv^>vv>^<v><vvvv>^<<>vvv<<<vv>^^<^>^>>v>v<<<<<>^^vv^>>v>^<^<v^v^>^v>>v>^v<><>^<^>v>v<<<^^^v>^<<<>vvv^v^^>^>>^>v>v<>^^><>>v>^>v<<<^^^v^<v^vv>><><^<^<><vvv<v^>>^v>vv<^v<<^vv>v^<<v>v>v>^v^>^v<<^v^vv>v<v>^<<><v^>>v<>><v<<<^v<<>vvv^<vv<vvv<<>^vv^^v><^>v^vv<<v^<<^^^<^<>^^<<>v<><<v>^><>^<><<v<v^^>vv<>^<v<^<vvv>vv>v><^^v<>><^v^v><><>><v<v>vv<>>><v^^v<>><<^>>><^^^vvv<<<vv<<^v<<<>><<vv>>>>v<<<<<vv><><v>v^^<<^vv^<vv<>>vv>^<>^v^^<>^^^vv>v^^<v<><v>v<v>>^v<v<>>^<v^^><>v^^^>v^^v<vv><^>v^v^<>v>v<v<^^>>v<^^vv^v<^^^^vv<<><<^>>^^<<v^^<<^>v^>>^^^><^^>^v^v>^<<v<vv<<<v<^^^>^>>^v<>^<^>v>^>^v^<^^^<^vv<v><^^>>v<v>^>^v^>>>>^v>^^<<^<v^v<^<<v<<^><^^<v^<><v>v^<<v^^<><<>>><vv<<><>^<>>>v<<v^^^v^^<<<vv<<^<^<^vv^<><><<^^<^^>v^>^<v<>>v^v<><<v>^^v>^<^<vvv<v>v^v>>>^^<^<v^>^vv<<<v<<>^><><^<>v>>>v<v^<>v>><^^^v^^^v<^^<vv^^^>v>v<>>^^<><>v>^<v<>^>>>><>v>^v>^vv^v<vv<<^^>><v<>^>^^<v<^>^<vvv>><>^<<>>><<<><>^^<<<v<>v^>v>v<v>^^^>^>^v<<>v>vv>><<<v>^^<v><vv<<v^^>^>>^><^>v<^<^v>><^^>v<vv^^><><>^><<><>v^>v<><^^>><>^<^^v<^<<v>><v><<<^^<<v<^vv^v<>><>>>^>v<vvv^>^<><v^><^<<^vv<^v^v^v<>v^^v>v^<^>^vv^>>><<>v^vv^<>^v^><<v^v<v>v^<><>>v^v^><>v^vvv^^^<<^<<v<<v<^vv^>>v^v>^^<v<>><>v>>v^<>^>v>^>><<>v^v><^v>v>>><v<v><^<^^>vv<v><^>^<^>^^v><><v<^^v<<><^<<v^<v<<><^^vvv^v>^>^<>>vv>v^^v^^vv<^^>><v^^vv><^v>v^<<v<^v>vvv<>>^v><<>^v<<<>^><^vv><<^^<v^>v<<v>^vv<>^v>>>><<<<^^<^v>^<^^<^<^^>>^^v>^^^^v^^^<<>^^vv<<v^^><v>><^<<><>^>v<>>v^^^>^v^^v^<v^v>v>>>>>^v>^>^^<vvv^^<v^<<<v<<>v>><^^^v<<^^<v>>^<^<^><^<<v^v><<vv<^<>>v>v>^v<><<v>^>vv^v<v>v><^<v>><>^<vv<v^^^^v<^^>><<^^>v>v>^^^<>v>^v^^>vv^vv<^^>><>^>^<>v>><>^v<<v>v>^><^^^v^<vv><<^v^>v^>vv>v^<>v><vv><^v>v<><v^v^v<^v<>^v<v^<<><<v>>^v><v>^^<>vvv^>^<<v^>><^>><^<>^v<v<v<^vvv<><<^v^<v>><<<v>^<^<v>v>^vv^v>v<^^vv<<vvv^<v>><>vv^>v<<>v<vvvv>>v>^^>>><<<^>^vv>><v>^^^>v<^vv<>v<<<v<<<<v>>>>^<^^^^>v<^^<><v>v>v<v^>vv^>v>v<^>^v^<>v>>vvv>^^><^vvv>><>>>^<<^<v<>>>v^^><v<v>>^><>v<^^v^<<v><>^<>>><^v^v>>>^vvvv^<><<<v<^>>v>^v^<v<v<<^<<v^vv^v>v<v<>>v<v^<<<><v^>><^<<^>^^><v>v<^v^<^>v>^<<v>v^<>v^<>vv^<>^>^>v^>^vv<>^^<<>>v<>^v<><v^><><<<vv>v>v^>vv^><<<<v>^v<><>^^<vv>v^^v^^^<v<^^><v^v<>><v<vv>^<>>><vv<^v<<>>^><>>v<v^v^>>>v<<>v<<<<<<<^v<<^^^v<^v<>v^^<<<^<>>v^vv<v>^<^^<^^<<^>vv><^<^^v<<<^><^v<^><>v<vv^>^v^^>>><<vv^^v><^<<^<>>^>>^<<<<v^vv<>>>v>^v>><>v>>v>><>v>><^^><v>^^vv<^^<^>vv><<^>><<><v>^vvv><^v^>vvv^>>^<><^>^<<>>v^v>v<<>^>>^>v<^^<^<<>^^v<vvvvv^^^<^<>^^v>v<>^<^^<<v>v^^vvv^^v>^vv<v^>^<>v<^v^>^<v><v<<<^v<v<v^^<vvv>vv<<vv>v^<<v<^<vv><^>^><^^<^^<<v^^<v^v<v^^^^>^>vv^<>^<>^>^^<^v><<<^>vv^vv>v^v<>^^v^<^^^vvv^><v^<v^^<v<>v^<><>v>vv<^v^>>^v<^^vv>vv>^>><<<<v^^<^><>^><>>v<>>v>^v<^vv>^^>^<^<<v^>>v^v<^^v<vv<^<><^^>^^<>^^^<vv<v<<^^>^>^vv<^>><^<vvv^<>>vv^><v>v^>^vv>^>v^^<>>^v<>>v<^>^v>vv^<vv<^^>>^<v>>>>vvv>vv>^><^v<<<>^^v>v^v<^^^v^^>^><<^^>^<v>><^^^^^<v<vv<v<^<>^^<^v<^>>vv>>^v^vv<>><>^>>>^<v>^^^^><^<<<v<>^v<><vvv^<^^>vv^>>v<vvvv><v^v><^vv<^v<><vvv<vv>v<>^v^<<>>>>v^^>^vv<<vvv<^^><v><><<>v^v<^<^>><vv>^^><^>^><<><v<^v^><^<><>vv>>>>^><<^^^<^v^>^>^^>^<^><v><^^<^^<>><><v>><<<>^>^^v<>^<<<v>>vv>^>>^>^<>>vv<^^vv<>v<>^^>^v<v^^^^v<>^<v>v^v>^^^<v>v<<<^vv^><>^<v>>^^vv>v^<<^><>>vv^^^^^>v>>v<<<>^<vvv<<><><^v<^v<^>^<>^vvv>^>v><<<vv<>v>vv<v<<v>^<^^>v^v>^<^v^<<vvv^^<>^v<<^>^<><>^^<>>^^<^v^<^<v<><<^><v<>v^^>v^v^^^<^v<<^v>^>>^^^^^><<<vv^>>v^><v^^vv><>v^^<^v<^<v^^><<v>v^^^><^^^><<<<<>^<<^<>>v<<v^v^^v<<>^<vv>>><^^^<>>>>vvv>v<>>>v^v^v<^<<^>^<<>v>>^>^^><^><<^v^^<^<>v^v>vv<>>>>>>v<<><v^<v<>>^^>v<<<>^<<v><^><<^v>vv>>>><><>v^<^v><v^<<<<^v><^>v>>^^^v<^>>^>>v<<^<<>vvv>>^v<>>^v><<<^v^v<><v>^vvv<v<v>^^^<><vv^<<>vvv<v<^^v^^><v<^v<^v^<v<^>^^^>>v>^<v^>>^<><<><vv<>vv>^v^>>^<<v<^^v>v<v<vvv>><><<><vvvvv<^v<^>^^><>^<<>^v<<>>v^vv<<>^^v^v^v><^>v>v<^<<^<^>vv>^v<<^>^>>v^<<v^>v^^v^^<v^v>>><vv><<<>^v>><><v<vv<^>v<>><^v>^^v<<<<^v^vv<<<<><><^<^<^v><<^^v^<<<<<^^><^^>vv<v<^<v>v<^><><v<>vvv^<vv>v^>^>^^^v<<^<^^>vv<v^v^v>^vv^><^v^<<>v<^^>^vv<<>^<<><^>v^<<^<>v><><>v<<^^><^^^v>>v>^vv<v^>>^v^^<><<<<<^>^v^<^<^^>^vv<^>v^^v^<>v<><v>v^v>vvv><><<><>vv<vvv^v>^^>^^^<><^>^^^>v<vvvv<>vv<v<v^^>><>v<>>v^>v^^vv^>v>>><v<<<<v<^v>><^^>^v^v<v^v^^^vvv>>>vv<^>><<<^>><^<^>^<^>^>>v^<^<>^<^^<><vvv^^<>^<>>><<v>^<^<v<<><^<<^><^^>vv<>^^><v^v<vv<^<vvv<<^>v^>>v>>>v<<^vv^<><>>>^^<^v^>>^>>><<v<<^<vv><^<>^>>^v>>><^^^<<<vv<<v<v>^vv><><<>^^^<>^<vv^<^<<v>^^><vv>><>>>^>vv>^<^<>>^<^^><v>v^><v>vv><><>>><><<^^v<<^v<v>vv<><><<^v>^v<>^<^^^v^>^<^><^v>v>^v<>><^^v^^^^^<><v<>>vvv<v^^<>v>>>>^<<><^v>vv>>^^><<><><^^^<^<^<<^v>^^^><v>>>>><<v<v>v^^^<>>v<vv<^<>v^^^v<><^>v>><<><>v<^><<>>><>v>^<>>^>v^v<<<<>^<v^vv^>vv<<><v^vv<v<v<<>>>>>vv<><>^<^v>vv^<<v<^v^^<<^<<^^v^>>><<>^<>><^>>><v<>><<>^^>><<<^^^^^v>>^<<>>vvvv<^v<v^^<^>^vv<vv<>v<<<^><>>>>vv^<^v>v<^<>^v>>^<^^v^>>><>^^<^v>>v<<>vv<vvvv<>vv>^><>v^<>^<<^vv<v^^v<vvvv><^>>^v^>^^<<<^>>^^>^<^^<^<<<v^<^^v<<vv^<<^^^vv><v<vv^>v^^v<v>^^<^v<^>>><<>vv<<^><<v^v^^^v<vv>^>vv<^>>^<v<>vv>>>^>>><<v<^<>^<<<>>^<<>><^<<^^^>>v^^>v<<<>v>v>v<v<^>^<>>>^vvv><<^^<<><v<><^<v<vvv>v>>>>vv^^v<v<^<^><v>^v<<v<vv>>v>v<<<<><<>vv<><^^^<>>v<v<vvv><v^<vv^>>><v^^<>>>^^<><^<^v^><vv>>^^v>^<<v^>v>^^>^v^<v<^<v^v><>>v^^<^v^^<<>^^>v^^>><<<<^<^^v>^^v>v<<vv^^vv>^>v^<v<v><>vv>>^<v^v^<v<^>^v>v^^>vvvvv<v><<>vv>vvvvvv>>v>>^^^<v>vv^^><<v>>v^^^^v>vv>v<^v>>>>^>^><v^>^<v<vv>v>^>><v>><<>>^vv<vv^^<^^>>>>><><<^<v<><<v>^><^vv^v>>>>>v>^>^<vv>^v^>v<^v^<^<<vv<<>v<>>^vv<<>^v^v>><><<>>v^^<<>^^<v><>v<<^^<^^>^^>^<^><>>v<>>^^<^>><<<v<>>>^v^>v>v<<^^<<^>v<v^>>v^^v^^<<>^v>v><v^>v<^^>^<vv><vv^<>v<><^<<<vv<<v>v<^<<<<^^>v^v^^><<><^^^<v>v^^>>>vvv><>vv<>>^^v^v<<^>v^^v^>vv>^<<v<^<v^>^^<<v<^^>^v^^<^^v<<>>vv<^>>^><><>v>>v<>^<v^^><<>>>
#+END_SRC
** puzzle 1
#+BEGIN_SRC cpp
  #include <stdio.h>
  #include <stdlib.h>
  int main() {
    char d[1000000] = { '\0' };
    FILE *f = fopen("d3.txt", "r");
    fread(d, 1, 1000000, f);
  
    int visited[10000][2];
    int visited_size = 0;
  
    int x = 0;
    int y = 0;
  
    visited[visited_size][0] = x;
    visited[visited_size][1] = y;
    visited_size++;
  
    for (int i = 0; d[i] != '\0'; i++) {
      switch (d[i]) {
      case '<': x--; break;
      case '>': x++; break;
      case '^': y--; break;
      case 'v': y++; break;
      default: continue;
      }
      visited[visited_size][0] = x;
      visited[visited_size][1] = y;
      visited_size++;
    }
  
    // insertion sort
    for (int i = 0; i < visited_size; i++) {
      int j = i;
      int jx = visited[j][0];
      int jy = visited[j][1];
      while (j > 0 &&
             (jx < visited[j - 1][0]
              || (jx == visited[j - 1][0] && jy < visited[j - 1][1]))) {
          visited[j][0] = visited[j - 1][0];
          visited[j][1] = visited[j - 1][1];
          j--;
        }
      visited[j][0] = jx;
      visited[j][1] = jy;
    }
  
    int prevx = 0;
    int prevy = 0;
    int unique_visits = 0;
    int first = 1;
    for (int i = 0; i < visited_size; i++) {
      if (first || visited[i][0] != prevx || visited[i][1] != prevy) {
        first = 0;
        unique_visits++;
        prevx = visited[i][0];
        prevy = visited[i][1];
      }
    }
    
    printf("%d", unique_visits);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 2572

 - too low: 2571
** puzzle 2
#+BEGIN_SRC cpp
    #include <stdio.h>
    #include <stdlib.h>
  
    int main() {
      char d[1000000] = { '\0' };
      FILE *f = fopen("d3.txt", "r");
      fread(d, 1, 1000000, f);
    
      int visited[10000][2];
      int visited_size = 0;
    
      int x = 0;
      int y = 0;
      int robox = 0;
      int roboy = 0;
    
      visited[visited_size][0] = x;
      visited[visited_size][1] = y;
      visited_size++;
    
      for (int i = 0; d[i] != '\0'; i++) {
        if (i % 2 == 0) {
          switch (d[i]) {
          case '<': x--; break;
          case '>': x++; break;
          case '^': y--; break;
          case 'v': y++; break;
          default: continue;
          }
          visited[visited_size][0] = x;
          visited[visited_size][1] = y;
          visited_size++;
        } else {
          switch (d[i]) {
          case '<': robox--; break;
          case '>': robox++; break;
          case '^': roboy--; break;
          case 'v': roboy++; break;
          default: continue;
          }
          visited[visited_size][0] = robox;
          visited[visited_size][1] = roboy;
          visited_size++;
        }
      }
    
      // insertion sort
      for (int i = 0; i < visited_size; i++) {
        int j = i;
        int jx = visited[j][0];
        int jy = visited[j][1];
         while (j > 0 &&
               (jx < visited[j - 1][0]
                || (jx == visited[j - 1][0] && jy < visited[j - 1][1]))) {
            visited[j][0] = visited[j - 1][0];
            visited[j][1] = visited[j - 1][1];
            j--;
          }
        visited[j][0] = jx;
        visited[j][1] = jy;
      }
    
      int prevx = 0;
      int prevy = 0;
      int unique_visits = 0;
      int first = 1;
      for (int i = 0; i < visited_size; i++) {
        if (first || visited[i][0] != prevx || visited[i][1] != prevy) {
          first = 0;
          unique_visits++;
          prevx = visited[i][0];
          prevy = visited[i][1];
        }
      }
      
      printf("%d", unique_visits);
      return 0;
    }
#+END_SRC

#+RESULTS:
: 2631

** puzzle 2b
#+BEGIN_SRC cpp
    #include <stdio.h>
    #include <stdlib.h>

    int compare(const void *a, const void *b) {
      int *aa = (int*) a;
      int *bb = (int*) b;
      if (aa[0] < bb[0]) {
        return -1;
      } else if (aa[0] == bb[0]) {
        if (aa[1] < bb[1]) {
          return -1;
        } else if (aa[1] == bb[1]) {
          return 0;
        } else {
          return 1;
        }
      } else {
        return 1;
      }
    }
  
    int main() {
      char d[1000000] = { '\0' };
      FILE *f = fopen("d3.txt", "r");
      fread(d, 1, 1000000, f);
    
      int visited[10000][2];
      int visited_size = 0;
    
      int x = 0;
      int y = 0;
      int robox = 0;
      int roboy = 0;
    
      visited[visited_size][0] = x;
      visited[visited_size][1] = y;
      visited_size++;
    
      for (int i = 0; d[i] != '\0'; i++) {
        if (i % 2 == 0) {
          switch (d[i]) {
          case '<': x--; break;
          case '>': x++; break;
          case '^': y--; break;
          case 'v': y++; break;
          default: continue;
          }
          visited[visited_size][0] = x;
          visited[visited_size][1] = y;
          visited_size++;
        } else {
          switch (d[i]) {
          case '<': robox--; break;
          case '>': robox++; break;
          case '^': roboy--; break;
          case 'v': roboy++; break;
          default: continue;
          }
          visited[visited_size][0] = robox;
          visited[visited_size][1] = roboy;
          visited_size++;
        }
      }

      qsort(visited, visited_size, sizeof(int[2]), compare);
    
      int prevx = 0;
      int prevy = 0;
      int unique_visits = 0;
      int first = 1;
      for (int i = 0; i < visited_size; i++) {
        if (first || visited[i][0] != prevx || visited[i][1] != prevy) {
          first = 0;
          unique_visits++;
          prevx = visited[i][0];
          prevy = visited[i][1];
        }
      }
      
      printf("%d", unique_visits);
      return 0;
    }
#+END_SRC

#+RESULTS:
: 2631

- 2631

* day 4
** text
--- Day 4: The Ideal Stocking Stuffer ---

Santa needs help mining some AdventCoins (very similar to bitcoins) to use as gifts for all the economically forward-thinking little girls and boys.

To do this, he needs to find MD5 hashes which, in hexadecimal, start with at least five zeroes. The input to the MD5 hash is some secret key (your puzzle input, given below) followed by a number in decimal. To mine AdventCoins, you must find Santa the lowest positive number (no leading zeroes: 1, 2, 3, ...) that produces such a hash.

For example:

    If your secret key is abcdef, the answer is 609043, because the MD5 hash of abcdef609043 starts with five zeroes (000001dbbfa...), and it is the lowest such number to do so.
    If your secret key is pqrstuv, the lowest number it combines with to make an MD5 hash starting with five zeroes is 1048970; that is, the MD5 hash of pqrstuv1048970 looks like 000006136ef....

Your puzzle answer was 282749.
--- Part Two ---

Now find one that starts with six zeroes.

Your puzzle answer was 9962624.
** puzzle 1
#+BEGIN_SRC cpp :tangle d4p1.c
  #include <stdio.h>
  #include <openssl/md5.h>
  #include <unistd.h>
  #include <string.h>
  int main() {
    char in[1024] = { '\0' };
    unsigned char out[16] = { '\0' };
    char outhex[33] = { '\0' };
    const char *salt = "yzbqklnj";

    for (int i = 0; i < 1000000; i++) {
      int in_size = sprintf(in, "%s%d", salt, i);
      MD5((unsigned char*)in, in_size, out);

      char tmp[3];
      for (int j = 0; j < 16; j++) {
        sprintf(tmp, "%02X", out[j]);
        outhex[j * 2] = tmp[0];
        outhex[j * 2 + 1] = tmp[1];
      }

      if (strncmp(outhex, "00000", 5) == 0) {
        printf("%d", i);
        return 0;
      }
    }
    return 0;
  }
#+END_SRC
(require 'ob-sh)
(defun org-babel-get-header (a b))
#+BEGIN_SRC sh :results output :var DUMMY=(org-babel-tangle)
gcc -std=c99 d4p1.c -o d4p1 -lcrypto
./d4p1
#+END_SRC

#+RESULTS:
: foo
: 282749

** puzzle 2
#+BEGIN_SRC cpp :tangle d4p2.c
  #include <stdio.h>
  #include <openssl/md5.h>
  #include <unistd.h>
  #include <string.h>
  int main() {
    char in[1024] = { '\0' };
    unsigned char out[16] = { '\0' };
    char outhex[33] = { '\0' };
    const char *salt = "yzbqklnj";

    for (int i = 0; i < 10000000; i++) {
      int in_size = sprintf(in, "%s%d", salt, i);
      MD5((unsigned char*)in, in_size, out);

      char tmp[3];
      for (int j = 0; j < 16; j++) {
        sprintf(tmp, "%02X", out[j]);
        outhex[j * 2] = tmp[0];
        outhex[j * 2 + 1] = tmp[1];
      }

      if (strncmp(outhex, "000000", 6) == 0) {
        printf("%d", i);
        return 0;
      }
    }
    return 0;
  }
#+END_SRC
(require 'ob-sh)
(defun org-babel-get-header (a b))
#+BEGIN_SRC sh :results output :var DUMMY=(org-babel-tangle)
gcc -std=c99 d4p2.c -o d4p2 -lcrypto
./d4p2
#+END_SRC

#+RESULTS:
: 9962624

* day 5
** text
--- Day 5: Doesn't He Have Intern-Elves For This? ---

Santa needs help figuring out which strings in his text file are naughty or nice.

A nice string is one with all of the following properties:

    It contains at least three vowels (aeiou only), like aei, xazegov, or aeiouaeiouaeiou.
    It contains at least one letter that appears twice in a row, like xx, abcdde (dd), or aabbccdd (aa, bb, cc, or dd).
    It does not contain the strings ab, cd, pq, or xy, even if they are part of one of the other requirements.

For example:

    ugknbfddgicrmopn is nice because it has at least three vowels (u...i...o...), a double letter (...dd...), and none of the disallowed substrings.
    aaa is nice because it has at least three vowels and a double letter, even though the letters used by different rules overlap.
    jchzalrnumimnmhp is naughty because it has no double letter.
    haegwjzuvuyypxyu is naughty because it contains the string xy.
    dvszwmarrgswjxmb is naughty because it contains only one vowel.

How many strings are nice?

Your puzzle answer was 238.
--- Part Two ---

Realizing the error of his ways, Santa has switched to a better model of determining whether a string is naughty or nice. None of the old rules apply, as they are all clearly ridiculous.

Now, a nice string is one with all of the following properties:

    It contains a pair of any two letters that appears at least twice in the string without overlapping, like xyxy (xy) or aabcdefgaa (aa), but not like aaa (aa, but it overlaps).
    It contains at least one letter which repeats with exactly one letter between them, like xyx, abcdefeghi (efe), or even aaa.

For example:

    qjhvhtzxzqqjkmpb is nice because is has a pair that appears twice (qj) and a letter that repeats with exactly one letter between them (zxz).
    xxyxx is nice because it has a pair that appears twice and a letter that repeats with one between, even though the letters used by each rule overlap.
    uurcxstgmygtbstg is naughty because it has a pair (tg) but no repeat with a single letter between them.
    ieodomkazucvgmuy is naughty because it has a repeating letter with one between (odo), but no pair that appears twice.

How many strings are nice under these new rules?

Your puzzle answer was 69.
** data
#+BEGIN_SRC text :tangle d5.txt :padline no
zgsnvdmlfuplrubt
vlhagaovgqjmgvwq
ffumlmqwfcsyqpss
zztdcqzqddaazdjp
eavfzjajkjesnlsb
urrvucyrzzzooxhx
xdwduffwgcptfwad
orbryxwrmvkrsxsr
jzfeybjlgqikjcow
mayoqiswqqryvqdi
iiyrkoujhgpgkcvx
egcgupjkqwfiwsjl
zbgtglaqqolttgng
eytquncjituzzhsx
dtfkgggvqadhqbwb
zettygjpcoedwyio
rwgwbwzebsnjmtln
esbplxhvzzgawctn
vnvshqgmbotvoine
wflxwmvbhflkqxvo
twdjikcgtpvlctte
minfkyocskvgubvm
sfxhhdhaopajbzof
sofkjdtalvhgwpql
uqfpeauqzumccnrc
tdflsbtiiepijanf
dhfespzrhecigzqb
xobfthcuuzhvhzpn
olgjglxaotocvrhw
jhkzpfcskutwlwge
zurkakkkpchzxjhq
hekxiofhalvmmkdl
azvxuwwfmjdpjskj
arsvmfznblsqngvb
ldhkzhejofreaucc
adrphwlkehqkrdmo
wmveqrezfkaivvaw
iyphmphgntinfezg
blomkvgslfnvspem
cgpaqjvzhbumckwo
ydhqjcuotkeyurpx
sbtzboxypnmdaefr
vxrkhvglynljgqrg
ttgrkjjrxnxherxd
hinyfrjdiwytetkw
sufltffwqbugmozk
tohmqlzxxqzinwxr
jbqkhxfokaljgrlg
fvjeprbxyjemyvuq
gmlondgqmlselwah
ubpwixgxdloqnvjp
lxjfhihcsajxtomj
qouairhvrgpjorgh
nloszcwcxgullvxb
myhsndsttanohnjn
zjvivcgtjwenyilz
qaqlyoyouotsmamm
tadsdceadifqthag
mafgrbmdhpnlbnks
aohjxahenxaermrq
ovvqestjhbuhrwlr
lnakerdnvequfnqb
agwpwsgjrtcjjikz
lhlysrshsmzryzes
xopwzoaqtlukwwdu
xsmfrfteyddrqufn
ohnxbykuvvlbbxpf
bbdlivmchvzfuhoc
vtacidimfcfyobhf
tinyzzddgcnmiabd
tcjzxftqcqrivqhn
vgnduqyfpokbmzim
revkvaxnsxospyow
ydpgwxxoxlywxcgi
wzuxupbzlpzmikel
nscghlafavnsycjh
xorwbquzmgmcapon
asmtiycegeobfxrn
eqjzvgkxgtlyuxok
mmjrskloposgjoqu
gceqosugbkvytfto
khivvoxkvhrgwzjl
qtmejuxbafroifjt
ttmukbmpoagthtfl
bxqkvuzdbehtduwv
gvblrpzjylanoggj
cltewhyjxdbmbtqj
fbkgedqvomdipklj
uxvuplhenqawfcjt
fkdjmayiawdkycva
gnloqfgbnibzyidh
kyzorvtopjiyyyqg
drckpekhpgrioblt
tvhrkmbnpmkkrtki
khaldwntissbijiz
aoojqakosnaxosom
xfptccznbgnpfyqw
moqdwobwhjxhtrow
chfwivedutskovri
gprkyalfnpljcrmi
pwyshpwjndasykst
xuejivogihttzimd
bugepxgpgahtsttl
zufmkmuujavcskpq
urybkdyvsrosrfro
isjxqmlxwtqmulbg
pxctldxgqjqhulgz
hclsekryiwhqqhir
hbuihpalwuidjpcq
ejyqcxmfczqfhbxa
xljdvbucuxnnaysv
irqceqtqwemostbb
anfziqtpqzqdttnz
cgfklbljeneeqfub
zudyqkuqqtdcpmuo
iuvhylvznmhbkbgg
mpgppmgfdzihulnd
argwmgcvqqkxkrdi
pdhrfvdldkfihlou
cbvqnjrvrsnqzfob
lkvovtsqanohzcmm
vxoxjdyoylqcnyzt
kurdpaqiaagiwjle
gwklwnazaxfkuekn
rbaamufphjsjhbdl
tzbrvaqvizhsisbd
pbcqlbfjvlideiub
hiwoetbfywaeddtx
fjirczxtuupfywyf
omeoegeyyospreem
ozbbpupqpsskvrjh
pzvcxkvjdiyeyhxa
odclumkenabcsfzr
npdyqezqdjqaszvm
yodkwzmrhtexfrqa
rjcmmggjtactfrxz
mioxfingsfoimual
aqskaxjjborspfaa
wientdsttkevjtkf
tdaswkzckmxnfnct
voucjhzvkkhuwoqk
boaaruhalgaamqmh
iufzxutxymorltvb
pfbyvbayvnrpijpo
obztirulgyfthgcg
ntrenvhwxypgtjwy
ephlkipjfnjfjrns
pkjhurzbmobhszpx
gqbnjvienzqfbzvj
wjelolsrbginwnno
votanpqpccxqricj
bxyuyiglnmbtvehi
qyophcjfknbcbjrb
anoqkkbcdropskhj
tcnyqaczcfffkrtl
rsvqimuqbuddozrf
meppxdrenexxksdt
tyfhfiynzwadcord
wayrnykevdmywycf
mhowloqnppswyzbu
tserychksuwrgkxz
xycjvvsuaxsbrqal
fkrdsgaoqdcqwlpn
vrabcmlhuktigecp
xgxtdsvpaymzhurx
ciabcqymnchhsxkc
eqxadalcxzocsgtr
tsligrgsjtrnzrex
qeqgmwipbspkbbfq
vzkzsjujltnqwliw
ldrohvodgbxokjxz
jkoricsxhipcibrq
qzquxawqmupeujrr
mizpuwqyzkdbahvk
suupfxbtoojqvdca
ywfmuogvicpywpwm
uevmznxmsxozhobl
vjbyhsemwfwdxfxk
iyouatgejvecmtin
tcchwpuouypllcxe
lgnacnphdiobdsef
uoxjfzmdrmpojgbf
lqbxsxbqqhpjhfxj
knpwpcnnimyjlsyz
fezotpoicsrshfnh
dkiwkgpmhudghyhk
yzptxekgldksridv
pckmzqzyiyzdbcts
oqshafncvftvwvsi
yynihvdywxupqmbt
iwmbeunfiuhjaaic
pkpkrqjvgocvaxjs
ieqspassuvquvlyz
xshhahjaxjoqsjtl
fxrrnaxlqezdcdvd
pksrohfwlaqzpkdd
ravytrdnbxvnnoyy
atkwaifeobgztbgo
inkcabgfdobyeeom
ywpfwectajohqizp
amcgorhxjcybbisv
mbbwmnznhafsofvr
wofcubucymnhuhrv
mrsamnwvftzqcgta
tlfyqoxmsiyzyvgv
ydceguvgotylwtea
btyvcjqhsygunvle
usquiquspcdppqeq
kifnymikhhehgote
ybvkayvtdpgxfpyn
oulxagvbavzmewnx
tvvpekhnbhjskzpj
azzxtstaevxurboa
nfmwtfgrggmqyhdf
ynyzypdmysfwyxgr
iaobtgubrcyqrgmk
uyxcauvpyzabbzgv
fbasfnwiguasoedc
mgmjoalkbvtljilq
szgkxiqkufdvtksb
xgfzborpavdmhiuj
hmuiwnsonvfgcrva
zolcffdtobfntifb
mvzgcsortkugvqjr
pbbpgraaldqvzwhs
zvsxegchksgnhpuv
kdpdboaxsuxfswhx
jdfggigejfupabth
tpeddioybqemyvqz
mxsntwuesonybjby
tzltdsiojfvocige
ubtdrneozoejiqrv
fusyucnhncoxqzql
nlifgomoftdvkpby
pyikzbxoapffbqjw
hzballplvzcsgjug
ymjyigsfehmdsvgz
vpqgyxknniunksko
ffkmaqsjxgzclsnq
jcuxthbedplxhslk
ymlevgofmharicfs
nyhbejkndhqcoisy
rjntxasfjhnlizgm
oqlnuxtzhyiwzeto
tntthdowhewszitu
rmxyoceuwhsvfcua
qpgsjzwenzbxyfgw
sumguxpdkocyagpu
ymfrbxwrawejkduu
hetgrtmojolbmsuf
qzqizpiyfasgttex
qnmoemcpuckzsshx
ddyqiihagcmnxccu
oirwxyfxxyktgheo
phpaoozbdogbushy
uctjdavsimsrnvjn
aurbbphvjtzipnuh
hpbtrubopljmltep
pyyvkthqfsxqhrxg
jdxaiqzkepxbfejk
ukgnwbnysrzvqzlw
lfkatkvcssnlpthd
ucsyecgshklhqmsc
rwdcbdchuahkvmga
rxkgqakawgpwokum
hbuyxeylddfgorgu
tbllspqozaqzglkz
rqfwizjlbwngdvvi
xuxduyzscovachew
kouiuxckkvmetvdy
ycyejrpwxyrweppd
trctlytzwiisjamx
vtvpjceydunjdbez
gmtlejdsrbfofgqy
jgfbgtkzavcjlffj
tyudxlpgraxzchdk
gyecxacqitgozzgd
rxaocylfabmmjcvt
tornfzkzhjyofzqa
kocjcrqcsvagmfqv
zfrswnskuupivzxb
cunkuvhbepztpdug
pmpfnmklqhcmrtmf
tfebzovjwxzumxap
xpsxgaswavnzkzye
lmwijdothmxclqbr
upqxhmctbltxkarl
axspehytmyicthmq
xdwrhwtuooikehbk
tpggalqsytvmwerj
jodysbwnymloeqjf
rxbazvwuvudqlydn
ibizqysweiezhlqa
uexgmotsqjfauhzp
ldymyvumyhyamopg
vbxvlvthgzgnkxnf
pyvbrwlnatxigbrp
azxynqididtrwokb
lwafybyhpfvoawto
ogqoivurfcgspytw
cinrzzradwymqcgu
sgruxdvrewgpmypu
snfnsbywuczrshtd
xfzbyqtyxuxdutpw
fmpvjwbulmncykbo
ljnwoslktrrnffwo
ceaouqquvvienszn
yjomrunrxjyljyge
xpmjsapbnsdnbkdi
uetoytptktkmewre
eixsvzegkadkfbua
afaefrwhcosurprw
bwzmmvkuaxiymzwc
gejyqhhzqgsrybni
gjriqsfrhyguoiiw
gtfyomppzsruhuac
ogemfvmsdqqkfymr
jgzbipsygirsnydh
zghvlhpjnvqmocgr
ngvssuwrbtoxtrka
ietahyupkbuisekn
gqxqwjizescbufvl
eiprekzrygkncxzl
igxfnxtwpyaamkxf
soqjdkxcupevbren
fspypobyzdwstxak
qstcgawvqwtyyidf
gsccjacboqvezxvd
bfsblokjvrqzphmc
srezeptvjmncqkec
opmopgyabjjjoygt
msvbufqexfrtecbf
uiaqweyjiulplelu
pbkwhjsibtwjvswi
xwwzstmozqarurrq
nytptwddwivtbgyq
ejxvsufbzwhzpabr
jouozvzuwlfqzdgh
gfgugjihbklbenrk
lwmnnhiuxqsfvthv
bzvwbknfmaeahzhi
cgyqswikclozyvnu
udmkpvrljsjiagzi
zzuhqokgmisguyna
ekwcdnjzuctsdoua
eueqkdrnzqcaecyd
lnibwxmokbxhlris
fdrbftgjljpzwhea
iabvuhhjsxmqfwld
qgogzkynrgejakta
mfcqftytemgnpupp
klvhlhuqhosvjuqk
gdokmxcgoqvzvaup
juududyojcazzgvr
fyszciheodgmnotg
yfpngnofceqfvtfs
cahndkfehjumwavc
dxsvscqukljxcqyi
cqukcjtucxwrusji
vevmmqlehvgebmid
ahswsogfrumzdofy
ftasbklvdquaxhxb
tsdeumygukferuif
ybfgbwxaaitpwryg
djyaoycbymezglio
trzrgxdjqnmlnzpn
rumwchfihhihpqui
ffrvnsgrnzemksif
oizlksxineqknwzd
cirqcprftpjzrxhk
zrhemeqegmzrpufd
kqgatudhxgzlgkey
syjugymeajlzffhq
nlildhmgnwlopohp
flcszztfbesqhnyz
ohzicmqsajyqptrw
ebyszucgozsjbelq
enxbgvvcuqeloxud
ubwnvecbsmhkxwuk
noifliyxvlkqphbo
hazlqpetgugxxsiz
ihdzoerqwqhgajzb
ivrdwdquxzhdrzar
synwycdvrupablib
mqkdjkntblnmtvxj
qmmvoylxymyovrnq
pjtuxskkowutltlq
gchrqtloggkrjciz
namzqovvsdipazae
yfokqhkmakyjzmys
iapxlbuoiwqfnozm
fbcmlcekgfdurqxe
ednzgtczbplwxjlq
gdvsltzpywffelsp
oaitrrmpqdvduqej
gseupzwowmuuibjo
dfzsffsqpaqoixhh
tclhzqpcvbshxmgx
cfqkptjrulxiabgo
iraiysmwcpmtklhf
znwjlzodhktjqwlm
lcietjndlbgxzjht
gdkcluwjhtaaprfo
vbksxrfznjzwvmmt
vpfftxjfkeltcojl
thrmzmeplpdespnh
yafopikiqswafsit
xxbqgeblfruklnhs
qiufjijzbcpfdgig
ikksmllfyvhyydmi
sknufchjdvccccta
wpdcrramajdoisxr
grnqkjfxofpwjmji
lkffhxonjskyccoh
npnzshnoaqayhpmb
fqpvaamqbrnatjia
oljkoldhfggkfnfc
ihpralzpqfrijynm
gvaxadkuyzgbjpod
onchdguuhrhhspen
uefjmufwlioenaus
thifdypigyihgnzo
ugqblsonqaxycvkg
yevmbiyrqdqrmlbw
bvpvwrhoyneorcmm
gbyjqzcsheaxnyib
knhsmdjssycvuoqf
nizjxiwdakpfttyh
nwrkbhorhfqqoliz
ynsqwvwuwzqpzzwp
yitscrgexjfclwwh
dhajwxqdbtrfltzz
bmrfylxhthiaozpv
frvatcvgknjhcndw
xlvtdmpvkpcnmhya
pxpemuzuqzjlmtoc
dijdacfteteypkoq
knrcdkrvywagglnf
fviuajtspnvnptia
xvlqzukmwbcjgwho
bazlsjdsjoeuvgoz
nslzmlhosrjarndj
menvuwiuymknunwm
uavfnvyrjeiwqmuu
yrfowuvasupngckz
taevqhlrcohlnwye
skcudnogbncusorn
omtnmkqnqedsajfv
yqmgsqdgsuysqcts
odsnbtyimikkbmdd
vuryaohxdvjllieb
dhaxldeywwsfamlo
opobvtchezqnxpak
pzfnegouvsrfgvro
rzkcgpxdslzrdktu
ksztdtqzxvhuryam
ctnqnhkcooqipgkh
pyqbbvrzdittqbgm
koennvmolejeftij
rvzlreqikqlgyczj
xrnujfoyhonzkdgd
mmsmhkxaiqupfjil
ypjwoemqizddvyfd
qgugcxnbhvgahykj
cviodlsrtimbkgmy
xbfbbechhmrjxhnw
psuipaoucfczfxkp
hdhwcpeuptgqqvim
gsxlruhjeaareilr
vgyqonnljuznyrhk
eewezahlumervpyu
iiolebrxfadtnigy
tdadlrodykrdfscn
ocvdtzjxrhtjurpo
gidljbuvuovkhhrf
qwfcpilbjwzboohd
xzohxonlezuiupbg
vslpbkkqgvgbcbix
pivzqrzfxosbstzn
fyqcfboevcqmbhhs
yqsrneacnlxswojx
heicqpxxyrwcbsjz
yzynmnnoumkmlbeh
bncadbjdvvmczylw
hlnjskgfzbgmigfn
fphpszymugpcykka
zbifcktanxpmufvy
saklpkhoyfeqbguy
nqtqfcfxmpivnjyo
locygrwerxlsvzqm
qqflecydqvlogjme
njklmixvgkzpgppf
ugzkpjwjflaswyma
lriousvkbeftslcy
nsvsauxzfbbotgmh
tblcpuhjyybrlica
hqwshxcilwtmxrsf
xojwroydfeoqupup
tikuzsrogpnohpib
layenyqgxdfggloc
nqsvjvbrpuxkqvmq
ivchgxkdlfjdzxmk
uoghiuosiiwiwdws
twsgsfzyszsfinlc
waixcmadmhtqvcmd
zkgitozgrqehtjkw
xbkmyxkzqyktmpfi
qlyapfmlybmatwxn
ntawlvcpuaebuypf
clhebxqdkcyndyof
nrcxuceywiklpemc
lmurgiminxpapzmq
obalwqlkykzflxou
huvcudpiryefbcye
zlxbddpnyuyapach
gqfwzfislmwzyegy
jhynkjtxedmemlob
hmrnvjodnsfiukex
pstmikjykzyavfef
wuwpnscrwzsyalyt
hksvadripgdgwynm
tvpfthzjleqfxwkh
xpmrxxepkrosnrco
qjkqecsnevlhqsly
jjnrfsxzzwkhnwdm
pehmzrzsjngccale
bsnansnfxduritrr
ejzxkefwmzmbxhlb
pceatehnizeujfrs
jtidrtgxopyeslzl
sytaoidnamfwtqcr
iabjnikomkgmyirr
eitavndozoezojsi
wtsbhaftgrbqfsmm
vvusvrivsmhtfild
qifbtzszfyzsjzyx
ifhhjpaqatpbxzau
etjqdimpyjxiuhty
fvllmbdbsjozxrip
tjtgkadqkdtdlkpi
xnydmjleowezrecn
vhcbhxqalroaryfn
scgvfqsangfbhtay
lbufpduxwvdkwhmb
tshipehzspkhmdoi
gtszsebsulyajcfl
dlrzswhxajcivlgg
kgjruggcikrfrkrw
xxupctxtmryersbn
hljjqfjrubzozxts
giaxjhcwazrenjzs
tyffxtpufpxylpye
jfugdxxyfwkzqmgv
kbgufbosjghahacw
xpbhhssgegmthwxb
npefofiharjypyzk
velxsseyxuhrpycy
sglslryxsiwwqzfw
susohnlpelojhklv
lfnpqfvptqhogdmk
vtcrzetlekguqyle
jlyggqdtamcjiuxn
olxxqfgizjmvigvl
cyypypveppxxxfuq
hewmxtlzfqoqznwd
jzgxxybfeqfyzsmp
xzvvndrhuejnzesx
esiripjpvtqqwjkv
xnhrwhjtactofwrd
knuzpuogbzplofqx
tihycsdwqggxntqk
xkfywvvugkdalehs
cztwdivxagtqjjel
dsaslcagopsbfioy
gmowqtkgrlqjimbl
ctcomvdbiatdvbsd
gujyrnpsssxmqjhz
nygeovliqjfauhjf
mmgmcvnuppkbnonz
bhipnkoxhzcotwel
wkwpgedgxvpltqid
mliajvpdocyzcbot
kqjhsipuibyjuref
zqdczykothbgxwsy
koirtljkuqzxioaz
audpjvhmqzvhzqas
cxyhxlhntyidldfx
iasgocejboxjgtkx
abehujmqotwcufxp
fmlrzqmazajxeedl
knswpkekbacuxfby
yvyalnvrxgstqhxm
sjnrljfrfuyqfwuw
ssaqruwarlvxrqzm
iaxbpeqqzlcwfqjz
uwyxshjutkanvvsc
uxwrlwbblcianvnb
nodtifgrxdojhneh
mloxjfusriktxrms
lkfzrwulbctupggc
gcrjljatfhitcgfj
tkdfxeanwskaivqs
ypyjxqtmitwubbgt
ssxbygzbjsltedjj
zdrsnoorwqfalnha
xlgmissaiqmowppd
azhbwhiopwpguiuo
fydlahgxtekbweet
qtaveuqpifprdoiy
kpubqyepxqleucem
wlqrgqmnupwiuory
rwyocktuqkuhdwxz
abzjfsdevoygctqv
zsofhaqqghncmzuw
lqbjwjqxqbfgdckc
bkhyxjkrqbbunido
yepxfjnnhldidsjb
builayfduxbppafc
wedllowzeuswkuez
gverfowxwtnvgrmo
tpxycfumxdqgntwf
lqzokaoglwnfcolw
yqsksyheyspmcdqt
vufvchcjjcltwddl
saeatqmuvnoacddt
dxjngeydvsjbobjs
ucrcxoakevhsgcep
cajgwjsfxkasbayt
hknzmteafsfemwuv
xxwhxwiinchqqudr
usfenmavvuevevgr
kxcobcwhsgyizjok
vhqnydeboeunnvyk
bgxbwbxypnxvaacw
bwjzdypacwgervgk
rrioqjluawwwnjcr
fiaeyggmgijnasot
xizotjsoqmkvhbzm
uzphtrpxwfnaiidz
kihppzgvgyoncptg
hfbkfrxwejdeuwbz
zgqthtuaqyrxicdy
zitqdjnnwhznftze
jnzlplsrwovxlqsn
bmwrobuhwnwivpca
uuwsvcdnoyovxuhn
nmfvoqgoppoyosaj
hxjkcppaisezygpe
icvnysgixapvtoos
vbvzajjgrmjygkhu
jinptbqkyqredaos
dpmknzhkhleawfvz
ouwwkfhcedsgqqxe
owroouiyptrijzgv
bewnckpmnbrmhfyu
evdqxevdacsbfbjb
catppmrovqavxstn
dqsbjibugjkhgazg
mkcldhjochtnvvne
sblkmhtifwtfnmsx
lynnaujghehmpfpt
vrseaozoheawffoq
ytysdzbpbazorqes
sezawbudymfvziff
vrlfhledogbgxbau
bipdlplesdezbldn
ermaenjunjtbekeo
eyaedubkthdecxjq
gbzurepoojlwucuy
rsiaqiiipjlouecx
beqjhvroixhiemtw
buzlowghhqbcbdwv
ldexambveeosaimo
fpyjzachgrhxcvnx
komgvqejojpnykol
fxebehjoxdujwmfu
jnfgvheocgtvmvkx
qmcclxxgnclkuspx
rsbelzrfdblatmzu
vexzwqjqrsenlrhm
tnfbkclwetommqmh
lzoskleonvmprdri
nnahplxqscvtgfwi
ubqdsflhnmiayzrp
xtiyqxhfyqonqzrn
omdtmjeqhmlfojfr
cnimgkdbxkkcnmkb
tapyijgmxzbmqnks
byacsxavjboovukk
awugnhcrygaoppjq
yxcnwrvhojpuxehg
btjdudofhxmgqbao
nzqlfygiysfuilou
nubwfjdxavunrliq
vqxmmhsbmhlewceh
ygavmcybepzfevrp
kgflmrqsvxprkqgq
iaqyqmcaedscmakk
cvbojnbfmrawxzkh
jjjrprbnlijzatuw
lcsudrrfnnggbrmk
qzgxbiavunawfibc
gnnalgfvefdfdwwg
nokmiitzrigxavsc
etzoxwzxqkkhvais
urxxfacgjccieufi
lqrioqhuvgcotuec
dydbaeyoypsbftra
hhrotenctylggzaf
evctqvzjnozpdxzu
tbpvithmorujxlcp
pllbtcbrtkfpvxcw
fzyxdqilyvqreowv
xdleeddxwvqjfmmt
fcldzthqqpbswoin
sgomzrpjfmvgwlzi
axjyskmtdjbxpwoz
hcvaevqxsmabvswh
lfdlsfcwkwicizfk
isjbwpzdognhoxvm
oqnexibqxlyxpluh
zqfbgodsfzwgcwuf
kvmnwruwsjllbldz
kghazimdyiyhmokj
uiktgpsxpoahofxn
zkdwawxargcmidct
ftbixlyiprshrjup
nofhmbxififwroeg
mcdaqrhplffxrcdt
fbjxnwojcvlawmlb
rizoftvwfdhiwyac
eduogrtyhxfwyars
zoikunqxgjwfqqwr
zxwbbpmvctzezaqh
nghujwyeabwdqnop
vcxamijpoyyksogn
jnckdbuteoqlsdae
jurfqqawafmsiqwv
inepmztrzehfafie
tznzkyvzodbrtscf
xewbavjeppflwscl
ucndzsorexjlnplo
jpxbctscngxgusvu
mfmygcllauzuoaok
oibkuxhjmhxhhzby
zjkslwagmeoisunw
avnnxmopdgvmukuu
jmaargejcwboqhkt
yacmpeosarsrfkrv
iqhgupookcaovwgh
ebjkdnxwtikqzufc
imdhbarytcscbsvb
ifyibukeffkbqvcr
aloighmyvwybtxhx
yszqwrutbkiwkxjg
xyholyzlltjhsuhp
gykhmrwucneoxcrf
badkdgqrpjzbabet
sunaucaucykwtkjj
pumqkglgfdhneero
usgtyuestahlydxq
xmfhflphzeudjsjm
knywgmclisgpootg
mtojnyrnvxtweuzb
uuxufbwfegysabww
vobhwwocqttlbsik
yuydfezeqgqxqmnd
wbqgqkwbibiilhzc
sfdmgxsbuzsawush
ilhbxcfgordyxwvp
ahqoavuysblnqaeg
plwgtvpgotskmsey
ewjcmzkcnautrrmp
tyekgzbznlikcyqj
bqzctiuaxpriuiga
bimvbfjkiupyqiys
mpqtbcxfhwymxncw
htemlptvqhharjgb
mqbsmsruwzzxgcxc
zjyedjwhnvteuaid
pzoelkoidwglpttc
efydnsvlfimvwxhx
gfyhgoeiyjcgfyze
deqtomhwopmzvjlt
casafubtkoopuaju
yylsfarntbucfulg
mgjwsormkjsrrxan
lkkenpupgmjpnqqd
tegweszyohsoluot
lihsfdwxmxvwdxna
rrefrjjxerphejwb
guuazonjoebhymtm
ysofqzmfmyneziki
lmjgaliatcpduoal
qzthcpjwtgahbebr
wvakvephyukmpemm
simxacxxzfoaeddw
aetgqmiqzxbvbviz
jxlmhdmqggevrxes
mmuglnjmuddzgaik
svopsqhtrslgycgc
xnvcsiiqrcjkvecn
kkvumxtvashxcops
bduflsdyeectvcgl
vfrxbwmmytjvqnsj
eeqtdneiyiaiofxw
crtbgknfacjtwkfl
uuutuoxdsxolpbhd
lcrztwzreaswovtn
htorkvnvujmjdqzj
wttzuzvrzlyhfzyf
oraewznfwgdsnhuk
rctlkqqvkwbgrcgk
cfehrsrqhzyiwtmz
kbvxwcumjkhvjpui
xxlocexbmniiakfo
gtknkkzvykmlqghl
kcjuxvkuimhwqrtk
vohekwkuyuoacuww
vorctgughscysyfo
zmjevqplngzswxyq
qhswdrhrijnatkyo
joakcwpfggtitizs
juzlwjijcmtswdtq
icbyaqohpkemhkip
rpdxgpzxncedmvzh
rozkmimbqhbhcddv
wkkypomlvyglpfpf
jcaqyaqvsefwtaya
ghvmtecoxlebdwnf
lqrcyiykkkpkxvqt
eqlarfazchmzotev
vqwndafvmpguggef
dbfxzrdkkrusmdke
cmjpjjgndozcmefj
hbrdcwjuyxapyhlo
mmforetykbosdwce
zynfntqwblbnfqik
sodwujfwlasznaiz
yyvrivjiqnxzqkfp
uldbskmmjbqllpnm
fyhhrmrsukeptynl
hpfjekktvdkgdkzl
bozhkoekcxzeorob
uvpptyfrzkvmtoky
hkhfprmjdpjvfkcb
igxzwktwsqhsivqu
qceomwysgkcylipb
cglateoynluyeqgc
xcsdfkpeguxgvpfh
owjhxlcncdgkqyia
rpbmrpcesiakqpna
lueszxiourxsmezb
zelvsowimzkxliwc
vzxbttoobtvdtkca
pfxvzphzwscqkzsi
edsjorainowytbzu
ipsegdaluoiphmnz
mkhueokfpemywvuw
urxdnumhylpafdlc
ggluurzavsxkvwkl
ctclphidqgteakox
tfobosynxsktajuk
jzrmemhxqmzhllif
eemwekimdfvqslsx
yjkwpzrbanoaajgq
rlxghzanuyeimfhx
hozbgdoorhthlqpv
obkbmflhyanxilnx
xojrippyxjmpzmsz
ukykmbfheixuviue
qivlmdexwucqkres
rmyxxipqkarpjmox
fgaftctbvcvnrror
raawxozucfqvasru
dinpjbdfjfizexdh
gybxubwnnbuyvjcr
qrqitdvyoneqyxcg
jqzcfggayzyoqteo
cikqpvxizpdbmppm
stfpldgyhfmucjjv
slzbcuihmimpduri
aufajwfrsorqqsnl
iylmzraibygmgmqj
lcdyfpcqlktudfmu
pmomzzsdpvgkkliw
zpplirgtscfhbrkj
mvhyerxfiljlotjl
ofkvrorwwhusyxjx
xngzmvcgkqfltjpe
yxfxaqipmysahqqq
sdqafdzgfdjuabup
qcqajmerahcdgxfv
xqimrqtupbapawro
qfvkqwidzzrehsbl
himixxvueksiqfdf
vgtfqpuzxxmhrvvd
adiioqeiejguaost
jnzxuycjxvxehbvm
xedbpxdhphamoodk
jsrioscmwlsfuxrg
mtsynnfxunuohbnf
enamqzfzjunnnkpe
uwcvfecunobyhces
ciygixtgbsccpftq
ewjgcronizkcsfjy
wztjkoipxsikoimv
jrgalyvfelwxforw
imylyalawbqwkrwb
yflwqfnuuvgjsgcj
wkysyzusldlojoue
zopllxnidcffcuau
bscgwxuprxaerskj
zvnvprxxjkhnkkpq
nejwxbhjxxdbenid
chryiccsebdbcnkc
guoeefaeafhlgvxh
nzapxrfrrqhsingx
mkzvquzvqvwsejqs
kozmlmbchydtxeeo
keylygnoqhmfzrfp
srwzoxccndoxylxe
uqjzalppoorosxxo
potmkinyuqxsfdfw
qkkwrhpbhypxhiun
wgfvnogarjmdbxyh
gkidtvepcvxopzuf
atwhvmmdvmewhzty
pybxizvuiwwngqej
zfumwnazxwwxtiry
keboraqttctosemx
vtlzxaqdetbhclib
wjiecykptzexuayl
ejatfnyjjdawepyk
mpcrobansyssvmju
gqukndzganeueabm
ukzscvomorucdnqd
wfydhtbzehgwfazx
mtwqdzlephqvxqmx
dltmlfxbjopefibh
atcfrowdflluqtbi
vowawlophlxaqonw
vblgdjzvwnocdipw
uzerzksmkvnlvlhm
ytjwhpaylohorvxd
siprvfxvnxcdgofz
cbhjupewcyjhvtgs
apqtozaofusmfqli
tmssrtlxfouowqnr
ntutrvwnzzgmokes
zrsgpwdzokztdpis
nrobvmsxtfmrqdhv
kadkaftffaziqdze
yrovbgcyqtlsnoux
modheiwuhntdecqs
gzhjypwddizemnys
gaputpwpcsvzxjho
bgmouxwoajgaozau
oxuapfrjcpyakiwt
kntwbvhuaahdixzj
epqjdjbnkxdnaccx
dspltdvznhypykri
tdrgqmbnagrxdwtt
njfqawzjggmemtbg
chpemsgwpzjpdnkk
fpsrobmbqbmigmwk
flxptsrqaazmprnl
nzdunrxlcbfklshm
miuwljvtkgzdlbnn
xbhjakklmbhsdmdt
xwxhsbnrwnegwcov
pwosflhodjaiexwq
fhgepuluczttfvqh
tldxcacbvxyamvkt
gffxatrjglkcehim
tzotkdrpxkucsdps
wxheftdepysvmzbe
qfooyczdzoewrmku
rvlwikuqdbpjuvoo
bcbrnbtfrdgijtzt
vaxqmvuogsxonlgq
ibsolflngegravgo
txntccjmqakcoorp
vrrbmqaxfbarmlmc
dzspqmttgsuhczto
pikcscjunxlwqtiw
lwzyogwxqitqfqlv
gsgjsuaqejtzglym
feyeqguxbgmcmgpp
gmttebyebdwvprkn
mzuuwbhzdjfdryxu
fganrbnplymqbzjx
cvsrbdcvhtxxdmro
scmgkjlkqukoamyp
fkgrqbyqpqcworqc
hjsrvkdibdjarxxb
sztzziuqroeidcus
pxdfvcpvwaddrzwv
phdqqxleqdjfgfbg
cqfikbgxvjmnfncy
#+END_SRC

** puzzle 1
#+BEGIN_SRC cpp :results output
  #include <stdio.h>
  #include <string.h>
  int main() {
    FILE *f = fopen("d5.txt", "r");
    char s[64];

    int nices = 0;
    while (fgets(s, sizeof(s), f) != 0) {
      int vowels = 0;
      int dups = 0;
      int bads = 0;
      for (int i = 0; s[i] != '\n'; i++) {
        switch (s[i]) {
        case 'a': case 'e': case 'i': case 'o': case 'u':
        vowels++;
        }
        if (i > 0) {
          if (s[i - 1] == 'a' && s[i] == 'b'
              || s[i - 1] == 'c' && s[i] == 'd'
              || s[i - 1] == 'p' && s[i] == 'q'
              || s[i - 1] == 'x' && s[i] == 'y') {
              bads++;
          }
          if (s[i - 1] == s[i]) {
            dups++;
          }
        }
      }
      // s[strlen(s) - 1] = 0;
      // printf("'%s' v%d d%d b%d\n", s, vowels, dups, bads);
      if (vowels >= 3 && dups >= 1 && bads == 0) {
        nices++;
      }
    }
    fclose(f);
    printf("%d", nices);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 238

 - 260 too high
** puzzle 2
#+BEGIN_SRC cpp :results output
  #include <stdio.h>
  #include <string.h>
  int main() {
    FILE *f = fopen("d5.txt", "r");
    char s[64];

    int nices = 0;
    while (fgets(s, sizeof(s), f) != 0) {
      int slen = strlen(s);
      int nicepair = 0;
      for (int i = 1; i < slen; i++) {
        for (int j = i + 2; j < slen; j++) {
          if (s[i-1] == s[j-1] && s[i] == s[j]) {
            nicepair = 1;
            break;
          }
        }
        if (nicepair) {
          break;
        }
      }

      int mirror = 0;
      for (int i = 2; i < slen; i++) {
        if (s[i-2] == s[i]) {
          mirror = 1;
          break;
        }
      }

      if (nicepair && mirror) {
        nices++;
      }
    }
    fclose(f);
    printf("%d", nices);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 69

* day 6
** text
--- Day 6: Probably a Fire Hazard ---

Because your neighbors keep defeating you in the holiday house decorating contest year after year, you've decided to deploy one million lights in a 1000x1000 grid.

Furthermore, because you've been especially nice this year, Santa has mailed you instructions on how to display the ideal lighting configuration.

Lights in your grid are numbered from 0 to 999 in each direction; the lights at each corner are at 0,0, 0,999, 999,999, and 999,0. The instructions include whether to turn on, turn off, or toggle various inclusive ranges given as coordinate pairs. Each coordinate pair represents opposite corners of a rectangle, inclusive; a coordinate pair like 0,0 through 2,2 therefore refers to 9 lights in a 3x3 square. The lights all start turned off.

To defeat your neighbors this year, all you have to do is set up your lights by doing the instructions Santa sent you in order.

For example:

    turn on 0,0 through 999,999 would turn on (or leave on) every light.
    toggle 0,0 through 999,0 would toggle the first line of 1000 lights, turning off the ones that were on, and turning on the ones that were off.
    turn off 499,499 through 500,500 would turn off (or leave off) the middle four lights.

After following the instructions, how many lights are lit?

Your puzzle answer was 543903.
--- Part Two ---

You just finish implementing your winning light pattern when you realize you mistranslated Santa's message from Ancient Nordic Elvish.

The light grid you bought actually has individual brightness controls; each light can have a brightness of zero or more. The lights all start at zero.

The phrase turn on actually means that you should increase the brightness of those lights by 1.

The phrase turn off actually means that you should decrease the brightness of those lights by 1, to a minimum of zero.

The phrase toggle actually means that you should increase the brightness of those lights by 2.

What is the total brightness of all lights combined after following Santa's instructions?

For example:

    turn on 0,0 through 0,0 would increase the total brightness by 1.
    toggle 0,0 through 999,999 would increase the total brightness by 2000000.

Your puzzle answer was 14687245.
** data
#+BEGIN_SRC text :tangle d6.txt :padline no
toggle 461,550 through 564,900
turn off 370,39 through 425,839
turn off 464,858 through 833,915
turn off 812,389 through 865,874
turn on 599,989 through 806,993
turn on 376,415 through 768,548
turn on 606,361 through 892,600
turn off 448,208 through 645,684
toggle 50,472 through 452,788
toggle 205,417 through 703,826
toggle 533,331 through 906,873
toggle 857,493 through 989,970
turn off 631,950 through 894,975
turn off 387,19 through 720,700
turn off 511,843 through 581,945
toggle 514,557 through 662,883
turn off 269,809 through 876,847
turn off 149,517 through 716,777
turn off 994,939 through 998,988
toggle 467,662 through 555,957
turn on 952,417 through 954,845
turn on 565,226 through 944,880
turn on 214,319 through 805,722
toggle 532,276 through 636,847
toggle 619,80 through 689,507
turn on 390,706 through 884,722
toggle 17,634 through 537,766
toggle 706,440 through 834,441
toggle 318,207 through 499,530
toggle 698,185 through 830,343
toggle 566,679 through 744,716
toggle 347,482 through 959,482
toggle 39,799 through 981,872
turn on 583,543 through 846,710
turn off 367,664 through 595,872
turn on 805,439 through 964,995
toggle 209,584 through 513,802
turn off 106,497 through 266,770
turn on 975,2 through 984,623
turn off 316,684 through 369,876
turn off 30,309 through 259,554
turn off 399,680 through 861,942
toggle 227,740 through 850,829
turn on 386,603 through 552,879
turn off 703,795 through 791,963
turn off 573,803 through 996,878
turn off 993,939 through 997,951
turn on 809,221 through 869,723
turn off 38,720 through 682,751
turn off 318,732 through 720,976
toggle 88,459 through 392,654
turn off 865,654 through 911,956
toggle 264,284 through 857,956
turn off 281,776 through 610,797
toggle 492,660 through 647,910
turn off 879,703 through 925,981
turn off 772,414 through 974,518
turn on 694,41 through 755,96
turn on 452,406 through 885,881
turn off 107,905 through 497,910
turn off 647,222 through 910,532
turn on 679,40 through 845,358
turn off 144,205 through 556,362
turn on 871,804 through 962,878
turn on 545,676 through 545,929
turn off 316,716 through 413,941
toggle 488,826 through 755,971
toggle 957,832 through 976,992
toggle 857,770 through 905,964
toggle 319,198 through 787,673
turn on 832,813 through 863,844
turn on 818,296 through 818,681
turn on 71,699 through 91,960
turn off 838,578 through 967,928
toggle 440,856 through 507,942
toggle 121,970 through 151,974
toggle 391,192 through 659,751
turn on 78,210 through 681,419
turn on 324,591 through 593,939
toggle 159,366 through 249,760
turn off 617,167 through 954,601
toggle 484,607 through 733,657
turn on 587,96 through 888,819
turn off 680,984 through 941,991
turn on 800,512 through 968,691
turn off 123,588 through 853,603
turn on 1,862 through 507,912
turn on 699,839 through 973,878
turn off 848,89 through 887,893
toggle 344,353 through 462,403
turn on 780,731 through 841,760
toggle 693,973 through 847,984
toggle 989,936 through 996,958
toggle 168,475 through 206,963
turn on 742,683 through 769,845
toggle 768,116 through 987,396
turn on 190,364 through 617,526
turn off 470,266 through 530,839
toggle 122,497 through 969,645
turn off 492,432 through 827,790
turn on 505,636 through 957,820
turn on 295,476 through 698,958
toggle 63,298 through 202,396
turn on 157,315 through 412,939
turn off 69,789 through 134,837
turn off 678,335 through 896,541
toggle 140,516 through 842,668
turn off 697,585 through 712,668
toggle 507,832 through 578,949
turn on 678,279 through 886,621
toggle 449,744 through 826,910
turn off 835,354 through 921,741
toggle 924,878 through 985,952
turn on 666,503 through 922,905
turn on 947,453 through 961,587
toggle 525,190 through 795,654
turn off 62,320 through 896,362
turn on 21,458 through 972,536
turn on 446,429 through 821,970
toggle 376,423 through 805,455
toggle 494,896 through 715,937
turn on 583,270 through 667,482
turn off 183,468 through 280,548
toggle 623,289 through 750,524
turn on 836,706 through 967,768
turn on 419,569 through 912,908
turn on 428,260 through 660,433
turn off 683,627 through 916,816
turn on 447,973 through 866,980
turn on 688,607 through 938,990
turn on 245,187 through 597,405
turn off 558,843 through 841,942
turn off 325,666 through 713,834
toggle 672,606 through 814,935
turn off 161,812 through 490,954
turn on 950,362 through 985,898
turn on 143,22 through 205,821
turn on 89,762 through 607,790
toggle 234,245 through 827,303
turn on 65,599 through 764,997
turn on 232,466 through 965,695
turn on 739,122 through 975,590
turn off 206,112 through 940,558
toggle 690,365 through 988,552
turn on 907,438 through 977,691
turn off 838,809 through 944,869
turn on 222,12 through 541,832
toggle 337,66 through 669,812
turn on 732,821 through 897,912
toggle 182,862 through 638,996
turn on 955,808 through 983,847
toggle 346,227 through 841,696
turn on 983,270 through 989,756
turn off 874,849 through 876,905
turn off 7,760 through 678,795
toggle 973,977 through 995,983
turn off 911,961 through 914,976
turn on 913,557 through 952,722
turn off 607,933 through 939,999
turn on 226,604 through 517,622
turn off 3,564 through 344,842
toggle 340,578 through 428,610
turn on 248,916 through 687,925
toggle 650,185 through 955,965
toggle 831,359 through 933,536
turn off 544,614 through 896,953
toggle 648,939 through 975,997
turn on 464,269 through 710,521
turn off 643,149 through 791,320
turn off 875,549 through 972,643
turn off 953,969 through 971,972
turn off 236,474 through 772,591
toggle 313,212 through 489,723
toggle 896,829 through 897,837
toggle 544,449 through 995,905
turn off 278,645 through 977,876
turn off 887,947 through 946,977
turn on 342,861 through 725,935
turn on 636,316 through 692,513
toggle 857,470 through 950,528
turn off 736,196 through 826,889
turn on 17,878 through 850,987
turn on 142,968 through 169,987
turn on 46,470 through 912,853
turn on 182,252 through 279,941
toggle 261,143 through 969,657
turn off 69,600 through 518,710
turn on 372,379 through 779,386
toggle 867,391 through 911,601
turn off 174,287 through 900,536
toggle 951,842 through 993,963
turn off 626,733 through 985,827
toggle 622,70 through 666,291
turn off 980,671 through 985,835
turn off 477,63 through 910,72
turn off 779,39 through 940,142
turn on 986,570 through 997,638
toggle 842,805 through 943,985
turn off 890,886 through 976,927
turn off 893,172 through 897,619
turn off 198,780 through 835,826
toggle 202,209 through 219,291
turn off 193,52 through 833,283
toggle 414,427 through 987,972
turn on 375,231 through 668,236
turn off 646,598 through 869,663
toggle 271,462 through 414,650
turn off 679,121 through 845,467
toggle 76,847 through 504,904
turn off 15,617 through 509,810
toggle 248,105 through 312,451
turn off 126,546 through 922,879
turn on 531,831 through 903,872
toggle 602,431 through 892,792
turn off 795,223 through 892,623
toggle 167,721 through 533,929
toggle 813,251 through 998,484
toggle 64,640 through 752,942
turn on 155,955 through 892,985
turn on 251,329 through 996,497
turn off 341,716 through 462,994
toggle 760,127 through 829,189
turn on 86,413 through 408,518
toggle 340,102 through 918,558
turn off 441,642 through 751,889
turn on 785,292 through 845,325
turn off 123,389 through 725,828
turn on 905,73 through 983,270
turn off 807,86 through 879,276
toggle 500,866 through 864,916
turn on 809,366 through 828,534
toggle 219,356 through 720,617
turn off 320,964 through 769,990
turn off 903,167 through 936,631
toggle 300,137 through 333,693
toggle 5,675 through 755,848
turn off 852,235 through 946,783
toggle 355,556 through 941,664
turn on 810,830 through 867,891
turn off 509,869 through 667,903
toggle 769,400 through 873,892
turn on 553,614 through 810,729
turn on 179,873 through 589,962
turn off 466,866 through 768,926
toggle 143,943 through 465,984
toggle 182,380 through 569,552
turn off 735,808 through 917,910
turn on 731,802 through 910,847
turn off 522,74 through 731,485
turn on 444,127 through 566,996
turn off 232,962 through 893,979
turn off 231,492 through 790,976
turn on 874,567 through 943,684
toggle 911,840 through 990,932
toggle 547,895 through 667,935
turn off 93,294 through 648,636
turn off 190,902 through 532,970
turn off 451,530 through 704,613
toggle 936,774 through 937,775
turn off 116,843 through 533,934
turn on 950,906 through 986,993
turn on 910,51 through 945,989
turn on 986,498 through 994,945
turn off 125,324 through 433,704
turn off 60,313 through 75,728
turn on 899,494 through 940,947
toggle 832,316 through 971,817
toggle 994,983 through 998,984
toggle 23,353 through 917,845
toggle 174,799 through 658,859
turn off 490,878 through 534,887
turn off 623,963 through 917,975
toggle 721,333 through 816,975
toggle 589,687 through 890,921
turn on 936,388 through 948,560
turn off 485,17 through 655,610
turn on 435,158 through 689,495
turn on 192,934 through 734,936
turn off 299,723 through 622,847
toggle 484,160 through 812,942
turn off 245,754 through 818,851
turn on 298,419 through 824,634
toggle 868,687 through 969,760
toggle 131,250 through 685,426
turn off 201,954 through 997,983
turn on 353,910 through 832,961
turn off 518,781 through 645,875
turn off 866,97 through 924,784
toggle 836,599 through 857,767
turn on 80,957 through 776,968
toggle 277,130 through 513,244
turn off 62,266 through 854,434
turn on 792,764 through 872,842
turn off 160,949 through 273,989
turn off 664,203 through 694,754
toggle 491,615 through 998,836
turn off 210,146 through 221,482
turn off 209,780 through 572,894
turn on 766,112 through 792,868
turn on 222,12 through 856,241
#+END_SRC
** puzzle 1
#+BEGIN_SRC cpp :results output
  #include <stdio.h>
  #include <string.h>
  #define TOGGLE 0
  #define ON 1
  #define OFF 2
  int main() {
    FILE *f = fopen("d6.txt", "r");
    if (0 == f) {
      perror("error opening file d6.txt");
      return 1;
    }
    char line[1024];
    char lights[1000][1000] = { 0 };

    while (fgets(line, sizeof(line), f) != 0) {
      int x1, y1, x2, y2;
      int instruction = -1;
      if (sscanf(line, "toggle %d,%d through %d,%d", &x1, &y1, &x2, &y2) == 4) {
        instruction = TOGGLE;
      } else if (sscanf(line, "turn on %d,%d through %d,%d", &x1, &y1, &x2, &y2) == 4) {
        instruction = ON;
      } else if (sscanf(line, "turn off %d,%d through %d,%d", &x1, &y1, &x2, &y2) == 4) {
        instruction = OFF;
      } else {
        printf("invalid line: %s\n", line);
        return 1;
      }
      
      for (int x = x1; x <= x2; x++) {
        for (int y = y1; y <= y2; y++) {
          switch (instruction) {
          case TOGGLE: lights[x][y] = !lights[x][y]; break;
          case ON: lights[x][y] = 1; break;
          case OFF: lights[x][y] = 0; break;
          default: printf("invalid instructin\n"); return 1;
          }
        }
      }
    }
    fclose(f);
   
    int lights_on = 0;
    for (int x = 0; x <= 999; x++) {
      for (int y = 0; y <= 999; y++) {
        if (lights[x][y]) {
          lights_on++;
        }
      }
    }

    printf("%d", lights_on);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 543903

 - 544193 too high
** puzzle 2
#+BEGIN_SRC cpp :results output
  #include <stdio.h>
  #include <string.h>
  #define TOGGLE 0
  #define ON 1
  #define OFF 2
  int main() {
    FILE *f = fopen("d6.txt", "r");
    if (0 == f) {
      perror("error opening file d6.txt");
      return 1;
    }
    char line[1024];
    char lights[1000][1000] = { 0 };

    while (fgets(line, sizeof(line), f) != 0) {
      int x1, y1, x2, y2;
      int instruction = -1;
      if (sscanf(line, "toggle %d,%d through %d,%d", &x1, &y1, &x2, &y2) == 4) {
        instruction = TOGGLE;
      } else if (sscanf(line, "turn on %d,%d through %d,%d", &x1, &y1, &x2, &y2) == 4) {
        instruction = ON;
      } else if (sscanf(line, "turn off %d,%d through %d,%d", &x1, &y1, &x2, &y2) == 4) {
        instruction = OFF;
      } else {
        printf("invalid line: %s\n", line);
        return 1;
      }
      
      for (int x = x1; x <= x2; x++) {
        for (int y = y1; y <= y2; y++) {
          switch (instruction) {
          case TOGGLE: lights[x][y] += 2; break;
          case ON: lights[x][y] += 1; break;
          case OFF: if (lights[x][y] > 0) { lights[x][y] -= 1; } break;
          default: printf("invalid instructin\n"); return 1;
          }
        }
      }
    }
    fclose(f);
   
    long lights_brightness = 0;
    for (int x = 0; x <= 999; x++) {
      for (int y = 0; y <= 999; y++) {
        lights_brightness += lights[x][y];
      }
    }

    printf("%d", lights_brightness);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 14687245

 - 14190930 too low

* day 7
** text
--- Day 7: Some Assembly Required ---

This year, Santa brought little Bobby Tables a set of wires and bitwise logic gates! Unfortunately, little Bobby is a little under the recommended age range, and he needs help assembling the circuit.

Each wire has an identifier (some lowercase letters) and can carry a 16-bit signal (a number from 0 to 65535). A signal is provided to each wire by a gate, another wire, or some specific value. Each wire can only get a signal from one source, but can provide its signal to multiple destinations. A gate provides no signal until all of its inputs have a signal.

The included instructions booklet describes how to connect the parts together: x AND y -> z means to connect wires x and y to an AND gate, and then connect its output to wire z.

For example:

    123 -> x means that the signal 123 is provided to wire x.
    x AND y -> z means that the bitwise AND of wire x and wire y is provided to wire z.
    p LSHIFT 2 -> q means that the value from wire p is left-shifted by 2 and then provided to wire q.
    NOT e -> f means that the bitwise complement of the value from wire e is provided to wire f.

Other possible gates include OR (bitwise OR) and RSHIFT (right-shift). If, for some reason, you'd like to emulate the circuit instead, almost all programming languages (for example, C, JavaScript, or Python) provide operators for these gates.

For example, here is a simple circuit:

123 -> x
456 -> y
x AND y -> d
x OR y -> e
x LSHIFT 2 -> f
y RSHIFT 2 -> g
NOT x -> h
NOT y -> i

After it is run, these are the signals on the wires:

d: 72
e: 507
f: 492
g: 114
h: 65412
i: 65079
x: 123
y: 456

In little Bobby's kit's instructions booklet (provided as your puzzle input), what signal is ultimately provided to wire a?

Your puzzle answer was 3176.
--- Part Two ---

Now, take the signal you got on wire a, override wire b to that signal, and reset the other wires (including wire a). What new signal is ultimately provided to wire a?

Your puzzle answer was 14710.
** data
#+BEGIN_SRC text :tangle d7.txt :padline no
NOT dq -> dr
kg OR kf -> kh
ep OR eo -> eq
44430 -> b
NOT gs -> gt
dd OR do -> dp
eg AND ei -> ej
y AND ae -> ag
jx AND jz -> ka
lf RSHIFT 2 -> lg
z AND aa -> ac
dy AND ej -> el
bj OR bi -> bk
kk RSHIFT 3 -> km
NOT cn -> co
gn AND gp -> gq
cq AND cs -> ct
eo LSHIFT 15 -> es
lg OR lm -> ln
dy OR ej -> ek
NOT di -> dj
1 AND fi -> fj
kf LSHIFT 15 -> kj
NOT jy -> jz
NOT ft -> fu
fs AND fu -> fv
NOT hr -> hs
ck OR cl -> cm
jp RSHIFT 5 -> js
iv OR jb -> jc
is OR it -> iu
ld OR le -> lf
NOT fc -> fd
NOT dm -> dn
bn OR by -> bz
aj AND al -> am
cd LSHIFT 15 -> ch
jp AND ka -> kc
ci OR ct -> cu
gv AND gx -> gy
de AND dk -> dm
x RSHIFT 5 -> aa
et RSHIFT 2 -> eu
x RSHIFT 1 -> aq
ia OR ig -> ih
bk LSHIFT 1 -> ce
y OR ae -> af
NOT ca -> cb
e AND f -> h
ia AND ig -> ii
ck AND cl -> cn
NOT jh -> ji
z OR aa -> ab
1 AND en -> eo
ib AND ic -> ie
NOT eh -> ei
iy AND ja -> jb
NOT bb -> bc
ha OR gz -> hb
1 AND cx -> cy
NOT ax -> ay
ev OR ew -> ex
bn RSHIFT 2 -> bo
er OR es -> et
eu OR fa -> fb
jp OR ka -> kb
ea AND eb -> ed
k AND m -> n
et RSHIFT 3 -> ev
et RSHIFT 5 -> ew
hz RSHIFT 1 -> is
ki OR kj -> kk
NOT h -> i
lv LSHIFT 15 -> lz
as RSHIFT 1 -> bl
hu LSHIFT 15 -> hy
iw AND ix -> iz
lf RSHIFT 1 -> ly
fp OR fv -> fw
1 AND am -> an
ap LSHIFT 1 -> bj
u LSHIFT 1 -> ao
b RSHIFT 5 -> f
jq AND jw -> jy
iu RSHIFT 3 -> iw
ih AND ij -> ik
NOT iz -> ja
de OR dk -> dl
iu OR jf -> jg
as AND bd -> bf
b RSHIFT 3 -> e
jq OR jw -> jx
iv AND jb -> jd
cg OR ch -> ci
iu AND jf -> jh
lx -> a
1 AND cc -> cd
ly OR lz -> ma
NOT el -> em
1 AND bh -> bi
fb AND fd -> fe
lf OR lq -> lr
bn RSHIFT 3 -> bp
bn AND by -> ca
af AND ah -> ai
cf LSHIFT 1 -> cz
dw OR dx -> dy
gj AND gu -> gw
jg AND ji -> jj
jr OR js -> jt
bl OR bm -> bn
gj RSHIFT 2 -> gk
cj OR cp -> cq
gj OR gu -> gv
b OR n -> o
o AND q -> r
bi LSHIFT 15 -> bm
dy RSHIFT 1 -> er
cu AND cw -> cx
iw OR ix -> iy
hc OR hd -> he
0 -> c
db OR dc -> dd
kk RSHIFT 2 -> kl
eq LSHIFT 1 -> fk
dz OR ef -> eg
NOT ed -> ee
lw OR lv -> lx
fw AND fy -> fz
dz AND ef -> eh
jp RSHIFT 3 -> jr
lg AND lm -> lo
ci RSHIFT 2 -> cj
be AND bg -> bh
lc LSHIFT 1 -> lw
hm AND ho -> hp
jr AND js -> ju
1 AND io -> ip
cm AND co -> cp
ib OR ic -> id
NOT bf -> bg
fo RSHIFT 5 -> fr
ip LSHIFT 15 -> it
jt AND jv -> jw
jc AND je -> jf
du OR dt -> dv
NOT fx -> fy
aw AND ay -> az
ge LSHIFT 15 -> gi
NOT ak -> al
fm OR fn -> fo
ff AND fh -> fi
ci RSHIFT 5 -> cl
cz OR cy -> da
NOT ey -> ez
NOT ju -> jv
NOT ls -> lt
kk AND kv -> kx
NOT ii -> ij
kl AND kr -> kt
jk LSHIFT 15 -> jo
e OR f -> g
NOT bs -> bt
hi AND hk -> hl
hz OR ik -> il
ek AND em -> en
ao OR an -> ap
dv LSHIFT 1 -> ep
an LSHIFT 15 -> ar
fo RSHIFT 1 -> gh
NOT im -> in
kk RSHIFT 1 -> ld
hw LSHIFT 1 -> iq
ec AND ee -> ef
hb LSHIFT 1 -> hv
kb AND kd -> ke
x AND ai -> ak
dd AND do -> dq
aq OR ar -> as
iq OR ip -> ir
dl AND dn -> do
iu RSHIFT 5 -> ix
as OR bd -> be
NOT go -> gp
fk OR fj -> fl
jm LSHIFT 1 -> kg
NOT cv -> cw
dp AND dr -> ds
dt LSHIFT 15 -> dx
et RSHIFT 1 -> fm
dy RSHIFT 3 -> ea
fp AND fv -> fx
NOT p -> q
dd RSHIFT 2 -> de
eu AND fa -> fc
ba AND bc -> bd
dh AND dj -> dk
lr AND lt -> lu
he RSHIFT 1 -> hx
ex AND ez -> fa
df OR dg -> dh
fj LSHIFT 15 -> fn
NOT kx -> ky
gk OR gq -> gr
dy RSHIFT 2 -> dz
gh OR gi -> gj
lj AND ll -> lm
x OR ai -> aj
bz AND cb -> cc
1 AND lu -> lv
as RSHIFT 3 -> au
ce OR cd -> cf
il AND in -> io
dd RSHIFT 1 -> dw
NOT lo -> lp
c LSHIFT 1 -> t
dd RSHIFT 3 -> df
dd RSHIFT 5 -> dg
lh AND li -> lk
lf RSHIFT 5 -> li
dy RSHIFT 5 -> eb
NOT kt -> ku
at OR az -> ba
x RSHIFT 3 -> z
NOT lk -> ll
lb OR la -> lc
1 AND r -> s
lh OR li -> lj
ln AND lp -> lq
kk RSHIFT 5 -> kn
ea OR eb -> ec
ci AND ct -> cv
b RSHIFT 2 -> d
jp RSHIFT 1 -> ki
NOT cr -> cs
NOT jd -> je
jp RSHIFT 2 -> jq
jn OR jo -> jp
lf RSHIFT 3 -> lh
1 AND ds -> dt
lf AND lq -> ls
la LSHIFT 15 -> le
NOT fg -> fh
at AND az -> bb
au AND av -> ax
kw AND ky -> kz
v OR w -> x
kk OR kv -> kw
ks AND ku -> kv
kh LSHIFT 1 -> lb
1 AND kz -> la
NOT kc -> kd
x RSHIFT 2 -> y
et OR fe -> ff
et AND fe -> fg
NOT ac -> ad
jl OR jk -> jm
1 AND jj -> jk
bn RSHIFT 1 -> cg
NOT kp -> kq
ci RSHIFT 3 -> ck
ev AND ew -> ey
1 AND ke -> kf
cj AND cp -> cr
ir LSHIFT 1 -> jl
NOT gw -> gx
as RSHIFT 2 -> at
iu RSHIFT 1 -> jn
cy LSHIFT 15 -> dc
hg OR hh -> hi
ci RSHIFT 1 -> db
au OR av -> aw
km AND kn -> kp
gj RSHIFT 1 -> hc
iu RSHIFT 2 -> iv
ab AND ad -> ae
da LSHIFT 1 -> du
NOT bw -> bx
km OR kn -> ko
ko AND kq -> kr
bv AND bx -> by
kl OR kr -> ks
1 AND ht -> hu
df AND dg -> di
NOT ag -> ah
d OR j -> k
d AND j -> l
b AND n -> p
gf OR ge -> gg
gg LSHIFT 1 -> ha
bn RSHIFT 5 -> bq
bo OR bu -> bv
1 AND gy -> gz
s LSHIFT 15 -> w
NOT ie -> if
as RSHIFT 5 -> av
bo AND bu -> bw
hz AND ik -> im
bp AND bq -> bs
b RSHIFT 1 -> v
NOT l -> m
bp OR bq -> br
g AND i -> j
br AND bt -> bu
t OR s -> u
hz RSHIFT 5 -> ic
gk AND gq -> gs
fl LSHIFT 1 -> gf
he RSHIFT 3 -> hg
gz LSHIFT 15 -> hd
hf OR hl -> hm
1 AND gd -> ge
fo OR fz -> ga
id AND if -> ig
fo AND fz -> gb
gr AND gt -> gu
he OR hp -> hq
fq AND fr -> ft
ga AND gc -> gd
fo RSHIFT 2 -> fp
gl OR gm -> gn
hg AND hh -> hj
NOT hn -> ho
gl AND gm -> go
he RSHIFT 5 -> hh
NOT gb -> gc
hq AND hs -> ht
hz RSHIFT 3 -> ib
hz RSHIFT 2 -> ia
fq OR fr -> fs
hx OR hy -> hz
he AND hp -> hr
gj RSHIFT 5 -> gm
hf AND hl -> hn
hv OR hu -> hw
NOT hj -> hk
gj RSHIFT 3 -> gl
fo RSHIFT 3 -> fq
he RSHIFT 2 -> hf
#+END_SRC
** puzzle 1
#+BEGIN_SRC cpp :results output :tangle d7p1.c
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <errno.h>
  #include <ctype.h>

  #define VALS 1089 // ('z' - 'a' + 1) ^ 2
  #define HASH_SIZE 124

  struct ins {
    char *wire;
    char *line;
    unsigned int signal;
    char isset;
    struct ins *next;
  };

  int hash(const char *str) {
    int hash = 1;
    for (int i = 0; str[i] != '\0'; i++)
      hash = hash * 13 + str[i];
    return hash % HASH_SIZE;
  }

  struct ins* get(struct ins** is, const char *wire) {
    for (struct ins *i = is[hash(wire)]; i != NULL; i = i->next) {
      if (strcmp(wire, i->wire) == 0)
        return i;
    }
    return NULL;
  }

  char *get_wire(const char *line) {
    for (int i = 1; line[i] != '\0'; i++)
      if (line[i-1] == '-' && line[i] == '>') {
        char *dup = strdup(line + i + 2);
        for (int j = 0; dup[j] != '\0'; j++) {
          if (!isalpha(dup[j]))
            dup[j] = '\0';
        }
        return dup;
      }
    printf("error getting wire from: %s", line);
    exit(0);
  }

  void put(struct ins** is, char *line) {
    char *wire = get_wire(line);

    struct ins *old = is[hash(wire)];

    struct ins *newins = (struct ins *) malloc(sizeof(struct ins));
    newins->signal = 0;
    newins->isset = 0;
    newins->line = strdup(line);
    newins->wire = wire;
    newins->next = old;
    is[hash(wire)] = newins;
  }

  int indent = 0;

  unsigned int signal(struct ins** is, const char *wire) {
    char line[64];

    if (isdigit(wire[0]))
      return atoi(wire);

    struct ins *i = get(is, wire);
    if (NULL == i) {
      printf("No wire found for: %s\n", wire);
      exit(0);
    }
    if (i->isset) {
      // for (int j = 0; j < indent + 1; j++)
      //   printf(" ");
      // printf("< %2s %d old\n", wire, i->signal);
      return i->signal;
    }
    // for (int j = 0; j < indent; j++)
    //   printf(" ");
    // printf("%2s  %s", wire, i->line);

    indent++;

    unsigned int out;

    int val;
    char in1[3], in2[3], wire2[3];
    if (sscanf(i->line, "%s -> %s", in1, wire2) == 2) {
      out = signal(is, in1);
    } else if (sscanf(i->line, "%s AND %s -> %s", in1, in2, wire2) == 3) {
      out = signal(is, in1) & signal(is, in2);
    } else if (sscanf(i->line, "%s OR %s -> %s", in1, in2, wire2) == 3) {
      out = signal(is, in1) | signal(is, in2);
    } else if (sscanf(i->line, "%s LSHIFT %d -> %s", in1, &val, wire2) == 3) {
      out = 0xFFFF & (signal(is, in1) << val);
    } else if (sscanf(i->line, "%s RSHIFT %d -> %s", in1, &val, wire2) == 3) {
      out = signal(is, in1) >> val;
    } else if (sscanf(i->line, "NOT %s -> %s", in1, wire2) == 2) {
      out = 0xFFFF & ~signal(is, in1);
    } else {
      printf("unrecognized insturction: %s\n", i->line);
      exit(0);
    }


    i->isset = 1;
    i->signal = out;
    // for (int j = 0; j < indent; j++)
    //   printf(" ");
    // printf("< %2s %d old\n", wire, i->signal);
    indent--;
    return out;
  }

  int main() {
    FILE *f = fopen("d7.txt", "r");
    if (0 == f) {
      perror("error opening file d6.txt");
      return 1;
    }
    char line[1024];
    struct ins* is[HASH_SIZE] = { 0 };

    while (fgets(line, sizeof(line), f) != 0) {
      put(is, line);
    }

    // rewind(f);
    // while (fgets(line, sizeof(line), f) != 0) {
    //   char *w = get_wire(line);
    //   struct ins *i = get(is, w);
    //   printf("'%s' = %d\n", i->wire, signal(is, w));
    // }

    printf("%d", signal(is, "a"));
    return 0;
  }
#+END_SRC

#+RESULTS:
: 3176

 - 105 too low
 - 1312 too low

#+BEGIN_SRC cpp :results output :includes <stdio.h>
printf("%d", 5553 & 1388);

#+END_SRC

#+RESULTS:
: 1312

** puzzle 2
#+BEGIN_SRC cpp :results output :tangle d7p2.c
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <errno.h>
  #include <ctype.h>

  #define VALS 1089 // ('z' - 'a' + 1) ^ 2
  #define HASH_SIZE 124

  struct ins {
    char *wire;
    char *line;
    unsigned int signal;
    char isset;
    struct ins *next;
  };

  int hash(const char *str) {
    int hash = 1;
    for (int i = 0; str[i] != '\0'; i++)
      hash = hash * 13 + str[i];
    return hash % HASH_SIZE;
  }

  struct ins* get(struct ins** is, const char *wire) {
    for (struct ins *i = is[hash(wire)]; i != NULL; i = i->next) {
      if (strcmp(wire, i->wire) == 0)
        return i;
    }
    return NULL;
  }

  char *get_wire(const char *line) {
    for (int i = 1; line[i] != '\0'; i++)
      if (line[i-1] == '-' && line[i] == '>') {
        char *dup = strdup(line + i + 2);
        for (int j = 0; dup[j] != '\0'; j++) {
          if (!isalpha(dup[j]))
            dup[j] = '\0';
        }
        return dup;
      }
    printf("error getting wire from: %s", line);
    exit(0);
  }

  void put(struct ins** is, char *line) {
    char *wire = get_wire(line);

    struct ins *old = is[hash(wire)];

    struct ins *newins = (struct ins *) malloc(sizeof(struct ins));
    newins->signal = 0;
    newins->isset = 0;
    newins->line = strdup(line);
    newins->wire = wire;
    newins->next = old;
    is[hash(wire)] = newins;
  }

  int indent = 0;

  unsigned int signal(struct ins** is, const char *wire) {
    char line[64];

    if (isdigit(wire[0]))
      return atoi(wire);

    struct ins *i = get(is, wire);
    if (NULL == i) {
      printf("No wire found for: %s\n", wire);
      exit(0);
    }
    if (i->isset) {
      // for (int j = 0; j < indent + 1; j++)
      //   printf(" ");
      // printf("< %2s %d old\n", wire, i->signal);
      return i->signal;
    }
    // for (int j = 0; j < indent; j++)
    //   printf(" ");
    // printf("%2s  %s", wire, i->line);

    indent++;

    unsigned int out;

    int val;
    char in1[3], in2[3], wire2[3];
    if (sscanf(i->line, "%s -> %s", in1, wire2) == 2) {
      out = signal(is, in1);
    } else if (sscanf(i->line, "%s AND %s -> %s", in1, in2, wire2) == 3) {
      out = signal(is, in1) & signal(is, in2);
    } else if (sscanf(i->line, "%s OR %s -> %s", in1, in2, wire2) == 3) {
      out = signal(is, in1) | signal(is, in2);
    } else if (sscanf(i->line, "%s LSHIFT %d -> %s", in1, &val, wire2) == 3) {
      out = 0xFFFF & (signal(is, in1) << val);
    } else if (sscanf(i->line, "%s RSHIFT %d -> %s", in1, &val, wire2) == 3) {
      out = signal(is, in1) >> val;
    } else if (sscanf(i->line, "NOT %s -> %s", in1, wire2) == 2) {
      out = 0xFFFF & ~signal(is, in1);
    } else {
      printf("unrecognized insturction: %s\n", i->line);
      exit(0);
    }


    i->isset = 1;
    i->signal = out;
    // for (int j = 0; j < indent; j++)
    //   printf(" ");
    // printf("< %2s %d old\n", wire, i->signal);
    indent--;
    return out;
  }

  int main() {
    FILE *f = fopen("d7.txt", "r");
    if (0 == f) {
      perror("error opening file d6.txt");
      return 1;
    }
    char line[1024];
    struct ins* is[HASH_SIZE] = { 0 };

    while (fgets(line, sizeof(line), f) != 0) {
      put(is, line);
    }

    struct ins *i = get(is, "b");
    i->isset = 1;
    i->signal = 3176;

    // rewind(f);
    // while (fgets(line, sizeof(line), f) != 0) {
    //   char *w = get_wire(line);
    //   struct ins *i = get(is, w);
    //   printf("'%s' = %d\n", i->wire, signal(is, w));
    // }

    printf("%d", signal(is, "a"));
    return 0;
  }
#+END_SRC

#+RESULTS:
: 14710


#+BEGIN_SRC cpp :results output :includes <stdio.h>
printf("%d", 5553 & 1388);

#+END_SRC

#+RESULTS:
: 1312

* day 8
** text
--- Day 8: Matchsticks ---

Space on the sleigh is limited this year, and so Santa will be bringing his list as a digital copy. He needs to know how much space it will take up when stored.

It is common in many programming languages to provide a way to escape special characters in strings. For example, C, JavaScript, Perl, Python, and even PHP handle special characters in very similar ways.

However, it is important to realize the difference between the number of characters in the code representation of the string literal and the number of characters in the in-memory string itself.

For example:

    "" is 2 characters of code (the two double quotes), but the string contains zero characters.
    "abc" is 5 characters of code, but 3 characters in the string data.
    "aaa\"aaa" is 10 characters of code, but the string itself contains six "a" characters and a single, escaped quote character, for a total of 7 characters in the string data.
    "\x27" is 6 characters of code, but the string itself contains just one - an apostrophe ('), escaped using hexadecimal notation.

Santa's list is a file that contains many double-quoted string literals, one on each line. The only escape sequences used are \\ (which represents a single backslash), \" (which represents a lone double-quote character), and \x plus two hexadecimal characters (which represents a single character with that ASCII code).

Disregarding the whitespace in the file, what is the number of characters of code for string literals minus the number of characters in memory for the values of the strings in total for the entire file?

For example, given the four strings above, the total number of characters of string code (2 + 5 + 10 + 6 = 23) minus the total number of characters in memory for string values (0 + 3 + 7 + 1 = 11) is 23 - 11 = 12.

Your puzzle answer was 1350.
--- Part Two ---

Now, let's go the other way. In addition to finding the number of characters of code, you should now encode each code representation as a new string and find the number of characters of the new encoded representation, including the surrounding double quotes.

For example:

    "" encodes to "\"\"", an increase from 2 characters to 6.
    "abc" encodes to "\"abc\"", an increase from 5 characters to 9.
    "aaa\"aaa" encodes to "\"aaa\\\"aaa\"", an increase from 10 characters to 16.
    "\x27" encodes to "\"\\x27\"", an increase from 6 characters to 11.

Your task is to find the total number of characters to represent the newly encoded strings minus the number of characters of code in each original string literal. For example, for the strings above, the total encoded length (6 + 9 + 16 + 11 = 42) minus the characters in the original code representation (23, just like in the first part of this puzzle) is 42 - 23 = 19.

Your puzzle answer was 2085.
** data
#+BEGIN_SRC text :tangle d8.txt :padline no
"qxfcsmh"
"ffsfyxbyuhqkpwatkjgudo"
"byc\x9dyxuafof\\\xa6uf\\axfozomj\\olh\x6a"
"jtqvz"
"uzezxa\"jgbmojtwyfbfguz"
"vqsremfk\x8fxiknektafj"
"wzntebpxnnt\"vqndz\"i\x47vvjqo\""
"higvez\"k\"riewqk"
"dlkrbhbrlfrp\\damiauyucwhty"
"d\""
"qlz"
"ku"
"yy\"\"uoao\"uripabop"
"saduyrntuswlnlkuppdro\\sicxosted"
"tj"
"zzphopswlwdhebwkxeurvizdv"
"xfoheirjoakrpofles\"nfu"
"q\xb7oh\"p\xce\"n"
"qeendp\"ercwgywdjeylxcv"
"dcmem"
"\"i\x13r\"l"
"ikso\xdcbvqnbrjduh\"uqudzki\xderwk"
"wfdsn"
"pwynglklryhtsqbno"
"hcoj\x63iccz\"v\"ttr"
"zf\x23\\hlj\\kkce\\d\\asy\"yyfestwcdxyfj"
"xs"
"m\"tvltapxdvtrxiy"
"bmud"
"k\"a"
"b\"oas"
"\"yexnjjupoqsxyqnquy\"uzfdvetqrc"
"vdw\xe3olxfgujaj"
"qomcxdnd\"\\cfoe\""
"fpul"
"m\"avamefphkpv"
"vvdnb\\x\\uhnxfw\"dpubfkxfmeuhnxisd"
"hey\\"
"ldaeigghlfey"
"eure\"hoy\xa5iezjp\\tm"
"yygb\"twbj\\r\"\x10gmxuhmp\""
"weirebp\x39mqonbtmfmd"
"ltuz\\hs\"e"
"ysvmpc"
"g\x8amjtt\"megl\"omsaihifwa"
"yimmm"
"iiyqfalh"
"cwknlaaf"
"q\x37feg\xc6s\"xx"
"uayrgeurgyp\\oi"
"xhug\"pt\"axugllbdiggzhvy"
"kdaarqmsjfx\xc3d"
"\"vkwla"
"d\""
"tmroz\"bvfinxoe\\mum\"wmm"
"\"n\"bbswxne\\p\\yr\"qhwpdd"
"skzlkietklkqovjhvj\xfe"
"pbg\\pab\"bubqaf\"obzcwxwywbs\\dhtq"
"xxjidvqh\"lx\\wu\"ij"
"daef\x5fe\x5b\\kbeeb\x13qnydtboof"
"ogvazaqy\"j\x73"
"y"
"n\"tibetedldy\\gsamm\"nwu"
"wldkvgdtqulwkad"
"dpmxnj"
"twybw\"cdvf\"mjdajurokbce"
"ru\"\\lasij\"i"
"roc\\vra\\lhrm"
"pbkt\x60booz\"fjlkc"
"j\x4dytvjwrzt"
"\\uiwjkniumxcs"
"cbhm\"nexccior\"v\"j\"nazxilmfp\x47"
"qdxngevzrlgoq"
"\"lrzxftytpobsdfyrtdqpjbpuwmm\x9e"
"mdag\x0asnck\xc2ggj\"slb\"fjy"
"wyqkhjuazdtcgkcxvjkpnjdae"
"aixfk\xc0iom\x21vueob"
"dkiiakyjpkffqlluhaetires"
"ysspv\"lysgkvnmwbbsy"
"gy\"ryexcjjxdm\"xswssgtr"
"s"
"ddxv"
"qwt\"\x27puilb\"pslmbrsxhrz"
"qdg\xc9e\\qwtknlvkol\x54oqvmchn\\"
"lvo"
"b"
"fk\"aa\"\"yenwch\\\\on"
"srig\x63hpwaavs\\\x80qzk\"xa\"\xe6u\\wr"
"yxjxuj\"ghyhhxfj\"\xa6qvatre"
"yoktqxjxkzrklkoeroil"
"\"jfmik\""
"smgseztzdwldikbqrh\""
"jftahgctf\"hoqy"
"tcnhicr\"znpgckt\"ble"
"vqktnkodh\"lo\"a\\bkmdjqqnsqr"
"ztnirfzqq"
"s"
"xx"
"iqj\"y\\hqgzflwrdsusasekyrxbp\\ad"
"\\xzjhlaiynkioz\"\"bxepzimvgwt"
"s\x36rbw"
"mniieztwrisvdx"
"atyfxioy\x2b\\"
"irde\x85\x5cvbah\\jekw\"ia"
"bdmftlhkwrprmpat\"prfaocvp"
"w\\k"
"umbpausy"
"zfauhpsangy"
"p\"zqyw"
"wtztypyqvnnxzvlvipnq\"zu"
"deicgwq\\oqvajpbov\\or\"kgplwu"
"mbzlfgpi\\\\zqcidjpzqdzxityxa"
"lfkxvhma"
"\xf2yduqzqr\"\\fak\"p\"n"
"mpajacfuxotonpadvng"
"anb\\telzvcdu\\a\xf2flfq"
"lrs\"ebethwpmuuc\"\x86ygr"
"qmvdbhtumzc\"ci"
"meet"
"yopg\x0fdxdq\"h\\ugsu\xffmolxjv"
"uhy"
"fzgidrtzycsireghazscvmwcfmw\\t"
"cqohkhpgvpru"
"bihyigtnvmevx\"xx"
"xz"
"zofomwotzuxsjk\"q\"mc\"js\"dnmalhxd"
"\\ktnddux\\fqvt\"ibnjntjcbn"
"ia"
"htjadnefwetyp\xd5kbrwfycbyy"
"\"\\hkuxqddnao"
"meqqsz\x83luecpgaem"
"cvks\x87frvxo\"svqivqsdpgwhukmju"
"sgmxiai\\o\"riufxwjfigr\xdf"
"fgywdfecqufccpcdn"
"faghjoq\x28abxnpxj"
"zuppgzcfb\"dctvp\"elup\"zxkopx"
"xqs\x45xxdqcihbwghmzoa"
"anbnlp\\cgcvm\"hc"
"xf\"fgrngwzys"
"nrxsjduedcy\x24"
"\x71sxl\"gj\"sds\"ulcruguz\\t\\ssvjcwhi"
"jhj\"msch"
"qpovolktfwyiuyicbfeeju\x01"
"nkyxmb\"qyqultgt\"nmvzvvnxnb"
"ycsrkbstgzqb\"uv\\cisn"
"s"
"ueptjnn\"\"sh"
"lp\"z\"d\"mxtxiy"
"yzjtvockdnvbubqabjourf\"k\"uoxwle"
"\x82\"wqm\""
"\xb5cwtuks\x5fpgh"
"wd"
"tbvf"
"ttbmzdgn"
"vfpiyfdejyrlbgcdtwzbnm"
"uc"
"otdcmhpjagqix"
"\\\xb1qso\"s"
"scowax"
"behpstjdh\xccqlgnqjyz\"eesn"
"r\xe1cbnjwzveoomkzlo\\kxlfouhm"
"jgrl"
"kzqs\\r"
"ctscb\x7fthwkdyko\"\x62pkf\"d\xe6knmhurg"
"tc\"kw\x3ftt"
"bxb\x5ccl"
"jyrmfbphsldwpq"
"jylpvysl\"\"juducjg"
"en\\m\"kxpq\"wpb\\\""
"madouht\"bmdwvnyqvpnawiphgac\""
"vuxpk\"ltucrw"
"aae\x60arr"
"ttitnne\"kilkrgssnr\xfdurzh"
"oalw"
"pc\"\"gktkdykzbdpkwigucqni\"nxiqx"
"dbrsaj"
"bgzsowyxcbrvhtvekhsh\"qgd"
"kudfemvk\"\"\"hkbrbil\"chkqoa"
"zjzgj\\ekbhyfzufy"
"\\acos\"fqekuxqzxbmkbnn\x1ejzwrm"
"elxahvudn\"txtmomotgw"
"\x2eoxmwdhelpr\"cgi\xf7pzvb"
"eapheklx"
"hfvma\"mietvc\"tszbbm\"czex"
"h\"iiockj\\\xc1et"
"d\"rmjjftm"
"qlvhdcbqtyrhlc\\"
"yy\"rsucjtulm\"coryri\"eqjlbmk"
"tv"
"r\"bfuht\\jjgujp\""
"kukxvuauamtdosngdjlkauylttaokaj"
"srgost\"\"rbkcqtlccu\x65ohjptstrjkzy"
"yxwxl\\yjilwwxffrjjuazmzjs"
"dxlw\\fkstu\"hjrtiafhyuoh\"sewabne"
"\x88sj\"v"
"rfzprz\xec\"oxqclu\"krzefp\\q"
"cfmhdbjuhrcymgxpylllyvpni"
"ucrmjvmimmcq\x88\xd9\"lz"
"lujtt\""
"gvbqoixn\"pmledpjmo\"flydnwkfxllf"
"dvxqlbshhmelsk\x8big\"l"
"mx\x54lma\x8bbguxejg"
"\x66jdati\xeceieo"
"\"iyyupixei\x54ff"
"xohzf\"rbxsoksxamiu"
"vlhthspeshzbppa\x4drhqnohjop\"\"mfjd"
"f\"tvxxla\"vurian\"\"idjq\x3aptm\xc3olep"
"gzqz"
"kbq\\wogye\\altvi\\hbvmodny"
"j\xd8"
"ofjozdhkblvndl"
"hbitoupimbawimxlxqze"
"ypeleimnme"
"xfwdrzsc\\oxqamawyizvi\\y"
"enoikppx\xa1ixe\"yo\"gumye"
"fb"
"vzf"
"zxidr"
"cu\x31beirsywtskq"
"lxpjbvqzztafwezd"
"\\jyxeuo\x18bv"
"b\"vawc\"p\\\\giern\"b"
"odizunx\"\"t\\yicdn\"x\"sdiz"
"\"\"tebrtsi"
"ctyzsxv\xa6pegfkwsi\"tgyltaakytccb"
"htxwbofchvmzbppycccliyik\xe5a"
"ggsslefamsklezqkrd"
"rcep\"fnimwvvdx\"l"
"zyrzlqmd\x12egvqs\\llqyie"
"\x07gsqyrr\\rcyhyspsvn"
"butg\""
"gb"
"gywkoxf\"jsg\\wtopxvumirqxlwz"
"rj\"ir\"wldwveair\x2es\"dhjrdehbqnzl"
"ru\"elktnsbxufk\\ejufjfjlevt\\lrzd"
"\"widsvok"
"oy\"\x81nuesvw"
"ay"
"syticfac\x1cfjsivwlmy\"pumsqlqqzx"
"m"
"rjjkfh\x78cf\x2brgceg\"jmdyas\"\\xlv\xb6p"
"tmuvo\"\x3ffdqdovjmdmkgpstotojkv\"as"
"jd\\ojvynhxllfzzxvbn\"wrpphcvx"
"pz"
"\"twr"
"n\\hdzmxe\"mzjjeadlz"
"fb\"rprxuagvahjnri"
"rfmexmjjgh\\xrnmyvnatrvfruflaqjnd"
"obbbde\"co\"qr\"qpiwjgqahqm\\jjp\""
"vpbq\"\"y\"czk\\b\x52ed\"lnzepobp"
"syzeajzfarplydipny\"y\"\xe8ad"
"mpyodwb"
"\x47rakphlqqptd"
"wa\"oj\"aiy"
"a"
"ropozx"
"q\x51nbtlwa"
"etukvgx\\jqxlkq"
"\"tp\"rah\"pg\"s\"bpdtes\\tkasdhqd"
"dn\"qqpkikadowssb\xcah\"dzpsf\\ect\"jdh"
"pxunovbbrrn\\vullyn\"bno\"\"\"myfxlp\""
"qaixyazuryvkmoulhcqaotegfj\\mpzm"
"bvfrbicutzbjwn\\oml\"cf\"d\"ezcpv\"j"
"rmbrdtneudemigdhelmb"
"aq\\aurmbhy"
"wujqvzw"
"gf\"tssmvm\"gm\"hu\x9a\xb7yjawsa"
"hrhqqxow\xe2gsydtdspcfqy\"zw\\ou"
"ianwwf\\yko\\tdujhhqdi"
"xylz\"zpvpab"
"lwuopbeeegp"
"aoop\x49jhhcexdmdtun"
"\\\\mouqqcsgmz"
"tltuvwhveau\x43b\"ymxjlcgiymcynwt"
"gsugerumpyuhtjljbhrdyoj"
"lnjm\xb8wg\"ajh"
"zmspue\"nfttdon\\b\"eww"
"\"w\x67jwaq\x7ernmyvs\\rmdsuwydsd\"th"
"ogtgvtlmcvgllyv"
"z\"fqi\"rvddoehrciyl"
"yustxxtot\"muec\"xvfdbzunzvveq"
"mqslw"
"txqnyvzmibqgjs\xb6xy\x86nfalfyx"
"kzhehlmkholov"
"plpmywcnirrjutjguosh\\"
"pydbnqofv\"dn\\m"
"aegqof"
"eambmxt\\dxagoogl\\zapfwwlmk"
"afbmqitxxqhddlozuxcpjxgh"
"vgts"
"bfdpqtoxzzhmzcilehnflna"
"s\"idpz"
"\xcfhgly\"nlmztwybx\"ecezmsxaqw"
"aackfgndqcqiy"
"\x22unqdlsrvgzfaohoffgxzfpir\"s"
"abh\"ydv\"kbpdhrerl"
"bdzpg"
"ekwgkywtmzp"
"wtoodejqmrrgslhvnk\"pi\"ldnogpth"
"njro\x68qgbx\xe4af\"\\suan"
#+END_SRC
** puzzle 1
#+BEGIN_SRC cpp :results output
  #include <stdio.h>

  int main() {
    FILE *f = fopen("d8.txt", "r");
    if (0 == f) {
      perror("error opening file d6.txt");
      return 1;
    }
    char line[124];

    int sum_diff = 0;
    while (fgets(line, sizeof(line), f) != 0) {
      int skips = 0;
      int real_len = 0;
      int i;
      for (i = 1; line[i] != '"'; i++) {
        real_len++;
        if (line[i] == '\\') {
          switch (line[i + 1]) {
          case 'x': i += 3; break;
          case '\\': case '"': i += 1; break;
          default: printf("Bad escaped char: %c in '%s'\n", line[i], line); return 0;
          }
        }
      }
      int code_len = i + 1;
      sum_diff += code_len - real_len;
      // printf("## code=%d, real=%d, line='%s'\n", code_len, real_len, line);
    }


    printf("%d", sum_diff);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 1350

 - too log 1227
** puzzle 2
#+BEGIN_SRC cpp :results output
  #include <stdio.h>

  int main() {
    FILE *f = fopen("d8.txt", "r");
    if (0 == f) {
      perror("error opening file d8.txt");
      return 1;
    }
    char line[124];

    int sum_diff = 0;
    while (fgets(line, sizeof(line), f) != 0) {
      int skips = 0;
      int encoded_len = 2; // encoded string in ""
      int i;
      for (i = 0; line[i] != '\n'; i++) {
        switch (line[i]) {
        case '\\': case '"': encoded_len += 2; break;
        default: encoded_len += 1;
        }
      }
      int code_len = i;
      sum_diff += encoded_len - code_len;
      // printf("## code=%d, encoded=%d, line='%s'\n", code_len, encoded_len, line);
    }


    printf("%d", sum_diff);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 2085

 - too low 977
 - too low 1485

* day 9
** text
--- Day 9: All in a Single Night ---

Every year, Santa manages to deliver all of his presents in a single night.

This year, however, he has some new locations to visit; his elves have provided him the distances between every pair of locations. He can start and end at any two (different) locations he wants, but he must visit each location exactly once. What is the shortest distance he can travel to achieve this?

For example, given the following distances:

London to Dublin = 464
London to Belfast = 518
Dublin to Belfast = 141

The possible routes are therefore:

Dublin -> London -> Belfast = 982
London -> Dublin -> Belfast = 605
London -> Belfast -> Dublin = 659
Dublin -> Belfast -> London = 659
Belfast -> Dublin -> London = 605
Belfast -> London -> Dublin = 982

The shortest of these is London -> Dublin -> Belfast = 605, and so the answer is 605 in this example.

What is the distance of the shortest route?

Your puzzle answer was 117.
--- Part Two ---

The next year, just to show off, Santa decides to take the route with the longest distance instead.

He can still start and end at any two (different) locations he wants, and he still must visit each location exactly once.

For example, given the distances above, the longest route would be 982 via (for example) Dublin -> London -> Belfast.

What is the distance of the longest route?

Your puzzle answer was 909.
** data
#+BEGIN_SRC text :tangle d9.txt :padline no
Faerun to Tristram = 65
Faerun to Tambi = 129
Faerun to Norrath = 144
Faerun to Snowdin = 71
Faerun to Straylight = 137
Faerun to AlphaCentauri = 3
Faerun to Arbre = 149
Tristram to Tambi = 63
Tristram to Norrath = 4
Tristram to Snowdin = 105
Tristram to Straylight = 125
Tristram to AlphaCentauri = 55
Tristram to Arbre = 14
Tambi to Norrath = 68
Tambi to Snowdin = 52
Tambi to Straylight = 65
Tambi to AlphaCentauri = 22
Tambi to Arbre = 143
Norrath to Snowdin = 8
Norrath to Straylight = 23
Norrath to AlphaCentauri = 136
Norrath to Arbre = 115
Snowdin to Straylight = 101
Snowdin to AlphaCentauri = 84
Snowdin to Arbre = 96
Straylight to AlphaCentauri = 107
Straylight to Arbre = 14
AlphaCentauri to Arbre = 46
#+END_SRC
** puzzle 1
#+BEGIN_SRC cpp :results output
  #include <stdio.h>
  #include <stdlib.h>
  #include <limits.h>
  #include <string.h>

  int city_id(char **cities, char *city) {
    int i = 0;
    while (cities[i] != NULL) {
      if (strcmp(city, cities[i]) == 0) {
        return i;
      }
      i++;
    }
    cities[i] = strdup(city);
    return i;
  }

  // https://en.wikipedia.org/wiki/Heap's_algorithm
  int heap(int dists[][128], int n, int *arr) {
    if (n == 1) {
      // printf("#### ");
      // for (int i = 0; arr[i] != -1; i++) {
      //   printf("%d, ", arr[i]);
      // }
      // printf("\n");
      int dist = 0;
      for (int i = 1; arr[i] != -1; i++) {
        if (arr[i - 1] < arr[i]) {
          dist += dists[arr[i - 1]][arr[i]];
        } else {
          dist += dists[arr[i]][arr[i - 1]];
        }
        // printf("### %d -> %d (%d)\n", arr[i - 1], arr[i], dist);
      }
      // printf("\n");
      return dist;
    } else {
      int min = INT_MAX;
      for (int i = 0; i < n - 1; i++) {
        int dist = heap(dists, n - 1, arr);
        if (dist < min) 
          min = dist;
        if (n % 2 == 0) {
          int tmp = arr[i];
          arr[i] = arr[n - 1];
          arr[n - 1] = tmp;
        } else {
          int tmp = arr[0];
          arr[0] = arr[n - 1];
          arr[n - 1] = tmp;
        }
      }
      int dist = heap(dists, n - 1, arr);
      if (dist < min) 
        min = dist;
      return min;
    }
  }

  int main() {
    FILE *f = fopen("d9.txt", "r");
    if (0 == f) {
      perror("error opening file d9.txt");
      return 1;
    }
    char line[124];

    char *cities[128] = { NULL };
    int dists[128][128] = { -1 };

    int max_id = 0;
    while (fgets(line, sizeof(line), f) != 0) {
      char from[64], to[64];
      int dist;
      sscanf(line, "%s to %s = %d", from, to, &dist);
      int from_id = city_id(cities, from);
      int to_id = city_id(cities, to);
      dists[from_id][to_id] = dist;
      if (from_id > max_id)
        max_id = from_id;
      if (to_id > max_id)
        max_id = to_id;
      // printf("## %d -> %d = %d\n", from_id, to_id, dist);
    }

    int perm[max_id + 2];
    for (int i = 0; i <= max_id; i++) {
      perm[i] = i;
    }
    perm[max_id + 1] = -1;

    printf("%d", heap(dists, max_id + 1, perm));
    return 0;
  }
#+END_SRC

#+RESULTS:
: 117

 - too high 546
** puzzle 2
#+BEGIN_SRC cpp :results output
  #include <stdio.h>
  #include <stdlib.h>
  #include <limits.h>
  #include <string.h>

  int city_id(char **cities, char *city) {
    int i = 0;
    while (cities[i] != NULL) {
      if (strcmp(city, cities[i]) == 0) {
        return i;
      }
      i++;
    }
    cities[i] = strdup(city);
    return i;
  }

  // https://en.wikipedia.org/wiki/Heap's_algorithm
  int heap(int dists[][128], int n, int *arr) {
    if (n == 1) {
      // printf("#### ");
      // for (int i = 0; arr[i] != -1; i++) {
      //   printf("%d, ", arr[i]);
      // }
      // printf("\n");
      int dist = 0;
      for (int i = 1; arr[i] != -1; i++) {
        if (arr[i - 1] < arr[i]) {
          dist += dists[arr[i - 1]][arr[i]];
        } else {
          dist += dists[arr[i]][arr[i - 1]];
        }
        // printf("### %d -> %d (%d)\n", arr[i - 1], arr[i], dist);
      }
      // printf("\n");
      return dist;
    } else {
      int max = INT_MIN;
      for (int i = 0; i < n - 1; i++) {
        int dist = heap(dists, n - 1, arr);
        if (dist > max) 
          max = dist;
        if (n % 2 == 0) {
          int tmp = arr[i];
          arr[i] = arr[n - 1];
          arr[n - 1] = tmp;
        } else {
          int tmp = arr[0];
          arr[0] = arr[n - 1];
          arr[n - 1] = tmp;
        }
      }
      int dist = heap(dists, n - 1, arr);
      if (dist > max) 
        max = dist;
      return max;
    }
  }

  int main() {
    FILE *f = fopen("d9.txt", "r");
    if (0 == f) {
      perror("error opening file d9.txt");
      return 1;
    }
    char line[124];

    char *cities[128] = { NULL };
    int dists[128][128] = { -1 };

    int max_id = 0;
    while (fgets(line, sizeof(line), f) != 0) {
      char from[64], to[64];
      int dist;
      sscanf(line, "%s to %s = %d", from, to, &dist);
      int from_id = city_id(cities, from);
      int to_id = city_id(cities, to);
      dists[from_id][to_id] = dist;
      if (from_id > max_id)
        max_id = from_id;
      if (to_id > max_id)
        max_id = to_id;
      // printf("## %d -> %d = %d\n", from_id, to_id, dist);
    }

    int perm[max_id + 2];
    for (int i = 0; i <= max_id; i++) {
      perm[i] = i;
    }
    perm[max_id + 1] = -1;

    printf("%d", heap(dists, max_id + 1, perm));
    return 0;
  }
#+END_SRC

#+RESULTS:
: 909

 - too high 546
* day 10
** text
--- Day 10: Elves Look, Elves Say ---

Today, the Elves are playing a game called look-and-say. They take turns making sequences by reading aloud the previous sequence and using that reading as the next sequence. For example, 211 is read as "one two, two ones", which becomes 1221 (1 2, 2 1s).

Look-and-say sequences are generated iteratively, using the previous value as input for the next step. For each step, take the previous value, and replace each run of digits (like 111) with the number of digits (3) followed by the digit itself (1).

For example:

    1 becomes 11 (1 copy of digit 1).
    11 becomes 21 (2 copies of digit 1).
    21 becomes 1211 (one 2 followed by one 1).
    1211 becomes 111221 (one 1, one 2, and two 1s).
    111221 becomes 312211 (three 1s, two 2s, and one 1).

Starting with the digits in your puzzle input, apply this process 40 times. What is the length of the result?

Your puzzle answer was 360154.
--- Part Two ---

Neat, right? You might also enjoy hearing John Conway talking about this sequence (that's Conway of Conway's Game of Life fame).

Now, starting again with the digits in your puzzle input, apply this process 50 times. What is the length of the new result?

Your puzzle answer was 5103798.
** puzzle 1
#+BEGIN_SRC cpp :results output :tangle d10p1.c
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>

  void look_and_say(char *in, char *out) {
    int outi = 0;
    for (int i = 0; in[i] != '\0';) {
      int j = i + 1;
      while (in[j] != '\0' && in[j] == in[i]) 
        j++;
      int dups = j - i;
      outi += sprintf(out + outi, "%d%d", dups, in[i] - '0');
      i += dups;
    }
    out[outi] = '\0';
  }

  int main() {
    char *puzzle = "1113122113";

    char *in = (char*) malloc(sizeof(char) * 1000000);
    char *out = (char*) malloc(sizeof(char) * 1000000);
    strcpy(in, puzzle);
    for (int i = 0; i < 40; i++) {
      look_and_say(in, out);
      strcpy(in, out);
    }

    printf("%d\n", strlen(out));
    return 0;
  }
#+END_SRC

#+RESULTS:
: 360154
** puzzle 2
#+BEGIN_SRC cpp :results output :tangle d10p1.c
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>

  void look_and_say(char *in, char *out) {
    int outi = 0;
    for (int i = 0; in[i] != '\0';) {
      int j = i + 1;
      while (in[j] != '\0' && in[j] == in[i]) 
        j++;
      int dups = j - i;
      outi += sprintf(out + outi, "%d%d", dups, in[i] - '0');
      i += dups;
    }
    out[outi] = '\0';
  }

  int main() {
    char *puzzle = "1113122113";

    char *in = (char*) malloc(sizeof(char) * 10000000);
    char *out = (char*) malloc(sizeof(char) * 10000000);
    strcpy(in, puzzle);
    for (int i = 0; i < 50; i++) {
      look_and_say(in, out);
      strcpy(in, out);
    }

    printf("%d\n", strlen(out));
    return 0;
  }
#+END_SRC

#+RESULTS:
: 5103798

* day 11
** text
--- Day 11: Corporate Policy ---

Santa's previous password expired, and he needs help choosing a new one.

To help him remember his new password after the old one expires, Santa has devised a method of coming up with a password based on the previous one. Corporate policy dictates that passwords must be exactly eight lowercase letters (for security reasons), so he finds his new password by incrementing his old password string repeatedly until it is valid.

Incrementing is just like counting with numbers: xx, xy, xz, ya, yb, and so on. Increase the rightmost letter one step; if it was z, it wraps around to a, and repeat with the next letter to the left until one doesn't wrap around.

Unfortunately for Santa, a new Security-Elf recently started, and he has imposed some additional password requirements:

    Passwords must include one increasing straight of at least three letters, like abc, bcd, cde, and so on, up to xyz. They cannot skip letters; abd doesn't count.
    Passwords may not contain the letters i, o, or l, as these letters can be mistaken for other characters and are therefore confusing.
    Passwords must contain at least two different, non-overlapping pairs of letters, like aa, bb, or zz.

For example:

    hijklmmn meets the first requirement (because it contains the straight hij) but fails the second requirement requirement (because it contains i and l).
    abbceffg meets the third requirement (because it repeats bb and ff) but fails the first requirement.
    abbcegjk fails the third requirement, because it only has one double letter (bb).
    The next password after abcdefgh is abcdffaa.
    The next password after ghijklmn is ghjaabcc, because you eventually skip all the passwords that start with ghi..., since i is not allowed.

Given Santa's current password (your puzzle input), what should his next password be?

Your puzzle answer was hxbxxyzz.
--- Part Two ---

Santa's password expired again. What's the next one?

Your puzzle answer was hxcaabcc.
** puzzle 1
#+BEGIN_SRC cpp :results output :tangle d11p1.c
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>

    int main() {
      char pass[1024] = { '\0' };
      char *puzzle = "hxbxwxba";
      int puzzle_len = strlen(puzzle);
      for (int i = 0; i < puzzle_len; i++) {
        pass[i] = puzzle[puzzle_len - i - 1];
      }

      while (1) {
      for (int i = 0; pass[i] != '\0'; i++) {
        if (pass[i] == 'z') {
          pass[i] = 'a';
        } else {
          pass[i]++;
          break;
        }
      }

      int iols = 0;
      int increments = 0;
      int pairs = 0;
      for (int i = 0; pass[i] != '\0'; i++) {
        switch (pass[i]) {
          case 'i': case 'o': case 'l': iols++;
        }
        if (i >= 2) {
          if (pass[i - 2] == pass[i - 1] + 1
              && pass[i - 1] == pass[i] + 1) {
              increments++;
          }
        }
        if (i >= 1) {
          if (pass[i - 1] == pass[i]
              && (i <= 2 || pass[i - 2] != pass[i])) {
            pairs++;
          }
        }
      }
      // printf("## '%s' iols=%d, increments=%d, pairs=%d\n", pass, iols, increments, pairs);
      if (increments >= 1 && iols == 0 && pairs >= 2) {
        for (int i = strlen(pass) - 1; i >= 0; i--) {
          printf("%c", pass[i]);
        }
        // printf("%s", pass);
        return 0;
      }
      }
      return 0;
    }
#+END_SRC

#+RESULTS:
: hxbxxyzz

 - wrong hxbxxwvv

** puzzle 2
#+BEGIN_SRC cpp :results output :tangle d11p2.c
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>

    int main() {
      char pass[1024] = { '\0' };
      char *puzzle = "hxbxxyzz";
      int puzzle_len = strlen(puzzle);
      for (int i = 0; i < puzzle_len; i++) {
        pass[i] = puzzle[puzzle_len - i - 1];
      }

      while (1) {
      for (int i = 0; pass[i] != '\0'; i++) {
        if (pass[i] == 'z') {
          pass[i] = 'a';
        } else {
          pass[i]++;
          break;
        }
      }

      int iols = 0;
      int increments = 0;
      int pairs = 0;
      for (int i = 0; pass[i] != '\0'; i++) {
        switch (pass[i]) {
          case 'i': case 'o': case 'l': iols++;
        }
        if (i >= 2) {
          if (pass[i - 2] == pass[i - 1] + 1
              && pass[i - 1] == pass[i] + 1) {
              increments++;
          }
        }
        if (i >= 1) {
          if (pass[i - 1] == pass[i]
              && (i < 2 || pass[i - 2] != pass[i])) {
            pairs++;
          }
        }
      }
      // printf("## '%s' iols=%d, increments=%d, pairs=%d\n", pass, iols, increments, pairs);
      if (increments >= 1 && iols == 0 && pairs >= 2) {
        for (int i = strlen(pass) - 1; i >= 0; i--) {
          printf("%c", pass[i]);
        }
        // printf("%s", pass);
        return 0;
      }
      }
      return 0;
    }
#+END_SRC

#+RESULTS:
: hxcaabcc

* day 12
** text
--- Day 12: JSAbacusFramework.io ---

Santa's Accounting-Elves need help balancing the books after a recent order. Unfortunately, their accounting software uses a peculiar storage format. That's where you come in.

They have a JSON document which contains a variety of things: arrays ([1,2,3]), objects ({"a":1, "b":2}), numbers, and strings. Your first job is to simply find all of the numbers throughout the document and add them together.

For example:

    [1,2,3] and {"a":2,"b":4} both have a sum of 6.
    [[[3]]] and {"a":{"b":4},"c":-1} both have a sum of 3.
    {"a":[-1,1]} and [-1,{"a":1}] both have a sum of 0.
    [] and {} both have a sum of 0.

You will not encounter any strings containing numbers.

What is the sum of all numbers in the document?

Your puzzle answer was 191164.
--- Part Two ---

Uh oh - the Accounting-Elves have realized that they double-counted everything red.

Ignore any object (and all of its children) which has any property with the value "red". Do this only for objects ({...}), not arrays ([...]).

    [1,2,3] still has a sum of 6.
    [1,{"c":"red","b":2},3] now has a sum of 4, because the middle object is ignored.
    {"d":"red","e":[1,2,3,4],"f":5} now has a sum of 0, because the entire structure is ignored.
    [1,"red",5] has a sum of 6, because "red" in an array has no effect.

Your puzzle answer was 87842.
** data
#+BEGIN_SRC text :tangle d12.txt :padline no
[["green",[{"e":"green","a":77,"d":{"c":"violet","a":"yellow","b":"violet"},"c":"yellow","h":"red","b":144,"g":{"a":["yellow",-48,72,87,{"e":"violet","c":123,"a":101,"b":87,"d":"red","f":88},{"e":"red","c":2,"a":1,"g":"blue","b":"green","d":"violet","f":170},"orange",171,162]},"f":"orange","i":"orange"},49,[{"c":{"e":"violet","a":-44,"d":115,"c":117,"h":194,"b":{"e":-17,"a":172,"d":"green","c":197,"h":53,"b":106,"g":"violet","f":-10},"g":"red","f":"orange"},"a":-49,"b":["violet","orange","blue"]}],"green"]],["orange"],{"e":"blue","a":["red","yellow"],"d":{"a":[{"c":{"a":181,"b":["orange",-40,"red","orange","yellow",31,60,71,"yellow"]},"a":[114,-40],"b":"orange"},["green",93,10,{"c":11,"a":170,"b":[161,-3],"d":-16},58,{"e":{"c":-2,"a":117,"b":"violet"},"c":["blue","yellow","red","violet","yellow",123,113],"a":"orange","g":19,"b":108,"d":"red","f":"yellow"},{"e":"green","c":"yellow","a":{"e":28,"c":"red","a":"violet","b":"red","d":"green"},"g":"yellow","b":116,"d":148,"f":"red"},[15],["green","green",43],"blue"],[133],"green",134,"violet",{"c":"red","a":[71,41,"blue"],"b":"yellow","d":"violet"},132,[10,"violet",[182,"green","green","orange"],78,{"c":"blue","a":[100,-36,"blue","violet",-10,"orange"],"b":{"e":"orange","c":"blue","a":160,"g":"green","b":190,"d":"red","f":186}},16],[{"c":"green","a":"violet","b":20,"d":"red"},"green","blue",{"c":[0,84,184,"orange",-34,"blue","orange",0,"violet","violet"],"a":10,"b":89},"green",182,127,-2,196]]},"c":-20,"h":[[165,[180,"yellow",-5,16,"red",[{"e":"orange","a":"orange","d":"orange","c":"yellow","h":"red","b":182,"g":21,"f":"violet"},"red",69,"violet",10,"red","orange"]],[160,"blue",{"e":"yellow","c":"violet","a":"green","g":43,"b":[-40,"yellow","yellow",118,57,"green","violet","yellow","violet"],"d":"yellow","f":"blue"}],130,{"e":["yellow",58,"green",139,"violet","red"],"c":"green","a":"green","g":{"e":163,"c":33,"a":15,"b":78,"d":"green"},"b":86,"d":"orange","f":58},"red","red",{"a":37}],"yellow",{"e":44,"a":{"a":136,"b":"yellow"},"d":"yellow","j":39,"c":[-28,["violet",{"e":"red","a":150,"d":189,"c":76,"h":"orange","b":"yellow","g":164,"f":"orange"}],{"e":12,"a":"red","d":"yellow","c":"yellow","h":102,"b":"yellow","g":"red","f":147},"violet",[40,"red",24,193,105,179,"violet","green",{"a":"yellow","b":"violet"}],39,-25,{"a":127},126,{"e":"red","c":151,"a":-46,"b":"green","d":"violet"}],"h":"red","b":122,"g":93,"f":["violet",{"c":102,"a":-16,"b":39,"d":176},"red",187,{"e":"blue","a":172,"d":{"a":-5},"c":25,"h":{"a":"red"},"b":"blue","g":["yellow","red"],"f":{"e":158,"c":85,"a":"blue","g":"green","b":"violet","d":125,"f":93},"i":11},"violet"],"i":[195,{"a":"blue"},48,[44,25,"green","red","violet",172,"orange",49]]},["yellow",[{"e":-4,"a":"red","d":"green","c":"blue","h":"green","b":"green","g":190,"f":30,"i":-2},"green","violet",{"e":92,"c":-11,"a":{"e":"orange","c":0,"a":47,"g":"blue","b":"orange","d":"yellow","f":-47},"b":40,"d":193},97,"violet",[51,168,"violet",{"c":-45,"a":167,"b":"orange"},"blue","orange",64],[188,"green",91,-10,66,"green"],"green","blue"],"green",-42,{"e":"red","c":"red","a":199,"g":84,"b":"blue","d":["blue",194,["green",88,110,-23,"yellow","green",15,"violet"]],"f":"red"}],{"e":"blue","c":-33,"a":-34,"b":"blue","d":81}],"b":{"e":"violet","c":165,"a":"violet","b":{"a":"red","b":"yellow"},"d":[6,71,"orange","orange",{"a":96},74,"yellow"]},"g":["yellow",["orange",[-27],[[[8,"red","blue",-46,62,"yellow",94],[60,"violet",141,"green"],16,"green","yellow","blue",81,[93,"red",183,"blue","red",30,-16,"red","red","yellow"],-21,139],{"c":"blue","a":"orange","b":"violet","d":51}],"blue","yellow",["violet",19,"orange","yellow","red","violet","blue","violet",{"e":"yellow","a":"violet","d":137,"c":"blue","h":197,"b":"orange","g":{"e":"yellow","c":"orange","a":18,"b":42,"d":183,"f":142},"f":68}],"green",["blue",85,"violet"]]],"f":"green"},[92,{"c":-26,"a":{"c":["orange","orange",{"e":131,"c":192,"a":-38,"g":16,"b":27,"d":"yellow","f":-46},120,"orange",-28,-18,3],"a":["red",-15,{"e":56,"c":-15,"a":150,"g":"blue","b":"orange","d":"violet","f":70},-44,{"e":"green","c":53,"a":"blue","b":"blue","d":-34,"f":"violet"},"orange",[161,"orange",-19,{"e":27,"c":98,"a":"violet","g":"yellow","b":-45,"d":191,"f":"green"}]],"b":-41,"d":[["orange","red","yellow",120,140],[{"e":-1,"c":"orange","a":"yellow","b":"yellow","d":86},42,[78,140,"orange","green","orange",-49,159],"yellow","red",90,{"c":"green","a":62,"b":"violet"}],"violet",178,30,"green",186]},"b":"red","d":"violet"},{"e":-21,"a":{"e":{"e":{"e":"orange","c":115,"a":199,"b":-43,"d":"yellow"},"a":"blue","d":"green","c":"blue","h":"violet","b":"red","g":"violet","f":{"a":5}},"a":[{"e":"green","a":[20,"yellow",23,100,"orange",142,"red",-3],"d":19,"c":18,"h":"blue","b":"yellow","g":"yellow","f":{"a":-33}}],"d":"yellow","j":"yellow","c":["red",-2,95,-1,"green","violet",12],"h":"orange","b":{"e":[94,-14,"orange",68],"c":["blue","yellow",[-12,"yellow",126,"orange",199,"red",133],{"e":-14,"a":40,"d":-48,"c":5,"h":"orange","b":"red","g":"yellow","f":"red","i":"orange"},"blue",[-35,87,84,"yellow"],"red","red",86,"yellow"],"a":11,"g":{"e":-34,"a":"orange","d":"blue","j":"blue","c":"yellow","h":"yellow","b":"violet","g":42,"f":188,"i":53},"b":"yellow","d":{"e":"red","c":84,"a":"violet","b":"orange","d":87},"f":["blue","yellow","red",{"c":"orange","a":"blue","b":61},"violet",20,-22,129]},"g":{"e":28,"c":170,"a":["green",98,"orange",150,"orange"],"b":"blue","d":"blue"},"f":"blue","i":[{"e":"green","a":"blue","d":19,"c":177,"h":-18,"b":{"e":-19,"a":"green","d":"yellow","c":172,"h":"red","b":"red","g":"yellow","f":"yellow"},"g":{"c":-36,"a":"red","b":"violet"},"f":121},141,"violet",113,81]},"d":{"e":133,"a":19,"d":-27,"c":{"c":["yellow"],"a":105,"b":{"a":"orange"},"d":{"e":"yellow","c":"orange","a":"orange","b":163,"d":"violet","f":"red"}},"h":"yellow","b":161,"g":110,"f":[[137,6,[195,"violet",179,93,"green",130,"blue","yellow"],70,"orange",-8,-28,"orange",{"e":59,"a":"red","d":128,"j":88,"c":"violet","h":188,"b":0,"g":0,"f":"green","i":2}],86,"green","orange",68,"yellow"]},"c":{"e":"violet","a":-49,"d":["blue",140],"c":-29,"h":["red",4,-45,165,["yellow","blue","blue"]],"b":"blue","g":{"e":{"e":{"e":"blue","c":168,"a":51,"b":-28,"d":"orange","f":"violet"},"c":"violet","a":"green","g":"blue","b":-29,"d":121,"f":69},"a":"violet","d":["orange",[12,192,"green",-17,160,"blue"],131,"blue",41,{"e":"violet","a":"green","d":"blue","c":182,"h":"red","b":10,"g":"blue","f":-37,"i":151},"blue"],"c":{"e":"orange","a":182,"d":155,"j":18,"c":-41,"h":119,"b":148,"g":"green","f":104,"i":141},"h":16,"b":"blue","g":[137],"f":"green","i":-35},"f":[["green","red",19,"yellow","blue","red"],["red",37,[36,"red",-38,183,"violet",-17,119,93],130,-20,77,[64,115,66,"green"]],-13,-23,"green",100,"orange",{"a":"orange","b":"red"}]},"h":["red",{"e":28,"c":{"c":"green","a":149,"b":["orange",137,"violet",184,"orange","green","red",20,72]},"a":114,"g":["blue",{"e":"yellow","a":104,"d":"red","c":-17,"h":"blue","b":"violet","g":"orange","f":"red","i":"red"},181,21,"blue","orange",111,{"e":39,"a":"orange","d":196,"j":119,"c":143,"h":-42,"b":"green","g":190,"f":-43,"i":37}],"b":"orange","d":{"e":["green",44,"green",177,"violet",-44,160,"violet",85,95],"a":{"e":138,"c":"yellow","a":"yellow","b":"blue","d":"green"},"d":"violet","j":"blue","c":100,"h":"blue","b":104,"g":-28,"f":189,"i":"orange"},"f":[121,{"c":110,"a":68,"b":5,"d":57},[108],15,"red",[83,"blue","green",-16,"yellow"],"green"]},[[80],160,68,187,"green","green",94,113,2,163],34,"orange",["yellow",{"e":72,"c":["green",11,"green","green","orange"],"a":{"c":"violet","a":13,"b":66,"d":36},"g":"blue","b":"yellow","d":140,"f":145},"red",53,-11,"yellow","blue",148,{"e":"violet","a":"violet","d":83,"c":"yellow","h":103,"b":-23,"g":36,"f":[154,"red",62,112,35],"i":"violet"}],{"e":174,"a":-49,"d":58,"j":114,"c":"violet","h":[162,"red",54,-8,[142,178,"red",26,"violet",71,-20,38,"orange"],"orange","yellow",[49,25,"violet","green","blue",189,"green","yellow",-25,55],"red"],"b":-13,"g":156,"f":[48,107,-15,167],"i":"blue"},["red",{"a":"red","b":"red"},"violet",[73,"blue","violet","red"],["red","red"],63,-12,108]],"b":{"c":"violet","a":{"a":-39,"b":166},"b":183},"g":36,"f":[45,"yellow","blue","violet",26,7,[[156,-18,"yellow"],-4,-37,[129,-11,["yellow",179,"violet","red","yellow","violet"],"red","red",133],17,"green",137,"red",-9,"yellow"],"yellow",[{"e":"green","a":"yellow","d":52,"c":127,"h":132,"b":38,"g":"yellow","f":"violet","i":"red"},"yellow","red",{"e":{"c":60,"a":126,"b":88},"a":159,"d":"red","j":70,"c":23,"h":195,"b":178,"g":"red","f":"yellow","i":"blue"},13,-37,[196,146,145,"orange",60,"violet",["red",144,51,"red",-26,172,"yellow","red",52,"yellow"],157,"green"],[{"a":-7,"b":"red"},123,{"e":"yellow","c":"orange","a":"orange","b":40,"d":"blue"},139,"green","red",48,{"e":165,"a":60,"d":83,"c":"yellow","h":186,"b":34,"g":"blue","f":178,"i":33},[116,"yellow",179,18,32]],"red"]]},{"c":[6,{"e":{"c":79,"a":82,"b":"orange"},"a":"blue","d":[38,"red",37,[12,134,139,"violet",102,60,"green",82,91],"orange",84],"j":"orange","c":["yellow","green","blue","violet",{"e":"orange","c":157,"a":"green","b":"blue","d":"violet","f":"blue"},64,["violet",176,-7,137,"red",57,"yellow"],"yellow",["blue",170,159],"orange"],"h":170,"b":[3],"g":"violet","f":"violet","i":186},{"e":{"e":"yellow","c":"red","a":"blue","g":["violet",104],"b":124,"d":42,"f":"violet"},"c":-43,"a":-28,"b":[6],"d":[0,97,{"e":-9,"a":"violet","d":31,"c":23,"h":40,"b":76,"g":"red","f":94},["violet"],124,68,"green",37]},[84,{"e":"yellow","c":18,"a":"orange","b":"blue","d":"red"},["yellow",66],81,"orange",-22,-10,"green",139],"red","yellow"],"a":25,"b":"yellow"},[{"e":25,"a":{"e":["violet",22,103,{"e":193,"c":"red","a":"yellow","g":"violet","b":"yellow","d":-33,"f":29},{"e":-10,"a":77,"d":"blue","c":-15,"h":74,"b":-4,"g":"orange","f":153},"yellow",176,94,"green",141],"c":"blue","a":146,"b":-26,"d":-7,"f":149},"d":"green","c":["violet"],"h":"orange","b":[[23,"violet","blue","violet","violet",-40],"orange","yellow"],"g":57,"f":[{"e":141,"a":"yellow","d":"red","c":138,"h":118,"b":{"a":"yellow","b":"red"},"g":133,"f":{"e":169,"c":"violet","a":"green","g":193,"b":"orange","d":"violet","f":-17},"i":"yellow"},72,"green","violet",[106,"red","red","red","yellow",180,"orange",{"a":"green","b":"green"},111,"blue"],147],"i":-7},[[62,65,158,"blue",86,"yellow"],[71,[168,179,"yellow","red","green"],-7],"violet"],"violet",["yellow","red","blue","orange",78,47,{"c":"orange","a":"violet","b":152},[-37,"yellow"],-11,6]],"red",{"e":"red","a":"orange","d":{"e":"red","a":10,"d":"blue","c":{"c":"green","a":91,"b":"yellow","d":-28},"h":158,"b":[["orange"]],"g":"blue","f":[[137,157,50,10,"blue",-12,"violet",76,76,80],[164,46,"orange",-23,{"a":"green"},"yellow","green","green","yellow",48],47]},"j":{"e":["orange",{"e":191,"c":"orange","a":25,"g":"red","b":"yellow","d":148,"f":"orange"},-34,"orange","orange",-36],"a":[{"e":198,"a":["blue",80,121,36,102],"d":{"e":"green","a":"blue","d":76,"j":"red","c":127,"h":"yellow","b":"yellow","g":"yellow","f":163,"i":"red"},"c":"yellow","h":73,"b":"red","g":"green","f":"red"},"violet",{"e":133,"a":"blue","d":"green","j":3,"c":"violet","h":144,"b":25,"g":"green","f":102,"i":"green"},{"e":{"a":"violet","b":"green"},"a":"green","d":[86],"c":"green","h":3,"b":{"c":"orange","a":"orange","b":"yellow","d":193},"g":-34,"f":-35,"i":"green"}],"d":[{"e":"violet","a":"blue","d":{"c":79,"a":"red","b":0,"d":"violet"},"c":77,"h":"violet","b":"green","g":-47,"f":"green"},-49,90],"j":"blue","c":"yellow","h":["violet","green",28,"green",97,"orange"],"b":53,"g":{"e":21,"a":{"c":42,"a":"blue","b":"red"},"d":"violet","c":142,"h":158,"b":"blue","g":["orange",197,"blue","green","yellow",-3,15,-38],"f":62},"f":{"a":32},"i":79},"c":{"e":[{"e":[125,"yellow",-43,"orange","red"],"c":3,"a":"orange","b":"orange","d":{"e":195,"c":16,"a":"yellow","b":94,"d":-20,"f":-13},"f":"yellow"},89,["orange"],"violet"],"c":{"e":"red","a":"orange","d":5,"j":{"a":92,"b":142},"c":22,"h":"blue","b":"orange","g":{"a":[-13,199,"green",133,-41,-22,"orange",169],"b":[134,"blue"]},"f":183,"i":["green",-24,"violet"]},"a":116,"g":[{"e":57,"a":["blue",144,44,43,"orange",34,"yellow",126,"red"],"d":"green","c":"violet","h":"orange","b":"violet","g":"violet","f":[196,60],"i":-21},[168],["red","violet","yellow","green","yellow","green","blue",113,{"e":"orange","a":"red","d":-7,"c":-29,"h":"orange","b":-44,"g":"red","f":-32}],{"a":116},"blue"],"b":{"c":{"e":-41,"a":"orange","d":154,"c":"yellow","h":-12,"b":"yellow","g":"blue","f":"violet","i":105},"a":-23,"b":2},"d":161,"f":"orange"},"h":[187,{"c":"yellow","a":"orange","b":"orange","d":"red"},[[58,"blue"],[111,["yellow","green","green","violet","green"],"orange","blue",112,-45],31,"violet"]],"b":{"e":[[13,"blue",-19,"blue","yellow",144,23,17,110],"violet",{"c":"orange","a":"yellow","b":73,"d":"red"},9,115,"blue","violet","yellow","blue","green"],"a":[-9,"yellow","violet",183,"red",14,"blue",192,"yellow",165],"d":"blue","j":{"e":[86],"a":-14,"d":"yellow","j":"violet","c":"violet","h":{"e":85,"a":["red","yellow",114,111,129,37,71,"blue"],"d":"yellow","c":43,"h":11,"b":72,"g":128,"f":"red"},"b":11,"g":183,"f":34,"i":187},"c":122,"h":{"c":[93,132,"yellow","yellow",91],"a":"green","b":"orange"},"b":[{"e":"blue","a":"green","d":"blue","j":{"e":"orange","a":"violet","d":"orange","j":"yellow","c":"yellow","h":"orange","b":"green","g":"orange","f":"green","i":"green"},"c":186,"h":"yellow","b":145,"g":112,"f":"orange","i":"orange"},100,139,-11,{"e":103,"c":["green","red",-40,90,"violet","violet","yellow"],"a":140,"g":"red","b":"violet","d":"red","f":"blue"},{"c":-43,"a":"orange","b":66},"red",["red","orange",["blue",187],76,192,50,"yellow","violet"]],"g":38,"f":"blue","i":[129,[30,"green",157,92,181,176],{"e":"violet","a":127,"d":172,"j":"yellow","c":148,"h":171,"b":"yellow","g":{"e":115,"a":"red","d":48,"c":-12,"h":"blue","b":"orange","g":"red","f":78},"f":135,"i":79}]},"g":[[173,131,"yellow",193,162,"yellow"],[-5,{"e":[116,102,"orange","yellow"],"a":189,"d":136,"c":{"e":72,"a":"blue","d":-13,"j":"yellow","c":90,"h":"violet","b":169,"g":"orange","f":"blue","i":"blue"},"h":186,"b":"orange","g":"red","f":"orange"},{"e":-8,"a":-37,"d":104,"c":"violet","h":"orange","b":-31,"g":25,"f":168,"i":119},"green",32,[[197,"orange","violet"]],"yellow",{"e":["red",-16,"yellow"],"a":"blue","d":31,"c":"yellow","h":"red","b":"red","g":"violet","f":20,"i":"violet"},31,80],22,{"e":{"e":"red","a":125,"d":"yellow","j":111,"c":34,"h":193,"b":100,"g":"orange","f":31,"i":15},"c":{"e":75,"a":13,"d":-29,"c":["green"],"h":-46,"b":{"a":58},"g":100,"f":{"c":"violet","a":"red","b":-35},"i":["violet","green","orange","violet",183,0,-27,96]},"a":"red","b":[95,"orange","blue","green",170,{"e":3,"a":"blue","d":125,"j":-25,"c":10,"h":25,"b":"blue","g":182,"f":141,"i":27},["violet",7,76,-37,"red",59,"yellow",29]],"d":78,"f":88}],"f":["violet",72],"i":[96,["green","orange",63,"red",83,"yellow"],[{"e":"red","a":{"e":"orange","a":"green","d":183,"c":"orange","h":"yellow","b":146,"g":-1,"f":"red","i":"orange"},"d":"green","j":"red","c":"red","h":"yellow","b":"violet","g":-9,"f":182,"i":"red"},-49,17,"orange",187,-2,[178,"red","red",131,195,[94,-26,"blue","green",0,1,101]]],-25,14,"violet",{"c":"blue","a":"green","b":"orange"},198,-2]},9],[{"e":["green",177,[-38],{"e":"green","a":[147,"green",[56,93,"violet","red"],82,{"e":"blue","a":"orange","d":"red","c":30,"h":"blue","b":10,"g":"orange","f":"orange","i":82},193],"d":"violet","j":69,"c":"green","h":161,"b":-12,"g":{"e":125,"c":-33,"a":-42,"g":70,"b":{"c":81,"a":52,"b":"red","d":"violet"},"d":["violet"],"f":39},"f":["red","green",74,158,14],"i":"yellow"},[144,88,["yellow","violet",-1,"blue",109,[53,86,-36,91,"violet","green",59,15],171,"blue"]],185],"c":{"e":{"a":92},"a":67,"d":"violet","c":"blue","h":[71,"violet",25,154,{"e":16,"a":"red","d":"red","j":"violet","c":54,"h":"violet","b":160,"g":"orange","f":{"e":-47,"a":"green","d":"blue","c":56,"h":175,"b":118,"g":97,"f":"red"},"i":"yellow"},{"e":[107,"violet","violet","blue",-4,"blue","green",82,"red"],"c":{"e":"yellow","c":"violet","a":"orange","b":"blue","d":"green"},"a":172,"b":131,"d":"green","f":43},"red","green",["red","green","violet","violet",132,"green",153,195,-41,[128]]],"b":"yellow","g":"green","f":{"c":72,"a":{"c":"green","a":"violet","b":"green","d":180},"b":48,"d":["blue",70,60,"orange",139,183,"red","red",{"a":"red","b":123},"yellow"]},"i":[66,77,"green","violet",25,[193,"orange",78,"red",["violet","red",163,37,"yellow"]]]},"a":"red","b":175,"d":0,"f":[{"e":38,"a":"yellow","d":"violet","c":68,"h":{"e":"orange","c":129,"a":"blue","b":"green","d":106,"f":"orange"},"b":"red","g":"green","f":{"e":91,"c":46,"a":"blue","g":"red","b":"yellow","d":92,"f":"yellow"}},["green",65,150,86,"orange"],"green",{"c":"green","a":30,"b":"yellow"}]},["blue",70,143,{"a":"green","b":[{"e":83,"c":63,"a":-2,"g":{"e":"green","c":"orange","a":-46,"b":"yellow","d":"red"},"b":39,"d":"red","f":123},"orange",57,34,{"c":"yellow","a":{"c":"blue","a":"green","b":"blue"},"b":"orange","d":{"e":"blue","a":158,"d":"red","c":69,"h":122,"b":6,"g":93,"f":"yellow","i":163}},{"e":183,"c":99,"a":"orange","g":76,"b":42,"d":31,"f":118}]},{"e":31,"c":["orange",186,58,{"e":"violet","c":9,"a":115,"b":[115,"yellow",19,"violet","blue","yellow"],"d":106}],"a":{"e":"red","c":{"a":82,"b":180},"a":71,"b":"yellow","d":100},"g":{"c":68,"a":"red","b":{"a":"blue","b":70}},"b":"yellow","d":"violet","f":-4},"yellow",[{"a":"yellow"},[{"e":"violet","a":159,"d":"violet","c":"blue","h":{"a":195,"b":-16},"b":97,"g":74,"f":126,"i":83},-49,"orange","orange",20,{"e":-37,"c":82,"a":"blue","b":"yellow","d":"orange"},"violet","green",5],"blue",{"a":-2},{"e":-39,"c":"yellow","a":-3,"b":127,"d":[196]},{"c":"red","a":-1,"b":"orange","d":166},{"e":{"e":"red","a":97,"d":"orange","j":47,"c":84,"h":-36,"b":-5,"g":"red","f":"yellow","i":113},"c":55,"a":{"e":[13,108,137,"green","green",-9,71,-36,"orange","blue"],"a":"violet","d":95,"c":6,"h":125,"b":"orange","g":"orange","f":130},"b":-28,"d":[97,46,[-7,"violet",146,155,166,"orange","orange","yellow",148,"red"],"orange",40,"red"]}],[{"c":"violet","a":"yellow","b":64,"d":"orange"},{"e":{"e":"violet","c":"blue","a":{"e":"yellow","a":-41,"d":181,"c":101,"h":"orange","b":"orange","g":"blue","f":51},"g":-25,"b":"red","d":41,"f":1},"a":25,"d":{"e":"orange","a":"green","d":-9,"c":"orange","h":71,"b":"red","g":137,"f":133},"j":[["yellow",116],93,"orange","violet","blue",150,34],"c":66,"h":"violet","b":-49,"g":[60,194,[136,-37,160,"red","orange","red",179,"red"]],"f":[-24,"violet",35],"i":"blue"},{"e":92,"c":"blue","a":"red","b":"blue","d":"green"},"red",[126],96,"red",198],87],{"e":{"e":["orange","violet",{"e":"green","a":-42,"d":103,"c":["violet",-48,37,122,107,"orange","blue",97],"h":"blue","b":92,"g":"orange","f":0},"blue",197,-9,"yellow",{"a":["orange","blue",186,"blue","green","red","red",48,"red","green"],"b":195},121,"blue"],"a":96,"d":"orange","j":94,"c":66,"h":{"a":["violet"],"b":"orange"},"b":"violet","g":191,"f":{"e":"red","c":-32,"a":[149,[69,"green",84,25,"red"],"yellow","violet",4,"violet","green",69],"b":"blue","d":148,"f":111},"i":93},"a":[181],"d":{"e":{"e":{"e":"red","c":36,"a":143,"b":82,"d":11},"a":168,"d":"orange","j":-45,"c":159,"h":"red","b":{"e":120,"a":-37,"d":"green","c":"green","h":"red","b":59,"g":"violet","f":173},"g":166,"f":"orange","i":"yellow"},"a":158,"d":"green","c":126,"h":[[159,"violet","violet","green",101,"orange",141],"violet",122,"yellow","red",79],"b":13,"g":"red","f":{"a":"orange"},"i":{"a":89,"b":{"e":[-20,"green",6,58,18],"a":-17,"d":137,"c":[-25,"orange",95,"yellow","green"],"h":3,"b":"violet","g":26,"f":"green","i":168}}},"c":["orange",{"e":163,"a":{"a":6},"d":-25,"c":164,"h":[-47,"yellow","orange",[139,93,93,"yellow","violet","red",-12],"blue",-32,136,10],"b":"orange","g":"blue","f":174}],"h":["blue",-34,-29,{"e":"violet","a":3,"d":"green","j":"red","c":"orange","h":"green","b":"red","g":"green","f":124,"i":{"e":186,"c":"violet","a":168,"g":110,"b":[127,136,31,109,"blue","red","blue","violet",79,91],"d":"red","f":["violet",191,-15,-22]}}],"b":[124,{"e":-38,"a":{"a":"yellow"},"d":[130,{"c":158,"a":"blue","b":103,"d":197},-36,[153,-6,173,121,"yellow",94,168,"violet",77,-35],168,"red",{"e":-32,"a":"red","d":46,"c":82,"h":91,"b":"blue","g":"yellow","f":"orange","i":174},"green"],"j":[189,-43,41],"c":[185],"h":[182],"b":[139,"violet",-44],"g":"yellow","f":"red","i":["red",-18,"violet","red",31,"red",115,-49,["yellow","yellow","violet","blue","violet","violet"]]},143,"yellow",["violet","red",["blue","violet",{"a":-49},41,"orange","blue"],{"a":"orange"},[93,-8,"yellow",-39]],166,155,"red","violet","orange"],"g":"violet","f":"red","i":[85,126,{"e":{"e":"red","c":-42,"a":51,"b":"yellow","d":"red","f":{"e":130,"c":"violet","a":115,"g":"violet","b":-28,"d":-3,"f":"blue"}},"a":92,"d":114,"c":"violet","h":{"e":-41,"a":"red","d":57,"j":82,"c":"violet","h":"green","b":"red","g":2,"f":-20,"i":78},"b":"yellow","g":"violet","f":86,"i":67},147,146,-33,"blue","violet"]},{"e":[[{"a":174},21,"orange","green","blue",{"e":127,"c":{"c":0,"a":197,"b":"yellow"},"a":"blue","b":["yellow",153,9,"blue"],"d":136}],"blue"],"c":[{"c":"red","a":[-5,"green",["violet"],-47,19,173],"b":106,"d":"yellow"},182,[21,106,"violet",10,"green",20,"orange"],["green"],{"e":-25,"c":"blue","a":"violet","b":["red",27,"blue",21,193,"green",["green","green"]],"d":["orange"],"f":18},"yellow","yellow",{"e":{"e":"violet","a":"green","d":"violet","c":"red","h":171,"b":["red",149,"violet"],"g":"yellow","f":"blue","i":"green"},"c":[86,-30,"orange",56,123,"green"],"a":65,"b":[86,129,"yellow","blue",87,127,182],"d":4,"f":[-36,179,"red",-9,27,{"c":111,"a":178,"b":"yellow","d":25},"red","blue"]},[-3,5,["orange","blue"],70],"yellow"],"a":[{"e":{"c":-15,"a":"red","b":-18,"d":"green"},"a":-42,"d":{"c":-47,"a":"red","b":"green","d":"yellow"},"c":{"e":56,"a":"green","d":"yellow","c":"orange","h":"yellow","b":"blue","g":-35,"f":179,"i":"green"},"h":"blue","b":[35,153],"g":193,"f":{"e":{"e":37,"c":86,"a":"green","g":170,"b":"violet","d":"red","f":-33},"c":187,"a":16,"b":147,"d":19,"f":"red"},"i":88},"green","blue",{"e":{"e":"orange","a":"blue","d":"orange","c":150,"h":-12,"b":"green","g":"red","f":145,"i":"red"},"c":"red","a":"yellow","b":"yellow","d":"blue"},196,{"e":"green","c":186,"a":"green","g":-18,"b":"red","d":[102,"green","orange",[-6,160,128,"green","violet",48,"violet","yellow",50],"blue","green","orange",[199,59,20,15,126]],"f":[[120,"red",69],49,18,84,"red","green",["orange","blue",-31,"green","red",198,115]]},{"e":"yellow","a":196,"d":["orange",{"e":"violet","a":21,"d":"green","c":"red","h":"green","b":18,"g":48,"f":174,"i":"orange"},{"a":-1,"b":"green"},"green"],"c":106,"h":"blue","b":"blue","g":"yellow","f":{"e":-4,"a":61,"d":18,"c":122,"h":"green","b":84,"g":165,"f":"orange"}}],"b":[43,{"e":137,"c":"green","a":"green","b":75,"d":125}],"d":{"e":178,"c":[-21,[116,20,"yellow","blue",161,"orange","blue",30,{"c":181,"a":-30,"b":3}],"orange",-9,"orange",["violet","green",54],"orange",[-20,97,{"c":59,"a":115,"b":-48,"d":-22},28,{"e":59,"c":"green","a":"green","b":"yellow","d":"green","f":-27}],{"a":"violet"},{"e":"blue","c":50,"a":"orange","b":"yellow","d":"orange","f":{"a":"red","b":"green"}}],"a":"orange","b":134,"d":-3,"f":{"e":"violet","a":"orange","d":"green","c":80,"h":"red","b":[140],"g":"red","f":"red"}}},-47,[-28,{"a":[46,["blue",-45,172,193,"blue","green",-2],122,{"a":"green","b":92},-35,[136,[-8,127,20,91,45,"orange"],"green","orange",["orange","yellow",92,162,48,"orange","violet",197],"blue","orange",57,172],"green",135],"b":{"e":[173,{"e":89,"a":96,"d":"orange","c":"orange","h":"green","b":74,"g":"yellow","f":60,"i":135},-11,3,"blue","violet","blue"],"c":160,"a":"blue","b":60,"d":"green","f":"red"}},{"e":[12,"orange"],"c":{"e":45,"c":{"e":-26,"a":86,"d":"yellow","c":["yellow",128,180,135,102,186,"red",194,"green"],"h":"violet","b":{"c":90,"a":-47,"b":56},"g":"blue","f":"red","i":28},"a":71,"b":"violet","d":25},"a":182,"b":"green","d":111,"f":"violet"},{"c":[-21,{"e":[157,13,"red",180,"yellow","green","red",59],"c":-49,"a":82,"b":69,"d":{"e":"orange","a":"yellow","d":98,"j":60,"c":"red","h":199,"b":172,"g":120,"f":"yellow","i":98}},[53,[-23,"orange",135,102,165,170,172,"violet"],"yellow","blue","green",105,97],[74,"violet","orange",["yellow",56,"orange",81,"violet"],"orange",177,75,11],"blue","yellow","blue","red",["blue"]],"a":{"a":-36,"b":"orange"},"b":5,"d":"green"},179,-26,{"a":"green","b":[163,{"a":"orange","b":-35},{"e":180,"a":"blue","d":40,"j":"orange","c":"green","h":"orange","b":"orange","g":131,"f":53,"i":169}]}]],[[{"e":153,"c":"orange","a":"yellow","g":{"e":-4,"c":{"e":115,"c":"red","a":121,"b":151,"d":"red"},"a":"orange","b":194,"d":"orange"},"b":{"a":30},"d":["green",[31,["violet"],["orange",152,"yellow","red"],"yellow"],"violet",{"a":"violet"},171,"violet",{"c":"violet","a":"orange","b":"orange"},"green"],"f":{"e":"yellow","c":["green","red"],"a":"red","g":-17,"b":-3,"d":-42,"f":150}},"orange",{"c":["orange"],"a":"red","b":{"c":-32,"a":{"a":"blue","b":"orange"},"b":{"c":75,"a":{"e":"green","a":101,"d":-3,"j":"violet","c":56,"h":166,"b":192,"g":-5,"f":-22,"i":100},"b":"yellow"},"d":159},"d":{"e":"violet","a":"yellow","d":["green","orange","blue","green"],"j":"yellow","c":[23,"green","blue","yellow","violet","red"],"h":[149,-24,"red",152],"b":-12,"g":"red","f":89,"i":169}},[{"e":{"e":"violet","a":[124,"blue","orange","green",160],"d":113,"c":"red","h":"blue","b":["violet","red","violet",104],"g":85,"f":179,"i":{"e":"orange","a":"violet","d":"violet","j":"yellow","c":191,"h":"red","b":53,"g":-25,"f":"green","i":169}},"a":[147,120],"d":"green","j":["yellow",["yellow",108,"violet",114,"green",195,25,"green"],"green","orange"],"c":["orange",148,141,"yellow",32,-24],"h":124,"b":"orange","g":[121,"blue","red","violet",-18],"f":"violet","i":"red"},["violet","green",94,91,"blue"],{"c":[9,"violet",-18,69,"orange","orange",-24,"yellow","yellow"],"a":"yellow","b":150,"d":73}],110,["blue",-9,"blue","yellow",{"e":[163,45,67],"c":135,"a":50,"b":[43,26,18,120,"green","blue",10,"green",68,-2],"d":{"e":136,"a":15,"d":89,"c":[65,"green",108,122,"yellow","violet","yellow"],"h":"green","b":{"e":125,"a":21,"d":51,"c":153,"h":33,"b":158,"g":"blue","f":26,"i":"green"},"g":-33,"f":[-16,14,"red","red",126,"violet",-16]}},"red",{"e":120,"c":"red","a":{"e":"green","a":"yellow","d":18,"c":150,"h":185,"b":["yellow","red","violet",48,"violet","blue"],"g":"green","f":{"a":"yellow"}},"g":[12,"blue",168,"orange",{"a":"red"},168,"red"],"b":-2,"d":{"e":"violet","c":"yellow","a":86,"g":155,"b":3,"d":-24,"f":149},"f":"yellow"}],[{"c":"green","a":91,"b":"green"},[{"e":"red","c":98,"a":{"c":"red","a":-49,"b":176,"d":105},"b":"red","d":169,"f":"blue"},-46,"green","blue",-30,{"c":154,"a":72,"b":"yellow"},[161,85]],111,"blue",172,57,{"a":-23,"b":"green"},81,[160,["blue","green","green",157],137,["blue",["violet",162],[153,"yellow","orange","violet",127,"green",148,182,29,150],-33,168,"blue"],95]]],["yellow",132,{"c":16,"a":[113],"b":"red","d":{"e":"green","c":24,"a":{"a":"red"},"g":125,"b":["violet",2,101],"d":"green","f":132}},89],[{"e":"yellow","c":[68,"green",[160,146],175,"orange",185,"blue",[198,[179,"yellow","green",72,33,112,179,"violet",194,1]]],"a":["blue","violet",153,"blue",{"a":77,"b":"yellow"},-19,"yellow","green"],"b":"yellow","d":29,"f":{"c":"violet","a":"violet","b":-18}},"yellow",{"e":["violet","green",["red","red","blue",126,137,47,["blue","blue","green",102,"orange","yellow","green"],"red"],[["blue","orange",16,-2],"green","orange","yellow",27,150,0],{"e":62,"c":"yellow","a":"blue","b":94,"d":10,"f":31},[-47,{"e":"green","a":"yellow","d":197,"j":99,"c":"yellow","h":152,"b":"orange","g":85,"f":"green","i":"green"},174,"blue","green"],106],"c":["blue",118,[120,161,-41,["violet"],"violet","yellow"],"red"],"a":["orange","green","red",58,"green",5,178,191,-43],"b":62,"d":"violet"},{"e":97,"a":[["yellow",122,"orange","red",{"e":165,"c":"blue","a":63,"g":"violet","b":"blue","d":"yellow","f":77},[104,118,"green","red","orange",61]],{"c":124,"a":86,"b":"violet"},"yellow",{"e":[98,110,40,104,126,90,140,"blue",46],"a":-42,"d":[77,"green","red",-28,"blue",88,29,-9,-28],"j":-3,"c":"green","h":{"e":153,"c":45,"a":"green","g":127,"b":"red","d":183,"f":"orange"},"b":3,"g":0,"f":["blue","green",62,"red","yellow","green"],"i":"orange"},127,171,[118,[119,"blue"],15,87,"orange",{"e":-34,"c":"violet","a":18,"b":153,"d":37,"f":"red"}],"red"],"d":"red","c":["yellow","red","blue","red","violet","red",-13,179],"h":100,"b":{"e":"orange","a":48,"d":"red","c":{"e":"violet","a":"violet","d":"orange","c":["violet","yellow","blue","yellow"],"h":"red","b":"violet","g":149,"f":"green"},"h":"yellow","b":46,"g":"blue","f":184},"g":16,"f":36,"i":{"e":"green","a":-4,"d":{"c":{"e":"yellow","a":"blue","d":177,"j":"violet","c":"red","h":140,"b":131,"g":137,"f":53,"i":28},"a":16,"b":161},"c":48,"h":[53,7,[137,80,113,160,"blue",105]],"b":"blue","g":"orange","f":"green"}},"yellow",{"c":["orange",{"e":-11,"c":-36,"a":"green","b":"yellow","d":"yellow","f":{"a":186}},-4,170,"green","green",16,123],"a":-29,"b":{"c":"orange","a":"blue","b":"orange"}},{"c":[[161,"violet","blue"],"yellow","yellow",["red",22,["red",92,103,126,-13,67,"blue"],-21,136,"violet",[193]],"blue",-15],"a":{"e":179,"a":1,"d":"yellow","c":[92,15],"h":"orange","b":{"e":-6,"a":"violet","d":"yellow","j":155,"c":198,"h":-18,"b":14,"g":"blue","f":-39,"i":"orange"},"g":{"a":"yellow"},"f":"blue"},"b":87},"yellow",{"c":"blue","a":[{"e":"red","a":"blue","d":"orange","c":"orange","h":-27,"b":"yellow","g":47,"f":{"e":"violet","a":"green","d":185,"j":"orange","c":"violet","h":138,"b":-3,"g":"blue","f":"red","i":150}},{"e":75,"c":168,"a":[12,"blue","green"],"g":{"c":"blue","a":"green","b":107},"b":-36,"d":"orange","f":72},2,[120,"green",182,"yellow",-23,"red"],"green",{"e":"blue","a":"orange","d":"blue","c":157,"h":"green","b":58,"g":"blue","f":-39},"red","orange",32],"b":"violet"},{"e":178,"a":{"c":{"e":59,"a":186,"d":"orange","c":{"a":"violet"},"h":"green","b":198,"g":{"a":"blue","b":"blue"},"f":"orange","i":2},"a":"red","b":[95,130,"blue","violet",98]},"d":176,"c":-38,"h":["yellow",128,"green",39,74,"yellow",5],"b":"blue","g":"violet","f":"orange"}],{"a":{"e":135,"c":{"e":{"e":["orange",-44,81,-11,-1,47,"orange",-36],"c":10,"a":12,"b":"red","d":{"e":"violet","c":"violet","a":161,"b":192,"d":133},"f":77},"c":92,"a":"yellow","g":["blue"],"b":{"e":"violet","a":-48,"d":"orange","c":"blue","h":"orange","b":-40,"g":81,"f":77},"d":102,"f":"yellow"},"a":127,"b":"violet","d":{"e":130,"a":36,"d":148,"c":"yellow","h":117,"b":"orange","g":"orange","f":-19,"i":["green",{"e":"red","a":191,"d":159,"j":"violet","c":"red","h":147,"b":"blue","g":"red","f":"red","i":"green"},"blue",62]},"f":-5},"b":[["green",-36,62,"green","blue",{"c":"violet","a":{"a":-4},"b":"violet","d":88},{"e":"yellow","c":166,"a":["blue"],"g":50,"b":146,"d":"blue","f":142},"yellow"]]},["red","blue",{"e":{"a":-16},"a":[["violet",{"e":"blue","a":171,"d":"blue","c":"blue","h":"green","b":"green","g":"orange","f":"yellow"},186,"orange",195,87,"green",[67,158,"blue",23]],25],"d":[159,74],"c":-28,"h":{"e":-16,"a":"red","d":55,"c":158,"h":167,"b":"red","g":27,"f":{"e":"yellow","c":[34,"blue",-22,"orange"],"a":94,"b":-30,"d":["blue",133,39,102,"orange"]}},"b":119,"g":{"e":104,"c":90,"a":["orange","blue",158,-34,"violet"],"g":"green","b":33,"d":["violet",125,"yellow","yellow",117,["blue",25,"orange"],["red",193,-23,"red","green",146,173],"red","yellow",10],"f":50},"f":47,"i":{"e":[121,144,172,171,{"e":"green","a":9,"d":"violet","c":-33,"h":64,"b":-4,"g":45,"f":75}],"a":8,"d":{"c":68,"a":["yellow","red","green"],"b":"violet","d":9},"c":"blue","h":17,"b":199,"g":115,"f":[["green",108,113,"red",6,"violet","violet","green",57,"green"],"orange",177,"red",34,"blue","red"],"i":-25}},{"e":"blue","a":["orange","yellow",["violet",27,"violet",128,120,{"e":"green","a":"orange","d":"orange","j":"blue","c":"yellow","h":"yellow","b":"yellow","g":139,"f":132,"i":81},"blue","red",53],7,"orange","violet",{"c":"yellow","a":{"a":-11},"b":"orange","d":87},"violet"],"d":[{"a":175},[163,"orange",185],[-30,109,194,119,170,"green","violet","yellow",125,"red"],"blue",{"e":"green","c":152,"a":37,"b":"red","d":["orange"],"f":"orange"},69,"yellow",{"e":{"e":"yellow","c":"violet","a":144,"b":"yellow","d":141,"f":"blue"},"c":"blue","a":"green","g":"yellow","b":178,"d":"yellow","f":-8},"green",["green","orange",-42,"orange"]],"c":"red","h":54,"b":"orange","g":["green",2,146,-6,{"e":52,"a":"orange","d":"red","c":"yellow","h":141,"b":35,"g":{"e":"violet","a":"blue","d":"yellow","c":"blue","h":100,"b":119,"g":"blue","f":"yellow"},"f":136,"i":"yellow"},194,["yellow",139,"green",["blue",14,"green","blue","blue",119,"violet",-5],{"a":61,"b":"orange"},"violet"]],"f":20},{"c":"orange","a":{"e":135,"c":"violet","a":111,"g":{"a":"red","b":96},"b":186,"d":33,"f":127},"b":{"e":83,"a":"yellow","d":"orange","c":"blue","h":"orange","b":0,"g":"orange","f":164,"i":"blue"},"d":-28},-42,{"e":"green","c":{"e":-20,"c":"yellow","a":66,"b":156,"d":"violet"},"a":[-9,129],"g":74,"b":{"e":"violet","c":"green","a":[52,"blue",["green",-8,"green","green"],"red",188,43,"green",{"e":"orange","a":40,"d":-6,"c":"orange","h":93,"b":"green","g":103,"f":"red"}],"g":{"e":"red","c":"yellow","a":16,"b":7,"d":70},"b":{"e":133,"a":150,"d":{"a":34,"b":"green"},"j":166,"c":156,"h":79,"b":"red","g":178,"f":-37,"i":163},"d":"blue","f":"green"},"d":{"c":"blue","a":"violet","b":177,"d":80},"f":[61,88,"yellow",{"c":"blue","a":"orange","b":"violet","d":"yellow"},{"c":119,"a":"violet","b":{"a":"red"},"d":84},95,170]},{"e":191,"c":2,"a":"orange","b":{"a":[-9,"green","violet",["green",132,"red",61,85],3,2]},"d":["green","yellow","violet",-46,48,"green"]}],["violet",["yellow"],["blue",{"e":-15,"c":{"e":["green","violet",0,3,183,165,-1,"orange","blue"],"a":"violet","d":20,"c":"violet","h":"yellow","b":60,"g":"violet","f":163,"i":135},"a":71,"b":{"c":[115,"green",25,"yellow","blue",66],"a":"yellow","b":"green"},"d":"violet","f":{"e":"yellow","c":"blue","a":"blue","b":59,"d":[69,71,"yellow","red",99,"green","yellow",144,43,-38]}},"yellow","blue","orange",55,{"c":[-9,-16,"green",100,28,"red","blue","blue",174],"a":-31,"b":106,"d":"violet"},"blue"],[141,[32,"orange",{"c":-6,"a":-7,"b":64},["blue",{"e":-24,"c":"yellow","a":153,"b":"orange","d":"blue","f":"violet"},"violet",-28,197,"yellow","green","green"],2,{"e":"violet","c":"red","a":"red","b":"yellow","d":"yellow"},["yellow"],"red"],["green",[-16,47],"blue",87,"red","green"],105,"violet",[[127,"violet",81],"red","blue",[193,178,-6],20,"red",61],-2,"blue",-35],{"c":-12,"a":189,"b":"red"},[12,196,["red",27,["violet","green",15,["yellow","green",152,56,187,"yellow",69],"violet"]],127,{"a":"yellow"},-35,[[180,{"c":"yellow","a":191,"b":"violet","d":"red"},41,33,-5],188,"red","violet",23,100,30,91,-15],"blue"],[[129,"blue",{"a":"red"},"violet","green",56,["yellow"],180,[156,"violet"],-49],48,"red",38,{"a":{"e":93,"a":"yellow","d":170,"c":{"e":116,"a":5,"d":89,"j":"blue","c":"blue","h":"red","b":"blue","g":-2,"f":"red","i":-7},"h":148,"b":149,"g":"red","f":-18,"i":-44}},101,183],[25,16,123]],{"e":{"c":"orange","a":{"e":[{"c":"green","a":"orange","b":100,"d":-30}],"a":187,"d":"green","c":{"a":122},"h":-10,"b":118,"g":-12,"f":63},"b":{"e":["violet","yellow","yellow",167,163,5],"a":-28,"d":[-2,61,"red",-18,"red",{"e":"yellow","a":"orange","d":"yellow","j":"green","c":"orange","h":-10,"b":-32,"g":115,"f":141,"i":164},"red",["violet",99,"orange","blue","orange","green","green","violet","yellow"]],"c":-24,"h":"blue","b":"violet","g":47,"f":156},"d":195},"a":{"a":[176]},"d":["violet",[["green",180,"violet","yellow"],{"e":133,"a":"violet","d":{"e":57,"a":"yellow","d":57,"j":"violet","c":"red","h":33,"b":"green","g":"yellow","f":"green","i":79},"j":"orange","c":"violet","h":62,"b":"blue","g":-37,"f":"violet","i":93},-43,"violet",103,"yellow",194,56],{"e":-19,"c":"yellow","a":"orange","b":-19,"d":"red","f":"yellow"}],"c":162,"h":[73,"green",[87,{"a":"green"}],[56,"green",[["green",-2,"green",-47,"yellow",-39,47],"red",129,[90,181,50,"green","green","green","blue",7,"violet"],-3,9,-12,171],"red","orange",159,["violet","yellow",77,86,"yellow","yellow","red",185],145,[81,133]],"yellow",-3,[{"c":["orange",108,82],"a":"violet","b":{"a":"yellow","b":"yellow"},"d":42}],"orange",[-27,["green",{"c":"violet","a":"violet","b":"orange","d":15},78],"red",23],"orange"],"b":{"e":"yellow","a":46,"d":[118,31,142,{"e":-48,"a":"blue","d":"green","c":"violet","h":69,"b":"orange","g":178,"f":"orange","i":"green"},{"e":109,"a":"orange","d":-7,"c":42,"h":168,"b":"blue","g":157,"f":{"a":93,"b":142},"i":38},[59,80],"orange",73,"violet"],"c":122,"h":{"e":153,"c":"yellow","a":11,"b":"orange","d":101},"b":"blue","g":"orange","f":[{"e":48,"c":-39,"a":77,"g":-33,"b":"yellow","d":30,"f":36},153,{"c":"violet","a":78,"b":63,"d":"orange"},117],"i":"red"},"g":"yellow","f":{"a":"orange","b":[{"a":87},"violet","orange",96,154,"orange","violet",{"a":[-45],"b":103}]}},"red"],[{"e":"violet","a":{"e":167,"a":{"e":"orange","c":{"e":"red","c":76,"a":"green","b":"violet","d":146,"f":152},"a":"violet","b":-8,"d":76,"f":"red"},"d":[102,"yellow","blue","blue",22,73],"c":"red","h":{"e":{"c":92,"a":178,"b":{"e":-43,"a":"yellow","d":136,"j":"red","c":193,"h":98,"b":"orange","g":49,"f":"yellow","i":"violet"}},"a":54,"d":138,"j":[0,[177,178],"red",52,[87,"violet",123,"orange","orange","yellow",48,"yellow"],"violet",100,"blue"],"c":3,"h":"green","b":175,"g":{"e":[175,-25,-47,"orange",60,185],"a":["orange",-49,156],"d":"yellow","j":8,"c":-28,"h":129,"b":[89,-12,67,"green",195,"red","violet",150,"red",106],"g":"violet","f":-29,"i":123},"f":"orange","i":71},"b":[172,["yellow","violet","green","blue",194],-46,{"a":102,"b":"green"}],"g":[{"e":{"c":23,"a":"yellow","b":-25},"a":"blue","d":"green","j":185,"c":"yellow","h":["orange","violet",-21],"b":{"c":191,"a":197,"b":"yellow"},"g":115,"f":-41,"i":"blue"},-17,[-23,64,"red",8,"orange",[105,-11,29,-23,30,65,15],170],"yellow","yellow",-46,"green","orange",143],"f":177},"d":"red","c":"red","h":135,"b":{"e":"red","a":"orange","d":["violet",[23,"red","violet","orange",66,{"c":"orange","a":"green","b":169,"d":57},"blue",125,"green"],110,135,[-40,"violet","yellow",-26,-23,44],"orange",28],"c":"orange","h":107,"b":91,"g":105,"f":{"e":{"e":164,"c":180,"a":"blue","b":"yellow","d":144},"c":"violet","a":"violet","g":95,"b":"red","d":"violet","f":"green"},"i":156},"g":["violet",108,["blue","yellow","red",[23,"yellow",3,159,112],{"e":-41,"c":"green","a":22,"b":"violet","d":"blue","f":"blue"},"violet",-27,"green","violet",-17],"green",{"e":{"e":[-19,96,-28,"orange"],"c":"yellow","a":"yellow","g":124,"b":97,"d":{"a":"blue"},"f":"green"},"a":46,"d":["blue",118,"yellow","yellow","yellow","green",["yellow",-10,90,167,"red",54,-15]],"j":106,"c":"red","h":[{"e":"red","c":28,"a":"yellow","b":170,"d":"blue","f":105},-40,"orange",188,"yellow",142],"b":117,"g":"violet","f":{"a":[-5,"red",46,182,"red","orange"]},"i":"yellow"},["orange",88,18,{"e":"blue","a":"violet","d":"blue","c":"violet","h":"violet","b":196,"g":103,"f":67,"i":13}],"blue","blue"],"f":-19,"i":{"a":166}},164],[{"e":{"e":"blue","a":13,"d":{"e":{"e":"orange","a":88,"d":"red","c":"yellow","h":[93,79],"b":"orange","g":109,"f":34,"i":-13},"a":-44,"d":"red","j":[173,78,"red",{"e":"yellow","a":-32,"d":"blue","j":"violet","c":"blue","h":119,"b":"green","g":-30,"f":193,"i":95},"orange",-43,-16],"c":["green",{"e":41,"c":"red","a":109,"b":159,"d":59},173,18,"violet",21,"red"],"h":"blue","b":44,"g":{"a":129,"b":-10},"f":-26,"i":27},"j":"red","c":{"a":{"c":-28,"a":"green","b":188,"d":"blue"},"b":"blue"},"h":[183,[118,[-7,"orange"],132,[23,175,"yellow","green",11,178,171,"orange","blue",18],134,1,"green",[-9,99],103,-25],"red",[65,"red","blue"],"violet","blue"],"b":"yellow","g":164,"f":-9,"i":{"c":51,"a":"green","b":115,"d":{"a":27,"b":"red"}}},"a":[{"e":[143,"violet",128,"red","yellow",185,"green","red","red"],"a":29,"d":"red","c":170,"h":[131,"violet",96,{"a":"yellow","b":"green"},139,22,176,"yellow",[-46,-14,"red","blue",83,141],[132,108,"blue","blue","green",197,"yellow"]],"b":"blue","g":"orange","f":"yellow","i":[-9]},"violet",56,[169,12,155,["red",197,{"e":"violet","a":22,"d":"violet","c":84,"h":"red","b":70,"g":"violet","f":-41},47,"violet"],[["green","green",179,56,"green","violet",171,"violet","violet"],"blue","red","green",-17,"green",190],"green","red",146,60],"yellow","red","yellow","violet"],"d":[[141,40,"yellow",1,"blue","green","yellow",{"e":13,"a":"blue","d":"red","c":"red","h":176,"b":"violet","g":164,"f":4,"i":"violet"}]],"c":72,"h":15,"b":"yellow","g":{"e":[-12,"blue",["red","blue",11],29,{"e":59,"c":"red","a":{"e":55,"a":"blue","d":"orange","c":"yellow","h":"violet","b":-19,"g":"green","f":"violet","i":197},"b":"orange","d":"violet","f":90},[-14,154,"violet","orange",74,{"e":"yellow","a":"violet","d":66,"c":"yellow","h":80,"b":"yellow","g":"yellow","f":"orange","i":"blue"},"green","red",116,149],"green",108],"c":{"c":28,"a":"blue","b":"yellow","d":"blue"},"a":36,"b":["orange","green","orange","green","red",46,55,"blue",["violet",98,[163,-35,163,-28],"blue","red",155,"blue"],-8],"d":163},"f":[9,"green",{"c":"green","a":"violet","b":68,"d":"yellow"},114,33,1,-25]},["red",[-20,{"c":"yellow","a":"red","b":"green","d":{"a":"red"}},"red",[[141,76],[174],100,{"e":126,"c":39,"a":["violet",94,"orange",102,"blue"],"b":55,"d":"yellow","f":"yellow"},146,{"c":169,"a":"red","b":"red"},[["green",-48,"violet","orange"],[80,-7,-22,"yellow","orange","yellow",185,"orange"],"green","violet","orange"],"red"],"yellow"],[{"a":["orange","blue"],"b":[{"a":-42,"b":"violet"},"green",99,-20,"blue"]},{"c":"blue","a":"violet","b":14,"d":9},"green",{"c":["blue",148,[38,139,125,52,"red",40,190,"yellow",21,"violet"],"violet",110,"green"],"a":{"c":97,"a":[35,"orange",44,"red",87,"orange","blue",61,"yellow"],"b":176,"d":144},"b":137},85,[192,-37,"orange",{"c":"yellow","a":-10,"b":[71]},"yellow",176,["green",14],{"a":102},-39],"violet",164],-9,"blue",[["blue"],70]]]]
#+END_SRC
** test data
#+BEGIN_SRC text :tangle d12t.txt :padline no
[1,{"c":"red","b":2},3]
#+END_SRC
** puzzle 1
#+BEGIN_SRC cpp :results output :tangle d11p1.c
    #include <stdio.h>
    #include <stdlib.h>
    #include <ctype.h>

    int main() {
      FILE *f = fopen("d12.txt", "r");

      char buf[1024] = { '\0' };
      char num_buf[1024] = { '\0' };
      int buf_len = 0;
      int num_len = 0;
      int sum = 0;
      while ((buf_len = fread(buf, 1, sizeof(buf), f)) > 0) {
        for (int i = 0; i < buf_len; i++) {
          if (isdigit(buf[i]) || buf[i] == '-' && num_len == 0) {
            num_buf[num_len++] = buf[i];
          } else if (num_len > 0 && !(num_len == 1 && num_buf[0] == '-')) {
            num_buf[num_len] = '\0';
            sum += atoi(num_buf);
            num_len = 0;
          }
        }
      }
      if (num_len > 0) {
        num_buf[num_len] = '\0';
        sum += atoi(num_buf);
      }
      
      printf("%d", sum);
      return 0;
    }
#+END_SRC

#+RESULTS:
: 191164

- 214938 too high
** puzzle 2
#+BEGIN_SRC cpp :results output
  #include <stdio.h>
  #include <stdlib.h>
  #include <ctype.h>
  #include <string.h>

  typedef struct t_is {
    int idx;
    char ignore;
    int sum;
    struct t_is *next;
  } t_is;

  t_is* new_is(int idx) {
    t_is *is = (t_is*) malloc(sizeof(t_is));
    is->idx = idx;
    is->ignore = 0;
    is->sum = 0;
    is->next = NULL;
    return is;
  }

  int main() {
    FILE *f = fopen("d12.txt", "r");

    char buf[1000000] = { '\0' };
    int buflen = fread(buf, 1, sizeof(buf), f);
    if (buflen == sizeof(buf)) {
      printf("buffer too short\n");
      return 0;
    }

    t_is *stack = new_is(0);

    char num_buf[1024] = { '\0' };
    int num_len = 0;
    char prop_value[2014] = { '\0' };
    int prop_value_i = -1;

    for (int i = 0; i < buflen; i++) {

      if (isdigit(buf[i]) || buf[i] == '-' && num_len == 0) {
        num_buf[num_len++] = buf[i];
      } else if (num_len > 0 && !(num_len == 1 && num_buf[0] == '-')) {
        num_buf[num_len] = '\0';
        stack->sum += atoi(num_buf);
        num_len = 0;
      }

      if (buf[i] == '{') {
        t_is *is = new_is(i);
        is->ignore = stack->ignore;
        is->next = stack;
        stack = is;
      } else if (buf[i] == '}') {
        t_is *pop = stack;
        stack = pop->next;
        if (!pop->ignore) {
          stack->sum += pop->sum;
        }

        char tmp = buf[i+1];
        buf[i+1] = '\0';
        // printf("## ignore=%d, sum=%d, object=%s\n", pop->ignore, pop->sum, buf + pop->idx);
        buf[i+1] = tmp;
        free(pop);
      } else if (i >= 2 && buf[i - 2] == '"' && buf[i - 1] == ':' && buf[i] == '"') {
        prop_value_i = 0;
      } else if (prop_value_i >= 0) {
        if (buf[i] == '"') {
          prop_value[prop_value_i] = '\0';
          if (0 == strcmp("red", prop_value)) {
            stack->ignore = 1;
          }
          prop_value_i = -1;
        } else {
          prop_value[prop_value_i++] = buf[i];
        }
      }
    }


    printf("%d", stack->sum);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 87842

* day 13
** text
--- Day 13: Knights of the Dinner Table ---

In years past, the holiday feast with your family hasn't gone so well. Not everyone gets along! This year, you resolve, will be different. You're going to find the optimal seating arrangement and avoid all those awkward conversations.

You start by writing up a list of everyone invited and the amount their happiness would increase or decrease if they were to find themselves sitting next to each other person. You have a circular table that will be just big enough to fit everyone comfortably, and so each person will have exactly two neighbors.

For example, suppose you have only four attendees planned, and you calculate their potential happiness as follows:

Alice would gain 54 happiness units by sitting next to Bob.
Alice would lose 79 happiness units by sitting next to Carol.
Alice would lose 2 happiness units by sitting next to David.
Bob would gain 83 happiness units by sitting next to Alice.
Bob would lose 7 happiness units by sitting next to Carol.
Bob would lose 63 happiness units by sitting next to David.
Carol would lose 62 happiness units by sitting next to Alice.
Carol would gain 60 happiness units by sitting next to Bob.
Carol would gain 55 happiness units by sitting next to David.
David would gain 46 happiness units by sitting next to Alice.
David would lose 7 happiness units by sitting next to Bob.
David would gain 41 happiness units by sitting next to Carol.

Then, if you seat Alice next to David, Alice would lose 2 happiness units (because David talks so much), but David would gain 46 happiness units (because Alice is such a good listener), for a total change of 44.

If you continue around the table, you could then seat Bob next to Alice (Bob gains 83, Alice gains 54). Finally, seat Carol, who sits next to Bob (Carol gains 60, Bob loses 7) and David (Carol gains 55, David gains 41). The arrangement looks like this:

     +41 +46
+55   David    -2
Carol       Alice
+60    Bob    +54
     -7  +83

After trying every other seating arrangement in this hypothetical scenario, you find that this one is the most optimal, with a total change in happiness of 330.

What is the total change in happiness for the optimal seating arrangement of the actual guest list?

Your puzzle answer was 733.
--- Part Two ---

In all the commotion, you realize that you forgot to seat yourself. At this point, you're pretty apathetic toward the whole thing, and your happiness wouldn't really go up or down regardless of who you sit next to. You assume everyone else would be just as ambivalent about sitting next to you, too.

So, add yourself to the list, and give all happiness relationships that involve you a score of 0.

What is the total change in happiness for the optimal seating arrangement that actually includes yourself?

Your puzzle answer was 725.
** data
#+BEGIN_SRC text :tangle d13.txt :padline no
Alice would gain 2 happiness units by sitting next to Bob.
Alice would gain 26 happiness units by sitting next to Carol.
Alice would lose 82 happiness units by sitting next to David.
Alice would lose 75 happiness units by sitting next to Eric.
Alice would gain 42 happiness units by sitting next to Frank.
Alice would gain 38 happiness units by sitting next to George.
Alice would gain 39 happiness units by sitting next to Mallory.
Bob would gain 40 happiness units by sitting next to Alice.
Bob would lose 61 happiness units by sitting next to Carol.
Bob would lose 15 happiness units by sitting next to David.
Bob would gain 63 happiness units by sitting next to Eric.
Bob would gain 41 happiness units by sitting next to Frank.
Bob would gain 30 happiness units by sitting next to George.
Bob would gain 87 happiness units by sitting next to Mallory.
Carol would lose 35 happiness units by sitting next to Alice.
Carol would lose 99 happiness units by sitting next to Bob.
Carol would lose 51 happiness units by sitting next to David.
Carol would gain 95 happiness units by sitting next to Eric.
Carol would gain 90 happiness units by sitting next to Frank.
Carol would lose 16 happiness units by sitting next to George.
Carol would gain 94 happiness units by sitting next to Mallory.
David would gain 36 happiness units by sitting next to Alice.
David would lose 18 happiness units by sitting next to Bob.
David would lose 65 happiness units by sitting next to Carol.
David would lose 18 happiness units by sitting next to Eric.
David would lose 22 happiness units by sitting next to Frank.
David would gain 2 happiness units by sitting next to George.
David would gain 42 happiness units by sitting next to Mallory.
Eric would lose 65 happiness units by sitting next to Alice.
Eric would gain 24 happiness units by sitting next to Bob.
Eric would gain 100 happiness units by sitting next to Carol.
Eric would gain 51 happiness units by sitting next to David.
Eric would gain 21 happiness units by sitting next to Frank.
Eric would gain 55 happiness units by sitting next to George.
Eric would lose 44 happiness units by sitting next to Mallory.
Frank would lose 48 happiness units by sitting next to Alice.
Frank would gain 91 happiness units by sitting next to Bob.
Frank would gain 8 happiness units by sitting next to Carol.
Frank would lose 66 happiness units by sitting next to David.
Frank would gain 97 happiness units by sitting next to Eric.
Frank would lose 9 happiness units by sitting next to George.
Frank would lose 92 happiness units by sitting next to Mallory.
George would lose 44 happiness units by sitting next to Alice.
George would lose 25 happiness units by sitting next to Bob.
George would gain 17 happiness units by sitting next to Carol.
George would gain 92 happiness units by sitting next to David.
George would lose 92 happiness units by sitting next to Eric.
George would gain 18 happiness units by sitting next to Frank.
George would gain 97 happiness units by sitting next to Mallory.
Mallory would gain 92 happiness units by sitting next to Alice.
Mallory would lose 96 happiness units by sitting next to Bob.
Mallory would lose 51 happiness units by sitting next to Carol.
Mallory would lose 81 happiness units by sitting next to David.
Mallory would gain 31 happiness units by sitting next to Eric.
Mallory would lose 73 happiness units by sitting next to Frank.
Mallory would lose 89 happiness units by sitting next to George.
#+END_SRC
** test data
#+BEGIN_SRC text :tangle d13t.txt :padline no
Alice would gain 54 happiness units by sitting next to Bob.
Alice would lose 79 happiness units by sitting next to Carol.
Alice would lose 2 happiness units by sitting next to David.
Bob would gain 83 happiness units by sitting next to Alice.
Bob would lose 7 happiness units by sitting next to Carol.
Bob would lose 63 happiness units by sitting next to David.
Carol would lose 62 happiness units by sitting next to Alice.
Carol would gain 60 happiness units by sitting next to Bob.
Carol would gain 55 happiness units by sitting next to David.
David would gain 46 happiness units by sitting next to Alice.
David would lose 7 happiness units by sitting next to Bob.
David would gain 41 happiness units by sitting next to Carol.
#+END_SRC
** puzzle 1
#+BEGIN_SRC cpp :results output :tangle d13p1.c
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #define LEN 124

  int name(char *names[LEN], char *name) {
    int i;
    for (i = 0; names[i] != NULL; i++) {
      if (strcmp(name, names[i]) == 0)
        return i;
    }
    names[i] = strdup(name);
    return i;
  }

  int max_happy(int happy[LEN][LEN], int n, int* ids, int len) {
    if (n == 1) {
      int hap = 0;
      for (int i = 0; i < len; i++) {
        hap += happy[ids[i]][ids[(i - 1 + len) % len]];
        hap += happy[ids[i]][ids[(i + 1) % len]];
        // printf("%d: %d  %d\n", ids[i], happy[ids[i]][ids[(i - 1 + len) % len]],
        //        happy[ids[i]][ids[(i + 1) % len]]);
      }
      // printf("= %d\n", hap);
      return hap;
    } else {
      int max = 0;
      for (int i = 0; i < n - 1; i++) {
        int hap = max_happy(happy, n - 1, ids, len);
        if (hap > max) 
          max = hap;
        if (n % 2 == 0) {
          int tmp = ids[i];
          ids[i] = ids[n - 1];
          ids[n - 1] = tmp;
        } else {
          int tmp = ids[0];
          ids[0] = ids[n - 1];
          ids[n - 1] = tmp;
        }
      }
      int hap = max_happy(happy, n - 1, ids, len);
      if (hap > max) 
        max = hap;
      return max;
    }
  }

  int main() {
    FILE *f = fopen("d13.txt", "r");

    char *names[LEN] = { NULL };
    int happy[LEN][LEN] = { 0 };
    char line[1024] = { '\0' };

    int maxid = 0;

    while (fgets(line, LEN, f) != NULL) {
      char name1[LEN], name2[LEN];
      int happi;
      if (sscanf(line, "%s would gain %d happiness units by sitting next to %s.",
                 name1, &happi, name2) == 3) {
        // empty
      } else if (sscanf(line, "%s would lose %d happiness units by sitting next to %s.",
                 name1, &happi, name2) == 3) {
        happi = -1 * happi;         
      } else {
        printf("Could not parse line: %s\n", line);
        return 0;
      }
      name2[strlen(name2) - 1] = '\0';
      int id1 = name(names, name1);
      int id2 = name(names, name2);
      happy[id1][id2] = happi;
      if (id1 > maxid)
        maxid = id1;
      if (id2 > maxid)
        maxid = id2;
    }

    // for (int i = 0; i <= maxid; i++) {
    //   printf("### %d: %s\n", i, names[i]);
    // }
    // for (int i = 0; i <= maxid; i++) {
    //   for (int j = 0; j <= maxid; j++) {
    //     printf("## %s -> %s = %d\n", names[i], names[j], happy[i][j]);
    //   }
    // }

    int ids[maxid + 1];
    for (int i = 0; i <= maxid; i++) {
      ids[i] = i;
    }

    int max = max_happy(happy, maxid + 1, ids, maxid + 1);
    printf("%d", max);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 733

 - too low 65

** puzzle 2
#+BEGIN_SRC cpp :results output :tangle d13p2.c
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #define LEN 124

  int name(char *names[LEN], char *name) {
    int i;
    for (i = 0; names[i] != NULL; i++) {
      if (strcmp(name, names[i]) == 0)
        return i;
    }
    names[i] = strdup(name);
    return i;
  }

  int max_happy(int happy[LEN][LEN], int n, int* ids, int len) {
    if (n == 1) {
      int hap = 0;
      for (int i = 0; i < len; i++) {
        hap += happy[ids[i]][ids[(i - 1 + len) % len]];
        hap += happy[ids[i]][ids[(i + 1) % len]];
        // printf("%d: %d  %d\n", ids[i], happy[ids[i]][ids[(i - 1 + len) % len]],
        //        happy[ids[i]][ids[(i + 1) % len]]);
      }
      // printf("= %d\n", hap);
      return hap;
    } else {
      int max = 0;
      for (int i = 0; i < n - 1; i++) {
        int hap = max_happy(happy, n - 1, ids, len);
        if (hap > max) 
          max = hap;
        if (n % 2 == 0) {
          int tmp = ids[i];
          ids[i] = ids[n - 1];
          ids[n - 1] = tmp;
        } else {
          int tmp = ids[0];
          ids[0] = ids[n - 1];
          ids[n - 1] = tmp;
        }
      }
      int hap = max_happy(happy, n - 1, ids, len);
      if (hap > max) 
        max = hap;
      return max;
    }
  }

  int main() {
    FILE *f = fopen("d13.txt", "r");

    char *names[LEN] = { NULL };
    int happy[LEN][LEN] = { 0 };
    char line[1024] = { '\0' };

    int maxid = 0;

    while (fgets(line, LEN, f) != NULL) {
      char name1[LEN], name2[LEN];
      int happi;
      if (sscanf(line, "%s would gain %d happiness units by sitting next to %s.",
                 name1, &happi, name2) == 3) {
        // empty
      } else if (sscanf(line, "%s would lose %d happiness units by sitting next to %s.",
                 name1, &happi, name2) == 3) {
        happi = -1 * happi;         
      } else {
        printf("Could not parse line: %s\n", line);
        return 0;
      }
      name2[strlen(name2) - 1] = '\0';
      int id1 = name(names, name1);
      int id2 = name(names, name2);
      happy[id1][id2] = happi;
      if (id1 > maxid)
        maxid = id1;
      if (id2 > maxid)
        maxid = id2;
    }

    maxid = name(names, "myself");

    // for (int i = 0; i <= maxid; i++) {
    //   printf("### %d: %s\n", i, names[i]);
    // }
    // for (int i = 0; i <= maxid; i++) {
    //   for (int j = 0; j <= maxid; j++) {
    //     printf("## %s -> %s = %d\n", names[i], names[j], happy[i][j]);
    //   }
    // }

    int ids[maxid + 1];
    for (int i = 0; i <= maxid; i++) {
      ids[i] = i;
    }

    int max = max_happy(happy, maxid + 1, ids, maxid + 1);
    printf("%d", max);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 725

 - too low 65

* day 14
** text
--- Day 14: Reindeer Olympics ---

This year is the Reindeer Olympics! Reindeer can fly at high speeds, but must rest occasionally to recover their energy. Santa would like to know which of his reindeer is fastest, and so he has them race.

Reindeer can only either be flying (always at their top speed) or resting (not moving at all), and always spend whole seconds in either state.

For example, suppose you have the following Reindeer:

    Comet can fly 14 km/s for 10 seconds, but then must rest for 127 seconds.
    Dancer can fly 16 km/s for 11 seconds, but then must rest for 162 seconds.

After one second, Comet has gone 14 km, while Dancer has gone 16 km. After ten seconds, Comet has gone 140 km, while Dancer has gone 160 km. On the eleventh second, Comet begins resting (staying at 140 km), and Dancer continues on for a total distance of 176 km. On the 12th second, both reindeer are resting. They continue to rest until the 138th second, when Comet flies for another ten seconds. On the 174th second, Dancer flies for another 11 seconds.

In this example, after the 1000th second, both reindeer are resting, and Comet is in the lead at 1120 km (poor Dancer has only gotten 1056 km by that point). So, in this situation, Comet would win (if the race ended at 1000 seconds).

Given the descriptions of each reindeer (in your puzzle input), after exactly 2503 seconds, what distance has the winning reindeer traveled?

Your puzzle answer was 2640.
--- Part Two ---

Seeing how reindeer move in bursts, Santa decides he's not pleased with the old scoring system.

Instead, at the end of each second, he awards one point to the reindeer currently in the lead. (If there are multiple reindeer tied for the lead, they each get one point.) He keeps the traditional 2503 second time limit, of course, as doing otherwise would be entirely ridiculous.

Given the example reindeer from above, after the first second, Dancer is in the lead and gets one point. He stays in the lead until several seconds into Comet's second burst: after the 140th second, Comet pulls into the lead and gets his first point. Of course, since Dancer had been in the lead for the 139 seconds before that, he has accumulated 139 points by the 140th second.

After the 1000th second, Dancer has accumulated 689 points, while poor Comet, our old champion, only has 312. So, with the new scoring system, Dancer would win (if the race ended at 1000 seconds).

Again given the descriptions of each reindeer (in your puzzle input), after exactly 2503 seconds, how many points does the winning reindeer have?

Your puzzle answer was 1102.
** data
#+BEGIN_SRC text :tangle d14.txt :padline no
Dancer can fly 27 km/s for 5 seconds, but then must rest for 132 seconds.
Cupid can fly 22 km/s for 2 seconds, but then must rest for 41 seconds.
Rudolph can fly 11 km/s for 5 seconds, but then must rest for 48 seconds.
Donner can fly 28 km/s for 5 seconds, but then must rest for 134 seconds.
Dasher can fly 4 km/s for 16 seconds, but then must rest for 55 seconds.
Blitzen can fly 14 km/s for 3 seconds, but then must rest for 38 seconds.
Prancer can fly 3 km/s for 21 seconds, but then must rest for 40 seconds.
Comet can fly 18 km/s for 6 seconds, but then must rest for 103 seconds.
Vixen can fly 18 km/s for 5 seconds, but then must rest for 84 seconds.
#+END_SRC
** puzzle 1
#+BEGIN_SRC cpp :results output :tangle d14p1.c
  #include <stdio.h>
  #include <string.h>

  int main() {
    FILE *f = fopen("d14.txt", "r");

    int race = 2503;

    char line[1024] = { '\0' };

    int max_dist = 0;
    while (fgets(line, 127, f) != NULL) {
      char name[127];
      int speed;
      int duration;
      int rest;
      sscanf(line, "%s can fly %d km/s for %d seconds, but then must rest for %d seconds.",
             name, &speed, &duration, &rest);

      int cycles = race / (duration + rest);
      int dist = cycles * speed * duration;
      int i = cycles * (duration + rest);
      if (i + duration > race) {
        dist += speed * (race - i);
      } else {
        dist += speed * duration;
      }
      // printf("## %s (%d) (cyc=%d, speed=%d, dur=%d, rest=%d)\n", 
      //        name, dist, cycles, speed, duration, rest);
      if (dist > max_dist) {
        max_dist = dist;
      }
    }

    printf("%d", max_dist);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 2640

 - too high 70084
 - too high 4266

## Comet (4266) (cyc=22, speed=18, dur=6, rest=103)
22 * 18 * 6 = 2376
22 * (6 + 103) = 2398 (/ 2503)
2398 

** puzzle 2
#+BEGIN_SRC cpp :results output :tangle d14p2.c
  #include <stdio.h>
  #include <string.h>

  int dist(int race, int speed, int duration, int rest) {
    int cycles = race / (duration + rest);
    int dist = cycles * speed * duration;
    int i = cycles * (duration + rest);
    if (i + duration > race) {
      dist += speed * (race - i);
    } else {
      dist += speed * duration;
    }
    return dist;
  }

  int main() {
    FILE *f = fopen("d14.txt", "r");

    int race = 2503;

    char line[1024] = { '\0' };

    int len = 0;
    int speeds[64], durations[64], rests[64];
    while (fgets(line, 127, f) != NULL) {
      char name[127];
      int speed;
      int duration;
      int rest;
      sscanf(line, "%s can fly %d km/s for %d seconds, but then must rest for %d seconds.",
             name, &speed, &duration, &rest);

      speeds[len] = speed;
      durations[len] = duration;
      rests[len] = rest;
      len++;
    }

    int dists[64];
    int points[64] = { 0 };
    for (int i = 1; i <= race; i++) {
      int max_dist = 0;
      for (int r = 0; r < len; r++) {
        dists[r] = dist(i, speeds[r], durations[r], rests[r]);
        if (dists[r] > max_dist)
          max_dist = dists[r];
      }

      for (int r = 0; r < len; r++) {
        if (dists[r] == max_dist) {
          points[r]++;
        }
      }
    }
    
    int max_points = 0;
    for (int r = 0; r < len; r++) {
      if (points[r] > max_points)
        max_points = points[r];
    }


    printf("%d", max_points);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 1102

* day 15
** text
--- Day 15: Science for Hungry People ---

Today, you set out on the task of perfecting your milk-dunking cookie recipe. All you have to do is find the right balance of ingredients.

Your recipe leaves room for exactly 100 teaspoons of ingredients. You make a list of the remaining ingredients you could use to finish the recipe (your puzzle input) and their properties per teaspoon:

    capacity (how well it helps the cookie absorb milk)
    durability (how well it keeps the cookie intact when full of milk)
    flavor (how tasty it makes the cookie)
    texture (how it improves the feel of the cookie)
    calories (how many calories it adds to the cookie)

You can only measure ingredients in whole-teaspoon amounts accurately, and you have to be accurate so you can reproduce your results in the future. The total score of a cookie can be found by adding up each of the properties (negative totals become 0) and then multiplying together everything except calories.

For instance, suppose you have these two ingredients:

Butterscotch: capacity -1, durability -2, flavor 6, texture 3, calories 8
Cinnamon: capacity 2, durability 3, flavor -2, texture -1, calories 3

Then, choosing to use 44 teaspoons of butterscotch and 56 teaspoons of cinnamon (because the amounts of each ingredient must add up to 100) would result in a cookie with the following properties:

    A capacity of 44*-1 + 56*2 = 68
    A durability of 44*-2 + 56*3 = 80
    A flavor of 44*6 + 56*-2 = 152
    A texture of 44*3 + 56*-1 = 76

Multiplying these together (68 * 80 * 152 * 76, ignoring calories for now) results in a total score of 62842880, which happens to be the best score possible given these ingredients. If any properties had produced a negative total, it would have instead become zero, causing the whole score to multiply to zero.

Given the ingredients in your kitchen and their properties, what is the total score of the highest-scoring cookie you can make?

Your puzzle answer was 21367368.
--- Part Two ---

Your cookie recipe becomes wildly popular! Someone asks if you can make another recipe that has exactly 500 calories per cookie (so they can use it as a meal replacement). Keep the rest of your award-winning process the same (100 teaspoons, same ingredients, same scoring system).

For example, given the ingredients above, if you had instead selected 40 teaspoons of butterscotch and 60 teaspoons of cinnamon (which still adds to 100), the total calorie count would be 40*8 + 60*3 = 500. The total score would go down, though: only 57600000, the best you can do in such trying circumstances.

Given the ingredients in your kitchen and their properties, what is the total score of the highest-scoring cookie you can make with a calorie total of 500?

Your puzzle answer was 1766400.
** data
#+BEGIN_SRC text :tangle d15.txt :padline no
Sprinkles: capacity 2, durability 0, flavor -2, texture 0, calories 3
Butterscotch: capacity 0, durability 5, flavor -3, texture 0, calories 3
Chocolate: capacity 0, durability 0, flavor 5, texture -1, calories 8
Candy: capacity 0, durability -1, flavor 0, texture 5, calories 8
#+END_SRC
** puzzle 1
#+BEGIN_SRC cpp :results output :tangle d15p1.c
  #include <stdio.h>
  #include <string.h>

  int main() {
    FILE *f = fopen("d15.txt", "r");
    char line[1024] = { '\0' };

    int cs[64], ds[64], fs[64], ts[64];
    int len = 0;

    while (fgets(line, 127, f) != NULL) {
      char name[64];
      int capacity, durability, flavor, texture;
      sscanf(line, "%s capacity %d, durability %d, flavor %d, texture %d",
             name, &capacity, &durability, &flavor, &texture);

      cs[len] = capacity;
      ds[len] = durability;
      fs[len] = flavor;
      ts[len] = texture;
      len++;
      // printf("## %s: c=%d, d=%d, f=%d, t=%d\n", name, capacity, durability, flavor, texture);
    }

    int max_score = 0;
    for (int a = 0; a <= 100; a++) {
      for (int b = 0; b <= 100 - a; b++) {
        for (int c = 0; c <= 100 - a - b; c++) {
          for (int d = 0; d <= 100 - a - b - c; d++) {
            if (a + b + c + d != 100)
              continue;
            int cap = a * cs[0] + b * cs[1] + c * cs[2] + d * cs[3];
            int cur = a * ds[0] + b * ds[1] + c * ds[2] + d * ds[3];
            int fla = a * fs[0] + b * fs[1] + c * fs[2] + d * fs[3];
            int tex = a * ts[0] + b * ts[1] + c * ts[2] + d * ts[3];
            if (cap < 0) cap = 0;
            if (cur < 0) cur = 0;
            if (fla < 0) fla = 0;
            if (tex < 0) tex = 0;
            int score = cap * cur * fla * tex;
            if (score > max_score) {
              max_score = score;
            }
          }
        }
      }
    }

    printf("%d", max_score);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 21367368

** puzzle 1B
#+BEGIN_SRC cpp :results output :tangle d15p1.c
  #include <stdio.h>
  #include <string.h>

  int best(int i, int len, int *is, int ingredients[4][64]) {
    int left = 100;
    for (int j = 0; j < i; j++) {
      left -= is[j];
    }

    if (i == len - 1) {
      is[len - 1] = left;
      int type[4] = { 0 };
      for (int j = 0; j < len; j++) {
        for (int k = 0; k < 4; k++) {
          type[k] += is[j] * ingredients[k][j];
        }
      }

      for (int k = 0; k < 4; k++)
        if (type[k] < 0) type[k] = 0;

      int score = 1;
      for (int k = 0; k < 4; k++)
        score *= type[k];

      return score;
    } else {
      int max_score = 0;
      for (int k = 0 ; k < left; k++) {
        is[i] = k;
        int score = best(i + 1, len, is, ingredients);
        if (score > max_score)
          max_score = score;
      }
      return max_score;
    }
  }

  int main() {
    FILE *f = fopen("d15.txt", "r");
    char line[1024] = { '\0' };

    int ingredients[4][64];
    int len = 0;

    while (fgets(line, 127, f) != NULL) {
      char name[64];
      int capacity, durability, flavor, texture;
      sscanf(line, "%s capacity %d, durability %d, flavor %d, texture %d",
             name, &capacity, &durability, &flavor, &texture);

      ingredients[0][len] = capacity;
      ingredients[1][len] = durability;
      ingredients[2][len] = flavor;
      ingredients[3][len] = texture;
      len++;
      // printf("## %s: c=%d, d=%d, f=%d, t=%d\n", name, capacity, durability, flavor, texture);
    }

    int is[len];
    printf("%d", best(0, len, is, ingredients));
    return 0;
  }
#+END_SRC

#+RESULTS:
: 21367368

** puzzle 2
#+BEGIN_SRC cpp :results output :tangle d15p1.c
  #include <stdio.h>
  #include <string.h>

  int main() {
    FILE *f = fopen("d15.txt", "r");
    char line[1024] = { '\0' };

    int cs[64], ds[64], fs[64], ts[64], cals[64];
    int len = 0;

    while (fgets(line, 127, f) != NULL) {
      char name[64];
      int capacity, durability, flavor, texture, calories;
      sscanf(line, "%s capacity %d, durability %d, flavor %d, texture %d, calories %d",
             name, &capacity, &durability, &flavor, &texture, &calories);

      cs[len] = capacity;
      ds[len] = durability;
      fs[len] = flavor;
      ts[len] = texture;
      cals[len] = calories;
      len++;
      // printf("## %s: c=%d, d=%d, f=%d, t=%d\n", name, capacity, durability, flavor, texture);
    }

    int max_score = 0;
    for (int a = 0; a <= 100; a++) {
      for (int b = 0; b <= 100 - a; b++) {
        for (int c = 0; c <= 100 - a - b; c++) {
          for (int d = 0; d <= 100 - a - b - c; d++) {
            if (a + b + c + d != 100)
              continue;
            int cal = a * cals[0] + b * cals[1] + c * cals[2] + d * cals[3];
            if (cal != 500)
              continue;
            int cap = a * cs[0] + b * cs[1] + c * cs[2] + d * cs[3];
            int cur = a * ds[0] + b * ds[1] + c * ds[2] + d * ds[3];
            int fla = a * fs[0] + b * fs[1] + c * fs[2] + d * fs[3];
            int tex = a * ts[0] + b * ts[1] + c * ts[2] + d * ts[3];
            if (cap < 0) cap = 0;
            if (cur < 0) cur = 0;
            if (fla < 0) fla = 0;
            if (tex < 0) tex = 0;
            int score = cap * cur * fla * tex;
            if (score > max_score) {
              max_score = score;
            }
          }
        }
      }
    }

    printf("%d", max_score);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 1766400

* day 16
** text
--- Day 16: Aunt Sue ---

Your Aunt Sue has given you a wonderful gift, and you'd like to send her a thank you card. However, there's a small problem: she signed it "From, Aunt Sue".

You have 500 Aunts named "Sue".

So, to avoid sending the card to the wrong person, you need to figure out which Aunt Sue (which you conveniently number 1 to 500, for sanity) gave you the gift. You open the present and, as luck would have it, good ol' Aunt Sue got you a My First Crime Scene Analysis Machine! Just what you wanted. Or needed, as the case may be.

The My First Crime Scene Analysis Machine (MFCSAM for short) can detect a few specific compounds in a given sample, as well as how many distinct kinds of those compounds there are. According to the instructions, these are what the MFCSAM can detect:

    children, by human DNA age analysis.
    cats. It doesn't differentiate individual breeds.
    Several seemingly random breeds of dog: samoyeds, pomeranians, akitas, and vizslas.
    goldfish. No other kinds of fish.
    trees, all in one group.
    cars, presumably by exhaust or gasoline or something.
    perfumes, which is handy, since many of your Aunts Sue wear a few kinds.

In fact, many of your Aunts Sue have many of these. You put the wrapping from the gift into the MFCSAM. It beeps inquisitively at you a few times and then prints out a message on ticker tape:

children: 3
cats: 7
samoyeds: 2
pomeranians: 3
akitas: 0
vizslas: 0
goldfish: 5
trees: 3
cars: 2
perfumes: 1

You make a list of the things you can remember about each Aunt Sue. Things missing from your list aren't zero - you simply don't remember the value.

What is the number of the Sue that got you the gift?

Your puzzle answer was 103.
--- Part Two ---

As you're about to send the thank you note, something in the MFCSAM's instructions catches your eye. Apparently, it has an outdated retroencabulator, and so the output from the machine isn't exact values - some of them indicate ranges.

In particular, the cats and trees readings indicates that there are greater than that many (due to the unpredictable nuclear decay of cat dander and tree pollen), while the pomeranians and goldfish readings indicate that there are fewer than that many (due to the modial interaction of magnetoreluctance).

What is the number of the real Aunt Sue?

Your puzzle answer was 405.
** data
#+BEGIN_SRC text :tangle d16.txt :padline no
Sue 1: goldfish: 6, trees: 9, akitas: 0
Sue 2: goldfish: 7, trees: 1, akitas: 0
Sue 3: cars: 10, akitas: 6, perfumes: 7
Sue 4: perfumes: 2, vizslas: 0, cars: 6
Sue 5: goldfish: 1, trees: 3, perfumes: 10
Sue 6: children: 9, vizslas: 7, cars: 9
Sue 7: cars: 6, vizslas: 5, cats: 3
Sue 8: akitas: 10, vizslas: 9, children: 3
Sue 9: vizslas: 8, cats: 2, trees: 1
Sue 10: perfumes: 10, trees: 6, cars: 4
Sue 11: cars: 9, children: 1, cats: 1
Sue 12: pomeranians: 4, akitas: 6, goldfish: 8
Sue 13: cats: 10, children: 5, trees: 9
Sue 14: perfumes: 8, vizslas: 3, samoyeds: 1
Sue 15: vizslas: 2, perfumes: 8, trees: 3
Sue 16: pomeranians: 10, trees: 9, samoyeds: 4
Sue 17: akitas: 7, vizslas: 0, goldfish: 6
Sue 18: trees: 5, vizslas: 9, cars: 0
Sue 19: akitas: 3, goldfish: 9, trees: 10
Sue 20: perfumes: 7, samoyeds: 3, vizslas: 10
Sue 21: perfumes: 7, pomeranians: 10, akitas: 8
Sue 22: vizslas: 6, trees: 8, akitas: 10
Sue 23: goldfish: 0, trees: 4, children: 9
Sue 24: goldfish: 7, pomeranians: 9, akitas: 4
Sue 25: cars: 7, trees: 4, pomeranians: 4
Sue 26: trees: 9, akitas: 9, pomeranians: 7
Sue 27: samoyeds: 0, perfumes: 9, goldfish: 10
Sue 28: cars: 5, trees: 7, vizslas: 1
Sue 29: perfumes: 9, trees: 1, children: 6
Sue 30: goldfish: 10, trees: 0, cars: 4
Sue 31: akitas: 2, perfumes: 5, goldfish: 5
Sue 32: goldfish: 0, akitas: 5, trees: 0
Sue 33: vizslas: 2, akitas: 2, samoyeds: 3
Sue 34: goldfish: 8, perfumes: 5, cars: 3
Sue 35: akitas: 1, cats: 4, trees: 9
Sue 36: cars: 4, vizslas: 4, goldfish: 7
Sue 37: akitas: 5, perfumes: 7, trees: 3
Sue 38: goldfish: 10, trees: 2, vizslas: 9
Sue 39: goldfish: 4, pomeranians: 5, vizslas: 5
Sue 40: perfumes: 5, samoyeds: 4, akitas: 6
Sue 41: goldfish: 9, cars: 4, perfumes: 5
Sue 42: trees: 6, pomeranians: 9, goldfish: 8
Sue 43: perfumes: 7, pomeranians: 1, akitas: 2
Sue 44: vizslas: 9, cars: 5, cats: 0
Sue 45: akitas: 1, goldfish: 6, trees: 0
Sue 46: akitas: 5, vizslas: 8, trees: 2
Sue 47: trees: 9, akitas: 2, vizslas: 9
Sue 48: goldfish: 10, trees: 5, akitas: 2
Sue 49: cars: 7, vizslas: 2, perfumes: 6
Sue 50: akitas: 5, goldfish: 6, perfumes: 0
Sue 51: cars: 9, cats: 7, trees: 5
Sue 52: akitas: 7, goldfish: 10, cars: 0
Sue 53: cars: 10, cats: 4, perfumes: 2
Sue 54: goldfish: 2, pomeranians: 5, perfumes: 10
Sue 55: vizslas: 5, akitas: 4, cars: 8
Sue 56: goldfish: 9, vizslas: 4, akitas: 5
Sue 57: perfumes: 8, samoyeds: 7, cars: 9
Sue 58: cars: 5, akitas: 7, perfumes: 8
Sue 59: samoyeds: 8, cars: 10, vizslas: 10
Sue 60: akitas: 6, samoyeds: 0, goldfish: 3
Sue 61: trees: 8, pomeranians: 0, akitas: 2
Sue 62: trees: 1, perfumes: 3, vizslas: 4
Sue 63: vizslas: 6, samoyeds: 9, goldfish: 8
Sue 64: goldfish: 7, trees: 6, vizslas: 3
Sue 65: cars: 1, vizslas: 0, akitas: 6
Sue 66: cats: 6, pomeranians: 4, cars: 9
Sue 67: trees: 10, pomeranians: 7, samoyeds: 3
Sue 68: pomeranians: 5, goldfish: 9, akitas: 1
Sue 69: akitas: 1, vizslas: 0, trees: 9
Sue 70: cats: 4, goldfish: 4, vizslas: 10
Sue 71: vizslas: 7, perfumes: 7, trees: 8
Sue 72: children: 2, vizslas: 9, cats: 3
Sue 73: cars: 8, pomeranians: 0, perfumes: 6
Sue 74: akitas: 1, pomeranians: 8, vizslas: 10
Sue 75: vizslas: 5, perfumes: 5, cars: 7
Sue 76: cars: 3, vizslas: 3, goldfish: 0
Sue 77: akitas: 9, samoyeds: 1, pomeranians: 3
Sue 78: trees: 0, vizslas: 0, akitas: 6
Sue 79: pomeranians: 9, cars: 1, perfumes: 0
Sue 80: perfumes: 10, trees: 1, cats: 0
Sue 81: goldfish: 5, akitas: 9, trees: 0
Sue 82: vizslas: 1, akitas: 6, children: 4
Sue 83: samoyeds: 7, perfumes: 8, pomeranians: 4
Sue 84: perfumes: 3, children: 3, cats: 7
Sue 85: goldfish: 9, trees: 3, cars: 9
Sue 86: cars: 0, perfumes: 9, vizslas: 0
Sue 87: children: 3, trees: 4, akitas: 3
Sue 88: trees: 1, samoyeds: 1, goldfish: 0
Sue 89: akitas: 8, cars: 3, vizslas: 9
Sue 90: pomeranians: 9, trees: 9, goldfish: 8
Sue 91: goldfish: 7, trees: 10, children: 0
Sue 92: cats: 9, cars: 7, perfumes: 7
Sue 93: vizslas: 2, goldfish: 7, cats: 9
Sue 94: akitas: 5, cars: 8, vizslas: 4
Sue 95: goldfish: 7, vizslas: 1, perfumes: 2
Sue 96: goldfish: 5, trees: 6, perfumes: 10
Sue 97: trees: 0, perfumes: 7, cars: 0
Sue 98: cars: 2, perfumes: 6, trees: 8
Sue 99: trees: 10, children: 7, cats: 9
Sue 100: samoyeds: 5, goldfish: 6, vizslas: 6
Sue 101: cars: 10, perfumes: 9, vizslas: 3
Sue 102: pomeranians: 6, trees: 1, samoyeds: 4
Sue 103: cars: 2, perfumes: 1, goldfish: 5
Sue 104: goldfish: 2, cars: 8, pomeranians: 2
Sue 105: goldfish: 6, vizslas: 0, trees: 10
Sue 106: trees: 10, akitas: 10, pomeranians: 0
Sue 107: vizslas: 2, pomeranians: 10, trees: 3
Sue 108: children: 3, vizslas: 8, akitas: 7
Sue 109: perfumes: 2, akitas: 2, samoyeds: 3
Sue 110: goldfish: 7, trees: 1, perfumes: 1
Sue 111: akitas: 2, cars: 9, perfumes: 2
Sue 112: children: 10, cars: 0, akitas: 3
Sue 113: akitas: 9, vizslas: 4, children: 3
Sue 114: pomeranians: 3, trees: 2, goldfish: 5
Sue 115: perfumes: 8, cars: 6, trees: 0
Sue 116: samoyeds: 6, children: 3, pomeranians: 1
Sue 117: goldfish: 1, trees: 2, akitas: 1
Sue 118: goldfish: 10, akitas: 10, samoyeds: 0
Sue 119: vizslas: 10, perfumes: 6, cars: 0
Sue 120: cars: 2, perfumes: 9, goldfish: 5
Sue 121: vizslas: 2, trees: 2, cars: 6
Sue 122: vizslas: 3, trees: 0, akitas: 2
Sue 123: akitas: 5, samoyeds: 7, goldfish: 1
Sue 124: goldfish: 8, samoyeds: 7, trees: 8
Sue 125: trees: 3, goldfish: 8, perfumes: 5
Sue 126: cats: 3, vizslas: 9, goldfish: 0
Sue 127: pomeranians: 9, goldfish: 3, perfumes: 6
Sue 128: vizslas: 4, cars: 8, goldfish: 5
Sue 129: vizslas: 8, children: 5, perfumes: 8
Sue 130: cars: 7, children: 7, cats: 3
Sue 131: perfumes: 1, akitas: 8, vizslas: 9
Sue 132: perfumes: 7, samoyeds: 10, pomeranians: 6
Sue 133: cars: 5, perfumes: 3, goldfish: 7
Sue 134: perfumes: 9, akitas: 2, cats: 3
Sue 135: perfumes: 1, trees: 9, vizslas: 9
Sue 136: akitas: 7, cars: 3, perfumes: 7
Sue 137: vizslas: 9, goldfish: 8, cars: 5
Sue 138: trees: 0, samoyeds: 1, cars: 3
Sue 139: cars: 0, perfumes: 6, trees: 0
Sue 140: pomeranians: 4, cars: 1, perfumes: 7
Sue 141: vizslas: 10, akitas: 8, cats: 3
Sue 142: trees: 1, cats: 6, vizslas: 5
Sue 143: pomeranians: 9, cars: 7, perfumes: 9
Sue 144: cars: 0, perfumes: 2, pomeranians: 1
Sue 145: trees: 1, goldfish: 9, perfumes: 8
Sue 146: cars: 8, children: 5, vizslas: 2
Sue 147: perfumes: 2, goldfish: 5, cars: 0
Sue 148: akitas: 2, perfumes: 7, pomeranians: 6
Sue 149: goldfish: 8, cars: 0, trees: 1
Sue 150: akitas: 6, perfumes: 5, trees: 0
Sue 151: vizslas: 6, samoyeds: 8, akitas: 10
Sue 152: trees: 7, akitas: 7, perfumes: 6
Sue 153: goldfish: 9, cats: 9, cars: 3
Sue 154: vizslas: 10, trees: 0, cars: 9
Sue 155: perfumes: 3, children: 2, goldfish: 1
Sue 156: goldfish: 7, perfumes: 5, akitas: 6
Sue 157: cats: 10, trees: 1, goldfish: 0
Sue 158: cats: 7, children: 7, vizslas: 6
Sue 159: perfumes: 9, akitas: 0, cars: 0
Sue 160: akitas: 3, goldfish: 10, pomeranians: 2
Sue 161: goldfish: 10, cars: 6, perfumes: 3
Sue 162: trees: 0, cars: 9, goldfish: 1
Sue 163: cars: 8, perfumes: 9, vizslas: 5
Sue 164: goldfish: 1, trees: 10, children: 6
Sue 165: goldfish: 0, vizslas: 6, cars: 0
Sue 166: akitas: 5, vizslas: 1, cars: 5
Sue 167: vizslas: 1, samoyeds: 1, children: 4
Sue 168: samoyeds: 7, vizslas: 7, akitas: 3
Sue 169: goldfish: 3, cats: 9, trees: 2
Sue 170: cars: 5, perfumes: 9, vizslas: 5
Sue 171: goldfish: 7, cars: 6, perfumes: 10
Sue 172: cats: 6, akitas: 1, children: 6
Sue 173: cats: 4, goldfish: 1, children: 3
Sue 174: cars: 2, pomeranians: 2, vizslas: 7
Sue 175: trees: 0, children: 4, goldfish: 7
Sue 176: children: 8, cars: 5, cats: 9
Sue 177: pomeranians: 4, vizslas: 7, trees: 3
Sue 178: vizslas: 6, perfumes: 10, akitas: 6
Sue 179: cars: 4, akitas: 4, trees: 4
Sue 180: akitas: 8, goldfish: 6, trees: 9
Sue 181: perfumes: 3, vizslas: 10, cars: 3
Sue 182: vizslas: 3, samoyeds: 3, goldfish: 7
Sue 183: goldfish: 10, perfumes: 2, cats: 1
Sue 184: goldfish: 5, trees: 1, perfumes: 1
Sue 185: vizslas: 10, trees: 9, perfumes: 2
Sue 186: goldfish: 6, perfumes: 9, trees: 1
Sue 187: cars: 0, trees: 9, goldfish: 6
Sue 188: cars: 0, trees: 1, vizslas: 9
Sue 189: akitas: 7, vizslas: 2, trees: 0
Sue 190: pomeranians: 5, perfumes: 8, akitas: 10
Sue 191: vizslas: 5, akitas: 3, cats: 0
Sue 192: children: 1, trees: 1, cars: 2
Sue 193: cars: 3, goldfish: 9, trees: 2
Sue 194: samoyeds: 3, akitas: 4, perfumes: 8
Sue 195: trees: 1, vizslas: 8, akitas: 10
Sue 196: akitas: 6, cars: 5, pomeranians: 0
Sue 197: akitas: 5, vizslas: 5, cats: 1
Sue 198: trees: 4, cars: 6, goldfish: 6
Sue 199: cats: 7, cars: 5, goldfish: 6
Sue 200: vizslas: 4, cats: 0, akitas: 9
Sue 201: pomeranians: 1, perfumes: 4, children: 2
Sue 202: cats: 1, perfumes: 4, vizslas: 3
Sue 203: vizslas: 1, akitas: 9, children: 5
Sue 204: perfumes: 8, cars: 7, trees: 4
Sue 205: perfumes: 7, pomeranians: 5, cats: 9
Sue 206: vizslas: 8, trees: 2, akitas: 2
Sue 207: akitas: 6, vizslas: 2, perfumes: 10
Sue 208: vizslas: 1, children: 7, akitas: 4
Sue 209: perfumes: 4, trees: 2, children: 1
Sue 210: goldfish: 0, vizslas: 2, samoyeds: 10
Sue 211: cars: 8, perfumes: 3, trees: 1
Sue 212: cars: 8, samoyeds: 5, pomeranians: 8
Sue 213: akitas: 2, goldfish: 8, pomeranians: 2
Sue 214: akitas: 6, pomeranians: 2, cars: 0
Sue 215: trees: 10, pomeranians: 4, vizslas: 0
Sue 216: perfumes: 0, cars: 8, trees: 0
Sue 217: samoyeds: 8, akitas: 7, children: 10
Sue 218: perfumes: 1, vizslas: 6, children: 0
Sue 219: children: 1, goldfish: 4, trees: 1
Sue 220: akitas: 10, goldfish: 10, trees: 5
Sue 221: cars: 7, pomeranians: 6, perfumes: 3
Sue 222: vizslas: 6, children: 0, akitas: 5
Sue 223: perfumes: 9, cars: 1, trees: 6
Sue 224: pomeranians: 1, trees: 0, vizslas: 0
Sue 225: goldfish: 8, akitas: 4, perfumes: 10
Sue 226: pomeranians: 7, cats: 7, children: 4
Sue 227: trees: 0, akitas: 2, perfumes: 1
Sue 228: vizslas: 6, cars: 10, perfumes: 9
Sue 229: cars: 0, perfumes: 6, trees: 4
Sue 230: pomeranians: 7, perfumes: 5, trees: 2
Sue 231: goldfish: 9, cars: 6, trees: 7
Sue 232: akitas: 1, vizslas: 5, cars: 3
Sue 233: akitas: 7, samoyeds: 2, vizslas: 5
Sue 234: akitas: 6, cats: 8, pomeranians: 0
Sue 235: pomeranians: 5, akitas: 5, vizslas: 3
Sue 236: goldfish: 5, trees: 6, akitas: 5
Sue 237: goldfish: 9, perfumes: 5, cats: 5
Sue 238: cats: 8, goldfish: 4, perfumes: 0
Sue 239: samoyeds: 8, children: 6, pomeranians: 6
Sue 240: akitas: 4, samoyeds: 10, trees: 8
Sue 241: trees: 2, goldfish: 8, cars: 1
Sue 242: perfumes: 2, cars: 0, akitas: 10
Sue 243: pomeranians: 1, cars: 7, trees: 2
Sue 244: trees: 9, vizslas: 2, akitas: 10
Sue 245: cars: 9, pomeranians: 4, trees: 0
Sue 246: cars: 9, pomeranians: 7, perfumes: 1
Sue 247: trees: 0, goldfish: 1, akitas: 8
Sue 248: vizslas: 1, cats: 4, akitas: 4
Sue 249: cats: 6, children: 4, goldfish: 9
Sue 250: vizslas: 1, cars: 10, samoyeds: 5
Sue 251: cars: 0, goldfish: 1, vizslas: 7
Sue 252: cars: 7, akitas: 9, vizslas: 10
Sue 253: akitas: 7, vizslas: 2, perfumes: 5
Sue 254: vizslas: 10, akitas: 5, samoyeds: 0
Sue 255: pomeranians: 8, goldfish: 0, cats: 6
Sue 256: cars: 10, goldfish: 8, vizslas: 9
Sue 257: goldfish: 3, perfumes: 9, cats: 3
Sue 258: trees: 6, goldfish: 6, cars: 6
Sue 259: trees: 0, goldfish: 2, perfumes: 8
Sue 260: trees: 5, akitas: 0, cars: 0
Sue 261: pomeranians: 9, goldfish: 7, perfumes: 8
Sue 262: perfumes: 8, vizslas: 6, goldfish: 2
Sue 263: vizslas: 6, trees: 5, goldfish: 9
Sue 264: vizslas: 4, perfumes: 7, cars: 9
Sue 265: goldfish: 10, trees: 3, perfumes: 1
Sue 266: trees: 10, akitas: 8, goldfish: 8
Sue 267: goldfish: 4, trees: 0, samoyeds: 9
Sue 268: vizslas: 1, trees: 0, goldfish: 8
Sue 269: cars: 2, perfumes: 10, goldfish: 5
Sue 270: perfumes: 7, cars: 2, vizslas: 1
Sue 271: cars: 6, perfumes: 10, goldfish: 6
Sue 272: samoyeds: 4, goldfish: 2, vizslas: 9
Sue 273: perfumes: 4, goldfish: 4, vizslas: 1
Sue 274: children: 4, cars: 4, perfumes: 3
Sue 275: children: 8, vizslas: 3, trees: 2
Sue 276: vizslas: 5, children: 7, perfumes: 3
Sue 277: perfumes: 3, cats: 4, vizslas: 5
Sue 278: cars: 1, samoyeds: 10, akitas: 2
Sue 279: trees: 9, perfumes: 9, cars: 10
Sue 280: vizslas: 5, trees: 0, perfumes: 6
Sue 281: vizslas: 3, akitas: 10, pomeranians: 7
Sue 282: trees: 1, children: 2, akitas: 8
Sue 283: akitas: 9, goldfish: 6, cats: 5
Sue 284: cars: 9, children: 10, pomeranians: 2
Sue 285: pomeranians: 0, perfumes: 4, cars: 7
Sue 286: perfumes: 0, vizslas: 10, akitas: 10
Sue 287: cats: 2, perfumes: 3, trees: 5
Sue 288: akitas: 9, vizslas: 8, samoyeds: 9
Sue 289: perfumes: 6, children: 2, cars: 7
Sue 290: akitas: 0, children: 5, cars: 5
Sue 291: cars: 4, perfumes: 0, trees: 1
Sue 292: cats: 0, cars: 8, perfumes: 6
Sue 293: akitas: 9, cats: 5, children: 5
Sue 294: akitas: 4, cars: 9, goldfish: 3
Sue 295: cars: 2, akitas: 3, perfumes: 7
Sue 296: perfumes: 4, cars: 7, goldfish: 10
Sue 297: trees: 5, akitas: 8, vizslas: 1
Sue 298: perfumes: 0, goldfish: 6, trees: 9
Sue 299: perfumes: 6, samoyeds: 8, cars: 1
Sue 300: goldfish: 10, perfumes: 4, akitas: 2
Sue 301: cars: 3, trees: 0, goldfish: 8
Sue 302: perfumes: 7, samoyeds: 2, vizslas: 7
Sue 303: children: 10, goldfish: 7, perfumes: 2
Sue 304: samoyeds: 8, vizslas: 2, cars: 1
Sue 305: trees: 1, cats: 0, goldfish: 10
Sue 306: trees: 4, perfumes: 2, cars: 7
Sue 307: cars: 6, vizslas: 2, children: 6
Sue 308: vizslas: 2, cars: 0, akitas: 7
Sue 309: cars: 3, vizslas: 8, perfumes: 6
Sue 310: goldfish: 7, perfumes: 7, vizslas: 3
Sue 311: pomeranians: 10, trees: 2, cars: 0
Sue 312: samoyeds: 2, vizslas: 9, akitas: 1
Sue 313: cars: 4, pomeranians: 7, goldfish: 7
Sue 314: akitas: 2, pomeranians: 9, samoyeds: 10
Sue 315: akitas: 3, vizslas: 2, trees: 0
Sue 316: cars: 0, perfumes: 4, pomeranians: 6
Sue 317: akitas: 10, goldfish: 3, pomeranians: 7
Sue 318: cars: 9, trees: 0, pomeranians: 9
Sue 319: akitas: 3, vizslas: 7, children: 10
Sue 320: vizslas: 0, akitas: 8, pomeranians: 4
Sue 321: cars: 10, akitas: 9, vizslas: 3
Sue 322: perfumes: 0, akitas: 8, vizslas: 6
Sue 323: vizslas: 10, perfumes: 5, cars: 3
Sue 324: akitas: 0, goldfish: 6, vizslas: 7
Sue 325: perfumes: 9, vizslas: 5, pomeranians: 2
Sue 326: vizslas: 6, goldfish: 10, pomeranians: 8
Sue 327: vizslas: 10, cars: 1, akitas: 7
Sue 328: trees: 1, perfumes: 10, cars: 10
Sue 329: pomeranians: 5, samoyeds: 3, cars: 10
Sue 330: akitas: 6, cars: 1, pomeranians: 4
Sue 331: cars: 5, children: 2, trees: 0
Sue 332: vizslas: 6, pomeranians: 1, perfumes: 0
Sue 333: akitas: 7, trees: 1, cats: 9
Sue 334: vizslas: 6, goldfish: 9, akitas: 7
Sue 335: akitas: 3, samoyeds: 3, cars: 3
Sue 336: samoyeds: 10, perfumes: 9, trees: 6
Sue 337: vizslas: 2, cars: 9, akitas: 0
Sue 338: akitas: 6, perfumes: 9, vizslas: 3
Sue 339: cars: 3, samoyeds: 8, trees: 2
Sue 340: cats: 7, perfumes: 8, cars: 9
Sue 341: goldfish: 9, perfumes: 5, cars: 10
Sue 342: trees: 0, akitas: 3, perfumes: 5
Sue 343: perfumes: 2, children: 0, cars: 6
Sue 344: goldfish: 8, trees: 8, perfumes: 0
Sue 345: perfumes: 6, cars: 6, goldfish: 5
Sue 346: vizslas: 8, trees: 1, cars: 6
Sue 347: cars: 0, cats: 3, perfumes: 7
Sue 348: children: 7, perfumes: 10, cars: 7
Sue 349: pomeranians: 8, akitas: 5, children: 2
Sue 350: perfumes: 9, pomeranians: 4, goldfish: 3
Sue 351: perfumes: 8, pomeranians: 7, trees: 4
Sue 352: samoyeds: 1, goldfish: 9, akitas: 8
Sue 353: akitas: 6, goldfish: 10, vizslas: 8
Sue 354: akitas: 7, cars: 2, goldfish: 6
Sue 355: cars: 3, goldfish: 6, akitas: 5
Sue 356: akitas: 2, goldfish: 9, pomeranians: 1
Sue 357: goldfish: 10, cars: 6, pomeranians: 9
Sue 358: trees: 0, children: 2, goldfish: 6
Sue 359: samoyeds: 3, cars: 2, akitas: 4
Sue 360: trees: 1, goldfish: 8, cars: 5
Sue 361: akitas: 5, vizslas: 7, perfumes: 1
Sue 362: cats: 5, vizslas: 9, children: 4
Sue 363: goldfish: 9, perfumes: 3, vizslas: 9
Sue 364: children: 7, samoyeds: 2, pomeranians: 10
Sue 365: perfumes: 9, akitas: 10, pomeranians: 4
Sue 366: cars: 10, trees: 3, cats: 4
Sue 367: vizslas: 6, akitas: 10, perfumes: 5
Sue 368: akitas: 9, vizslas: 9, children: 4
Sue 369: goldfish: 8, trees: 2, perfumes: 5
Sue 370: trees: 0, children: 4, cars: 8
Sue 371: cats: 6, perfumes: 0, vizslas: 2
Sue 372: akitas: 7, cars: 5, perfumes: 3
Sue 373: cars: 0, perfumes: 4, pomeranians: 10
Sue 374: akitas: 5, perfumes: 5, vizslas: 2
Sue 375: goldfish: 7, trees: 10, pomeranians: 7
Sue 376: cars: 8, trees: 1, pomeranians: 8
Sue 377: cars: 0, akitas: 9, vizslas: 1
Sue 378: akitas: 5, perfumes: 3, vizslas: 7
Sue 379: trees: 2, goldfish: 8, pomeranians: 8
Sue 380: akitas: 5, cars: 9, perfumes: 9
Sue 381: cars: 2, perfumes: 6, trees: 3
Sue 382: perfumes: 6, vizslas: 2, goldfish: 9
Sue 383: akitas: 8, vizslas: 7, cats: 1
Sue 384: akitas: 9, trees: 10, vizslas: 7
Sue 385: cars: 0, perfumes: 7, vizslas: 2
Sue 386: vizslas: 10, akitas: 4, perfumes: 9
Sue 387: perfumes: 6, pomeranians: 5, samoyeds: 8
Sue 388: vizslas: 10, trees: 9, goldfish: 9
Sue 389: goldfish: 8, akitas: 4, perfumes: 10
Sue 390: goldfish: 6, trees: 8, akitas: 1
Sue 391: vizslas: 4, akitas: 10, goldfish: 7
Sue 392: akitas: 1, vizslas: 6, samoyeds: 5
Sue 393: trees: 6, cars: 3, akitas: 5
Sue 394: goldfish: 9, trees: 3, cars: 5
Sue 395: akitas: 6, samoyeds: 4, goldfish: 4
Sue 396: akitas: 2, trees: 1, cats: 5
Sue 397: cars: 0, children: 9, trees: 10
Sue 398: pomeranians: 3, samoyeds: 9, goldfish: 10
Sue 399: cars: 7, akitas: 4, goldfish: 8
Sue 400: cars: 4, akitas: 5, vizslas: 4
Sue 401: pomeranians: 5, akitas: 8, vizslas: 5
Sue 402: cats: 7, cars: 6, goldfish: 6
Sue 403: samoyeds: 8, perfumes: 4, cars: 5
Sue 404: akitas: 10, goldfish: 4, trees: 2
Sue 405: trees: 8, perfumes: 1, cars: 2
Sue 406: trees: 0, perfumes: 9, pomeranians: 10
Sue 407: perfumes: 4, trees: 7, goldfish: 3
Sue 408: akitas: 1, perfumes: 3, cars: 5
Sue 409: trees: 6, samoyeds: 3, cars: 9
Sue 410: vizslas: 3, goldfish: 5, akitas: 7
Sue 411: goldfish: 10, trees: 1, vizslas: 9
Sue 412: cars: 0, akitas: 6, trees: 6
Sue 413: goldfish: 7, trees: 0, cars: 3
Sue 414: pomeranians: 10, samoyeds: 3, cars: 10
Sue 415: perfumes: 6, trees: 9, cars: 4
Sue 416: trees: 2, cars: 4, goldfish: 8
Sue 417: goldfish: 2, cars: 9, cats: 5
Sue 418: vizslas: 1, cars: 9, akitas: 0
Sue 419: perfumes: 6, cats: 3, children: 9
Sue 420: cats: 5, goldfish: 7, akitas: 9
Sue 421: trees: 1, samoyeds: 6, pomeranians: 1
Sue 422: trees: 10, goldfish: 6, children: 7
Sue 423: cars: 8, goldfish: 7, vizslas: 3
Sue 424: samoyeds: 9, akitas: 7, trees: 5
Sue 425: akitas: 5, children: 4, perfumes: 9
Sue 426: goldfish: 1, children: 9, cats: 2
Sue 427: vizslas: 9, akitas: 7, goldfish: 9
Sue 428: pomeranians: 7, akitas: 5, vizslas: 1
Sue 429: vizslas: 7, goldfish: 7, cars: 9
Sue 430: trees: 7, perfumes: 0, pomeranians: 5
Sue 431: children: 9, perfumes: 5, vizslas: 7
Sue 432: trees: 6, samoyeds: 7, cats: 1
Sue 433: goldfish: 5, trees: 5, children: 6
Sue 434: goldfish: 9, akitas: 7, cars: 3
Sue 435: samoyeds: 10, perfumes: 2, cars: 0
Sue 436: akitas: 5, pomeranians: 4, perfumes: 7
Sue 437: vizslas: 5, cats: 6, perfumes: 5
Sue 438: trees: 2, goldfish: 6, vizslas: 7
Sue 439: samoyeds: 8, pomeranians: 10, goldfish: 1
Sue 440: akitas: 6, children: 9, perfumes: 4
Sue 441: cars: 2, goldfish: 9, children: 0
Sue 442: goldfish: 7, cars: 2, vizslas: 8
Sue 443: goldfish: 6, samoyeds: 3, perfumes: 2
Sue 444: trees: 2, goldfish: 7, cars: 8
Sue 445: trees: 2, pomeranians: 0, children: 0
Sue 446: perfumes: 4, akitas: 4, goldfish: 6
Sue 447: vizslas: 7, akitas: 9, cars: 3
Sue 448: goldfish: 6, trees: 9, cars: 0
Sue 449: samoyeds: 7, perfumes: 4, vizslas: 10
Sue 450: akitas: 7, cars: 10, goldfish: 7
Sue 451: goldfish: 4, children: 7, pomeranians: 4
Sue 452: cats: 4, vizslas: 6, trees: 7
Sue 453: cars: 1, trees: 10, goldfish: 9
Sue 454: trees: 2, goldfish: 3, vizslas: 10
Sue 455: pomeranians: 9, vizslas: 3, akitas: 2
Sue 456: vizslas: 10, akitas: 2, goldfish: 1
Sue 457: trees: 5, cats: 5, children: 8
Sue 458: cars: 6, goldfish: 3, akitas: 9
Sue 459: goldfish: 7, akitas: 2, cats: 7
Sue 460: akitas: 1, cars: 5, children: 8
Sue 461: cars: 8, perfumes: 0, goldfish: 6
Sue 462: pomeranians: 6, cats: 2, perfumes: 6
Sue 463: vizslas: 7, perfumes: 3, goldfish: 3
Sue 464: akitas: 10, goldfish: 10, trees: 1
Sue 465: vizslas: 0, akitas: 2, trees: 2
Sue 466: perfumes: 6, akitas: 8, cars: 2
Sue 467: goldfish: 1, cars: 10, perfumes: 3
Sue 468: goldfish: 4, trees: 2, cars: 9
Sue 469: perfumes: 6, pomeranians: 0, vizslas: 10
Sue 470: samoyeds: 8, children: 0, akitas: 7
Sue 471: children: 3, goldfish: 9, cats: 9
Sue 472: samoyeds: 0, goldfish: 0, trees: 0
Sue 473: trees: 3, goldfish: 4, vizslas: 1
Sue 474: perfumes: 10, cars: 3, trees: 7
Sue 475: akitas: 5, vizslas: 4, goldfish: 5
Sue 476: children: 2, akitas: 7, vizslas: 3
Sue 477: vizslas: 6, pomeranians: 9, trees: 6
Sue 478: vizslas: 7, pomeranians: 6, akitas: 7
Sue 479: trees: 2, perfumes: 2, children: 2
Sue 480: cars: 8, cats: 5, vizslas: 0
Sue 481: trees: 5, goldfish: 0, akitas: 3
Sue 482: cars: 8, perfumes: 6, goldfish: 10
Sue 483: goldfish: 0, cars: 3, perfumes: 10
Sue 484: pomeranians: 1, samoyeds: 1, perfumes: 3
Sue 485: trees: 0, akitas: 2, vizslas: 4
Sue 486: cars: 3, vizslas: 8, goldfish: 1
Sue 487: pomeranians: 9, vizslas: 2, children: 10
Sue 488: akitas: 6, vizslas: 10, perfumes: 9
Sue 489: goldfish: 6, vizslas: 4, cars: 2
Sue 490: vizslas: 10, cats: 8, samoyeds: 1
Sue 491: cats: 9, cars: 1, perfumes: 10
Sue 492: goldfish: 6, cars: 9, pomeranians: 9
Sue 493: children: 10, goldfish: 10, vizslas: 0
Sue 494: pomeranians: 5, cars: 0, vizslas: 0
Sue 495: vizslas: 7, perfumes: 6, samoyeds: 3
Sue 496: trees: 1, cats: 4, cars: 10
Sue 497: cats: 1, perfumes: 0, cars: 7
Sue 498: perfumes: 7, vizslas: 6, cats: 9
Sue 499: vizslas: 8, perfumes: 1, akitas: 3
Sue 500: perfumes: 4, cars: 9, trees: 4
#+END_SRC

** puzzle 1
#+BEGIN_SRC cpp :results output :tangle d16p1.c
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>
  #include <strings.h>

  int main() {
    FILE *f = fopen("d16.txt", "r");
    char line[1024] = { '\0' };

    char *knowns[] = { "children",
                       "cats",
                       "samoyeds",
                       "pomeranians",
                       "akitas",
                       "vizslas",
                       "goldfish",
                       "trees",
                       "cars",
                       "perfumes" };
   int knownsvals[] = { 3, 7, 2, 3, 0, 0, 5, 3, 2, 1 };
   int knownslen = sizeof(knowns) / sizeof(knowns[0]);
                        
   int bestsue = 0;
   int bestmatches = 0;
   while (fgets(line, 127, f) != NULL) {
      int sue = atoi(line + 4);
      int matches = 0;
      char *compound = index(line, ':') + 2;
      while (1) {
        char *end_of_compound = index(compound, ':');
        end_of_compound[0] = '\0';
        int val = atoi(end_of_compound + 1);
        for (int i = 0; i < knownslen; i++) {
          if (strcmp(compound, knowns[i]) == 0) {
            if (val == knownsvals[i]) {
              matches++;
            } else {
              matches = -1;
            }
            break;
          }
        }
        if (matches < 0)
          break;
        compound = index(end_of_compound + 1, ',');
        if (compound == NULL)
          break;
          compound += 2;
      }
      if (matches > bestmatches) {
        bestsue = sue;
        bestmatches = matches;
      }
    }

    printf("%d", bestsue);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 103

** puzzle 2
#+BEGIN_SRC cpp :results output :tangle d16p2.c
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>
  #include <strings.h>

  int main() {
    FILE *f = fopen("d16.txt", "r");
    char line[1024] = { '\0' };

    char *knowns[] = { "children",
                       "cats",
                       "samoyeds",
                       "pomeranians",
                       "akitas",
                       "vizslas",
                       "goldfish",
                       "trees",
                       "cars",
                       "perfumes" };
   int knownsvals[] = { 3, 7, 2,  3, 0, 0,  5, 3, 2, 1 };
   int knownstype[] = { 0, 1, 0, -1, 0, 0, -1, 1, 0, 0 };
   int knownslen = sizeof(knowns) / sizeof(knowns[0]);
                        
   int bestsue = 0;
   int bestmatches = 0;
   while (fgets(line, 127, f) != NULL) {
      int sue = atoi(line + 4);
      int matches = 0;
      char *compound = index(line, ':') + 2;
      while (1) {
        char *end_of_compound = index(compound, ':');
        end_of_compound[0] = '\0';
        int val = atoi(end_of_compound + 1);
        for (int i = 0; i < knownslen; i++) {
          if (strcmp(compound, knowns[i]) == 0) {
            if (knownstype[i] < 0 && val < knownsvals[i]
                || knownstype[i] == 0 && val == knownsvals[i]
                || knownstype[i] > 0 && val > knownsvals[i]) {
              matches++;
            } else {
              matches = -1;
            }
            break;
          }
        }
        if (matches < 0)
          break;
        compound = index(end_of_compound + 1, ',');
        if (compound == NULL)
          break;
          compound += 2;
      }
      if (matches > bestmatches) {
        bestsue = sue;
        bestmatches = matches;
      }
    }

    printf("%d", bestsue);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 405

* day 17
** text
--- Day 17: No Such Thing as Too Much ---

The elves bought too much eggnog again - 150 liters this time. To fit it all into your refrigerator, you'll need to move it into smaller containers. You take an inventory of the capacities of the available containers.

For example, suppose you have containers of size 20, 15, 10, 5, and 5 liters. If you need to store 25 liters, there are four ways to do it:

    15 and 10
    20 and 5 (the first 5)
    20 and 5 (the second 5)
    15, 5, and 5

Filling all containers entirely, how many different combinations of containers can exactly fit all 150 liters of eggnog?

Your puzzle answer was 1638.
--- Part Two ---

While playing with all the containers in the kitchen, another load of eggnog arrives! The shipping and receiving department is requesting as many containers as you can spare.

Find the minimum number of containers that can exactly fit all 150 liters of eggnog. How many different ways can you fill that number of containers and still hold exactly 150 litres?

In the example above, the minimum number of containers was two. There were three ways to use that many containers, and so the answer there would be 3.

Your puzzle answer was 17.
** data
#+BEGIN_SRC text :padline no :tangle d17.txt
43
3
4
10
21
44
4
6
47
41
34
17
17
44
36
31
46
9
27
38
#+END_SRC
** puzzle 1
#+BEGIN_SRC cpp :results output
  #include <stdio.h>
  #include <stdlib.h>

  #define EGGNOG 150

  int main() {
    FILE *f = fopen("d17.txt", "r");

    int containers[128];
    int len = 0;

    int container;
    while (fscanf(f, "%d", &container) == 1) {
      containers[len++] = container;
    }

    int allsubsetsi = 1 << len;

    int combs = 0;
    for (int i = 0; i < allsubsetsi; i++) {
      int sum = 0;
      for (int j = 0; j < len; j++) {
        if ((i & (1 << j)) > 0) {
          // printf("%d ", containers[j]);
          sum += containers[j];
        }
      }
      // printf("sum=%d (%d)\n", sum, i);
      if (sum == EGGNOG) {
        combs++;
      }
    }
    printf("%d", combs);
  }
#+END_SRC

#+RESULTS:
: 1638
** puzzle 2
#+BEGIN_SRC cpp :results output
  #include <stdio.h>
  #include <stdlib.h>

  #define EGGNOG 150

  int main() {
    FILE *f = fopen("d17.txt", "r");

    int containers[128];
    int len = 0;

    int container;
    while (fscanf(f, "%d", &container) == 1) {
      containers[len++] = container;
    }

    int allsubsetsi = 1 << len;

    int minused = len + 1;
    int mincombs = 0;
    for (int i = 0; i < allsubsetsi; i++) {
      int sum = 0;
      int used = 0;
      for (int j = 0; j < len; j++) {
        if ((i & (1 << j)) > 0) {
          // printf("%d ", containers[j]);
          sum += containers[j];
          used++;
        }
      }
      // printf("sum=%d (%d)\n", sum, i);
      if (sum == EGGNOG) {
        if (used < minused) {
          minused = used;
          mincombs = 1;
        } else if (used == minused) {
          mincombs++;
        }
      }
    }
    printf("%d", mincombs);
  }
#+END_SRC

#+RESULTS:
: 17

* day 18
** text
--- Day 18: Like a GIF For Your Yard ---

After the million lights incident, the fire code has gotten stricter: now, at most ten thousand lights are allowed. You arrange them in a 100x100 grid.

Never one to let you down, Santa again mails you instructions on the ideal lighting configuration. With so few lights, he says, you'll have to resort to animation.

Start by setting your lights to the included initial configuration (your puzzle input). A # means "on", and a . means "off".

Then, animate your grid in steps, where each step decides the next configuration based on the current one. Each light's next state (either on or off) depends on its current state and the current states of the eight lights adjacent to it (including diagonals). Lights on the edge of the grid might have fewer than eight neighbors; the missing ones always count as "off".

For example, in a simplified 6x6 grid, the light marked A has the neighbors numbered 1 through 8, and the light marked B, which is on an edge, only has the neighbors marked 1 through 5:

1B5...
234...
......
..123.
..8A4.
..765.

The state a light should have next is based on its current state (on or off) plus the number of neighbors that are on:

    A light which is on stays on when 2 or 3 neighbors are on, and turns off otherwise.
    A light which is off turns on if exactly 3 neighbors are on, and stays off otherwise.

All of the lights update simultaneously; they all consider the same current state before moving to the next.

Here's a few steps from an example configuration of another 6x6 grid:

Initial state:
.#.#.#
...##.
#....#
..#...
#.#..#
####..

After 1 step:
..##..
..##.#
...##.
......
#.....
#.##..

After 2 steps:
..###.
......
..###.
......
.#....
.#....

After 3 steps:
...#..
......
...#..
..##..
......
......

After 4 steps:
......
......
..##..
..##..
......
......

After 4 steps, this example has four lights on.

In your grid of 100x100 lights, given your initial configuration, how many lights are on after 100 steps?

Your puzzle answer was 814.
--- Part Two ---

You flip the instructions over; Santa goes on to point out that this is all just an implementation of Conway's Game of Life. At least, it was, until you notice that something's wrong with the grid of lights you bought: four lights, one in each corner, are stuck on and can't be turned off. The example above will actually run like this:

Initial state:
##.#.#
...##.
#....#
..#...
#.#..#
####.#

After 1 step:
#.##.#
####.#
...##.
......
#...#.
#.####

After 2 steps:
#..#.#
#....#
.#.##.
...##.
.#..##
##.###

After 3 steps:
#...##
####.#
..##.#
......
##....
####.#

After 4 steps:
#.####
#....#
...#..
.##...
#.....
#.#..#

After 5 steps:
##.###
.##..#
.##...
.##...
#.#...
##...#

After 5 steps, this example now has 17 lights on.

In your grid of 100x100 lights, given your initial configuration, but with the four corners always in the on state, how many lights are on after 100 steps?

Your puzzle answer was 924.
** data
#+BEGIN_SRC text :padline no :tangle d18.txt
#...##......#......##.##..#...##......##.#.#.###.#.#..#..#......####..#......###.#.#....#..##..###..
####..#.#...#....#.#####.##.##.#..#.......#....#.##...###.###..#.#.#........#..#.#.##...##..#.####.#
...#..##...#.#.###.#.###..#.##.####.###...#...........#.###..##.#.##.#.###...#.#..###....#.###.#..#.
.#...##...####.#..#.....#..#...#.#.##...#...##..#.#.###....#..###.....##..#.###..###.....##..###...#
..##.#####....##..#.#..##.##..######...#..###.######.....#..##...#.#..##..##..#..#..#..##.#.#.#.#...
.###.###.###...##...##..###..##.###.#.....##..##.#.#########...##..##.#..##.#..##..####..#.#.#.#####
#.#####..###.###.##.##.#...#.#.#.#..#.###...#..##.###.#...####.#..#.#.....###..#..####..#.#.#...##..
....#...##.....#....####.##.#.###..#.#.##..#.#...##.###.###..#.##..#.#.##..##..#.##.###..#.#.###.###
##.##...#.##...#.#..#.#..#...###...###.#..#..#.#####..###.#......#.....###.#####.#.#..#.#.#.##..#.#.
#.#..#.....#.....##.#..##...###..##...##...###.#.###.#..#.#.###...##..##..#.###...#.#######.#...#.#.
#.#.....####.#..#.##...#.##....#####.###.#.....#####....###..#........##..####...#...#.###....#..###
##.#.##..#.#.##.#.....##.#.....###.####.#..######.....####.#.#..##.#.##...#..#.#.....#.####.#.......
#..#..#.#..#.######.##..##.####.....##.#.##.#.######..#.#....#.#...#.#..#..#.#.###.#..#.#.#..#...###
####..####.#.#.###.....#.#.#.##..#.##.##.##.#..##..##.#.##.....#.#..#.####.....###.#..#.####.#.#..##
###.##..##.#.##..#..##...#.#####.##.#....##.####.#.##....#..###.#.#.##...#.....#.#.#.#.#..##.#.#..#.
......#..####...##.##...#.##.##...##..#..##.###..#...#..##...#.#....###.####...#.##.###.#.##.####.##
..#...#####.#.#..#.##....#..#...#..####.....###...##.###....#..#.###...#........#.#.##..#..#.#.....#
#######.#.#.###.###..######.##..#####.##.###.###....####.#..##.##...###.#..############.#.##....##.#
#.#...##.###.#.###..#.#.#.#.#.#..##..####.#..##.....#.##..#.##...##.#..##..#.#.#....##....##.#..#.#.
..#.#.####.....###..#######.#.#.#.#...##.#####.....##...##...##.###..######.###..#...####.#..###.###
.#.##....#.#.##..##.#.##.##..######...#.....#..#.#.#.#.....#.#..##.#.#.......#######....#.......#...
..###.##.##..##....#.###...#.....##..##......###...##..###.##...##.###.#.#.#.###.###.#.#...###..#...
.##.#.#...#...##.#.#...#..#..#.#...##.#.##...##..#....#.#..##.#..#.#..#.#.....#..#.#...#######.#.##.
...####....#.###.#..###..##...##..#.#.#.###...#..##.##.##..##.#...#..#.##.....#.#........#..#.#.####
.....##..###...#....#.#.#.#...###.###...#.#...#.#.####....#..####...###..#..######..##.##..###.#####
#####.##..#....###.###....##.....#.#..#....#.#####.##.#.####.#.##...#..###...###..##...#.###.#####..
###.##..........########.######....####.###.#..##...#.##.####.#.....##..#####..###...#####.....#.#.#
##..#####.##.#.#####.#.##.##..#.##....########.#####.#...#.###.##...#.###.#.#..#....##.#..#...#.#.#.
.##.#....#..#...#..#####..#..##.#......#..#....########...#..#...#.....####.#...##...#.###.#.#..##.#
.##.##.#.##.#.##...#.#.#..##.##.###.#..##..#...###.##.###.#####.#.###..#..###.#...#.###.#...#..#.#.#
.#..#..#.#..#..###..#....###.####.##.#.###.#.##.###.#.##.###.###...###...###.#...####...#.##.##.#.#.
###..##...###...#..##.#..#.#...##....###.##.##..#####....###..#..#....#..###.###.#...#.##...#.#.#..#
#....#.......##.....#.##...#..#.###.#.##..##..#.##..#.###..##.##...#####.#..#####..#####..#####....#
.####.####....###..###.#.##.####.##.#...####.#.###.#.....#...####..#####.###..#.#.###.##.##...##..#.
####..##...##.########...##..###..#..###.##.#.#.#........#.#####.#...#.###.####.#..####..#.#.#....##
###.#..#...###.#..#..#.###...##..###.##.#.#...#..#...####..##....#.#..#..##.#.#...#####.###.#..#.#.#
...##....#.###.#.#..##...##.###.#..#..#......#...#.#..####.#.##..######.####.#...#..#..#..##.#.#.##.
##.####.#...#..#.#.##..##.#.#.###..##...####......#..######.#......#.##.#....##...###.#.#..#......##
#.....#...#######.##.#..#.#...###.#..#.####....#.#.##.#.##...###..#...#.###.##..#.###..#.##...#####.
#####.##...#..#.#.#.......#.##..#####..#####...###..##.#.#..###.#.#####.####..#.#..##...#.##...#.###
.##.#..#######.###.#.####.....##...#.##.#.#..#...##....####......######.#..######.....##########.##.
##...#.#..#.##.###.#.#.#.##.###.##..##.##.##...#.#..###.#######..#.....#####..#....######.#..##..###
.#.#.###.....#..##..#.#..##..#.###...###.#..##...#...#.#####.#.#####..###.#..#...##..#.#..#..####...
.#......##..#.....####.###....##.###.....###.##........#.###.##..#..#.#######.#.######..##..###.....
..##.#.#..#.##...#.###.###...######..#..#.#..#....###.#.#....#..........#...##.##.##.#..##..#.#####.
###.###.#..#.##..##.#..#..##.....##.....#..#######.#..#.#.#.####.###..###.#.#..#.##.##.####.###.####
#.#.#..#....########.#..#..#...##..#.##..#.#..##..####...##.....#.##.#.#...########..#.###.#..#.#.##
.##.....#...#.#...##.##....###...##..#.####...#..#.#..#..#.##..#.###.##.####.##..####.....##.#.....#
....####.#.##.#.##.#..##.#.######.##.####..#...####.#..###.#.#..#..##.#.#.....##.#####.#.####...#.#.
#..#####.#####.....##....######..##....#..#.#.###.#####.....##.##.####.#...##...#.##.#.#####.##.#...
##.####..###.#....#...#.#.#.#.###.#####.#.####..####...####......##..#..#..#.#.##...########....#...
.###.#.#.#.#..####.##.#..######..#.#.###.....#.#......#.#.#.#..####.##...##.#####.#.##..##..#..#.#..
.....###...#...#.####.###.#.#.#.#.....#....#.####.###.##.##.##.#######......#.####......#....##.....
##..#..#.#.##..#...#..##.##.##..###.#....##.##....####.#.##.###....#.##.#.#.##...##.###...#..#..####
...#.#..##..##.#...##.##...#.#......#.#.##..###....####.##...#.#.###.#..#..#.####..##..##..#####.###
.##.##..##########.##...#.##.####.#.#######.##.#.##.##..#...##....########.###..##.##.##.#..##.#.#.#
#####.#....#.##..#.....#......##.##..#.##.###..##.......###..##.#.###.##.###....####.#..#.###..#.#.#
.#...#..#.##....##....#...####....#...#..#...####...########.###.#..##.#.#.##..###..#.#.###.....##.#
##..##.....###......#..###.##.####.##.####.#.#....#..#...#..#.#..#.###.#...#...#..##.##...#..#######
.....##..###..##...#####.#.#.....###.#.#..####...#.#.#..#..####..##.#..###.####.#....##..###....#..#
#.#.##.#....#.#####.#....##...#...##...##....#.#.......#....#..#...###.###.#.####..####....#.##.#.#.
..##...##..###.#.#.##.#..#....#.#.....##.###.#.###.###.....#...#.#..#######.#####..#.###...##......#
#......###..#....#.#..#.###.##.#...##..###.####.#.#....#.##..#.###..##.#..#####..##.###.....#..###..
##.#.##..##.###.#..##.....#.##.....###....##.####.######.#...#..###....#.#...#.##.....###....#..#.#.
.##.#.#.#.##..#.#.#..##..#.###.####....#..###.######..####.#.....###.##..#...###.#..######.##.#.##..
...##.####.#..##.#####.##.#...##..#..#...#.#.#.#####...#....#..###...#..#....#.#.##.#.######.#..####
..#.#.#.#...#.######.#.....#..#.#..###....#.#.########...#....#.#.##..#...##...#.#..#.#.###....##...
#####..#..##..#..##..#..#.#.##.#....#####.####.##.#.###..##..##....#.....#.#####.#...#.#####.##.#.#.
#.#..#####...####.###.###.....####.###.....##...##...#..#..#######.#.##....##..####.....##...#..#..#
#.#.###.#.#..##..#....#.#...#.#.##.##..#.##.....##...#.#..##.......##.#.###..#####.#.##....#.##.....
...#.......#....#.#.####.#.###.###..#....#..##.#..####........#.##..#...#.#...###.#..#.#.#...#...#..
...##.#####.##.#.###.##.##.#.##..##.#.#.#.#.#.##.#..##...##.#.#..#..##.##.#####.#.###...#####..#..#.
#######.#..#..#....##.#.#..####.#..#..###...#..#.......###.#.#.####....#.###...#.#.###.#.#.#.#..###.
..##.##.#.##.###....###.##.#.###.#...#....#.####..###..###.#.#..#...##.#.#.#..##.###..###.#.##...###
######..######..##..##.#.#.##.##.#..##..#.#.#.##..#.#...#...#.#.#..######.#..#.#.######..#......##.#
#.#####.....#.......#########..###.##...#...##.#.#..#...#####...#...#..#.###.#..#.#...###.#.#.#...#.
#....##....###...##.##.#...##.........##.#.#..#.#.##.#.######.#####..#..###.###.#...#.#.##.######...
#.#...###.#.###.##.#.######.#######.###.##..#.#.#...######.##.####.##..#.#.#.#......##..##.........#
..###..##....#.....##...#.#.###.#.#.....##.#...###.####.#...#...##..##.#.#.####..###...######....#.#
..###.#.##.####.#..#.##....##..#####....#..##.##.#..#######...#.####...##.#.#.##.........#....#....#
.##.#...#.####..#.#...#.##..######.##..##.#.###.##..###.###....##..#.##.##..##.#...###.##.##.###....
#...###.###.#..#....#.......#..#.....###..#.###.##.##....#.####.#.####.##..##..#..#.....#....##.#.#.
.##.#..#..#.##.......#.####.#######.....#.##.##.#.....#.#..#....######.#..###.##.##.....#.####..##.#
###..#.###.#..####.....##....#..####....#.##.##..#...######.#########...#.#....##...###.#..#.##...#.
#..###..##..#.#.##.###.#.#.##...###.#...##.##..#.###....###..#.#...#.###..######.#..#.###..#..#..#.#
.#........##.#.###..###.#.#.##.....##.##.#.#...##..#.##....###..#.#.#.#.##....#.##..#.#...###...#...
####.####..#....#.#.#..#..##.......##.####...###.##..#.#.##.#..##..######.......##.#.##..#...#.....#
..#..#..###..##.##..######.#..###..###.#.##..##.#..#####.#.#.#.##..#.##..##.##......####.#..........
...##.##..###.#...###....#.#.#.#.....#.##.....##...#...#......####...##.##....##.#..#.####.#..###.#.
..#.....####.#.###.#####..#..###..#..#.#...#####...###.###....#.###..#...#..#..#.#..#.##..##.#.#....
..##.#####...###.###.........#....##.####.##..#.#..#.#...#...##.##.##..#.#.##.########......#####...
...###.#.#..#...#.###.###.......##.###.#..#.##########...#..#.#.#.##.#.###...######..#.#...###.##...
.#.#.#######.#..##.##..##...#...####...#..#####.#..##...###.#.#...#.##...#......#..##.####..#.....##
.##.##.#.#......#######..###.....##.#.##..###......#....####...#.###.#.##.#........#..#....##.....##
#...#.###.#.##...##.####....#...#.###..#.#.....#.#....#.#.#.##...#.#..#####.#.#..#..#..#....#...####
.....##...###......#####..##.##.##...##.#.#####..##...#.#.#.#.###...###.##.####..#.#..#.#..#.####.##
#..#..##.#.##.#.##.#.#.#..###....###.##.#.##.#...#.#..#...#....###.#..#.#.######.#...####..#..##.#.#
#..#.#..#...###.#..##.#...#...##.#......#...#..#..####..##.....#.###...#.#..#.#....#.#####.##.###...
###....#.#..#.#..###..#.##......#...#..#..##.#..###..##..#..#.####..#...########..##.#.##.#.#.#...#.
.#.#.##.##.###..#...#.#....#..#.##..#.#.#.#.##.##.#####...#........####..###..####.#####..#.##.#.##.
#+END_SRC
** test data
#+BEGIN_SRC text :padline no :tangle d18t.txt
.#.#.#
...##.
#....#
..#...
#.#..#
####..
#+END_SRC
** puzzle 1
#+BEGIN_SRC cpp :results output
  #include <stdio.h>

  #define SIZE 100

  int main() {
    FILE *f = fopen("d18.txt", "r");
    char line[256];

    char lights[SIZE][SIZE] = { 0 };

    int y = 0;
    while (fgets(line, 256, f) != NULL) {
      for (int x = 0; x < SIZE; x++) {
        switch (line[x]) {
        case '.': lights[x][y] = 0; break;
        case '#': lights[x][y] = 1; break;
        default: printf("bad char: %d (%c)", line[x], line[x]); return 0;
        }
      }
      y++;
    }

    char lights2[SIZE][SIZE];

    for (int i = 0; i < 100; i++) {

    for (int y = 0; y < SIZE; y++) {
      for (int x = 0; x < SIZE; x++) {
        int neighbors = 0;
        neighbors += (x > 0      && y > 0     ) ? lights[x-1][y-1] : 0;
        neighbors += (              y > 0     ) ? lights[x  ][y-1] : 0;
        neighbors += (x < SIZE-1 && y > 0     ) ? lights[x+1][y-1] : 0;
        neighbors += (x > 0                   ) ? lights[x-1][y  ] : 0;
        neighbors += (x < SIZE-1              ) ? lights[x+1][y  ] : 0;
        neighbors += (x > 0      && y < SIZE-1) ? lights[x-1][y+1] : 0;
        neighbors += (              y < SIZE-1) ? lights[x  ][y+1] : 0;
        neighbors += (x < SIZE-1 && y < SIZE-1) ? lights[x+1][y+1] : 0;
        if (lights[x][y])
          lights2[x][y] = (neighbors == 2 || neighbors == 3);
        else
          lights2[x][y] = (neighbors == 3);
      }
    }

    for (int y = 0; y < SIZE; y++) {
      for (int x = 0; x < SIZE; x++) {
        lights[x][y] = lights2[x][y];
      }
    }

    // for (int y = 0; y < SIZE; y++) {
    //   for (int x = 0; x < SIZE; x++) {
    //     printf("%c", lights[x][y] ? '#' : '.');
    //   }
    //   printf("\n");
    // }
    // printf("\n");

    }

    int ons = 0;
    for (int y = 0; y < SIZE; y++) {
      for (int x = 0; x < SIZE; x++) {
        ons += lights[x][y];
      }
    }


    printf("%d", ons);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 814

** puzzle 2
#+BEGIN_SRC cpp :results output
  #include <stdio.h>

  #define SIZE 100

  int main() {
    FILE *f = fopen("d18.txt", "r");
    char line[256];

    char lights[SIZE][SIZE] = { 0 };

    int y = 0;
    while (fgets(line, 256, f) != NULL) {
      for (int x = 0; x < SIZE; x++) {
        switch (line[x]) {
        case '.': lights[x][y] = 0; break;
        case '#': lights[x][y] = 1; break;
        default: printf("bad char: %d (%c)", line[x], line[x]); return 0;
        }
      }
      y++;
    }

    char lights2[SIZE][SIZE];

    for (int i = 0; i < 100; i++) {

    lights[0][0] = 1;
    lights[0][SIZE-1] = 1;
    lights[SIZE-1][0] = 1;
    lights[SIZE-1][SIZE-1] = 1;

    for (int y = 0; y < SIZE; y++) {
      for (int x = 0; x < SIZE; x++) {
        int neighbors = 0;
        neighbors += (x > 0      && y > 0     ) ? lights[x-1][y-1] : 0;
        neighbors += (              y > 0     ) ? lights[x  ][y-1] : 0;
        neighbors += (x < SIZE-1 && y > 0     ) ? lights[x+1][y-1] : 0;
        neighbors += (x > 0                   ) ? lights[x-1][y  ] : 0;
        neighbors += (x < SIZE-1              ) ? lights[x+1][y  ] : 0;
        neighbors += (x > 0      && y < SIZE-1) ? lights[x-1][y+1] : 0;
        neighbors += (              y < SIZE-1) ? lights[x  ][y+1] : 0;
        neighbors += (x < SIZE-1 && y < SIZE-1) ? lights[x+1][y+1] : 0;
        if (lights[x][y])
          lights2[x][y] = (neighbors == 2 || neighbors == 3);
        else
          lights2[x][y] = (neighbors == 3);
      }
    }

    for (int y = 0; y < SIZE; y++) {
      for (int x = 0; x < SIZE; x++) {
        lights[x][y] = lights2[x][y];
      }
    }


    // for (int y = 0; y < SIZE; y++) {
    //   for (int x = 0; x < SIZE; x++) {
    //     printf("%c", lights[x][y] ? '#' : '.');
    //   }
    //   printf("\n");
    // }
    // printf("\n");

    }

    lights[0][0] = 1;
    lights[0][SIZE-1] = 1;
    lights[SIZE-1][0] = 1;
    lights[SIZE-1][SIZE-1] = 1;

    int ons = 0;
    for (int y = 0; y < SIZE; y++) {
      for (int x = 0; x < SIZE; x++) {
        ons += lights[x][y];
      }
    }


    printf("%d", ons);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 924

 - 861 too low
 - 922 to low

* day 19
** text
--- Day 19: Medicine for Rudolph ---

Rudolph the Red-Nosed Reindeer is sick! His nose isn't shining very brightly, and he needs medicine.

Red-Nosed Reindeer biology isn't similar to regular reindeer biology; Rudolph is going to need custom-made medicine. Unfortunately, Red-Nosed Reindeer chemistry isn't similar to regular reindeer chemistry, either.

The North Pole is equipped with a Red-Nosed Reindeer nuclear fusion/fission plant, capable of constructing any Red-Nosed Reindeer molecule you need. It works by starting with some input molecule and then doing a series of replacements, one per step, until it has the right molecule.

However, the machine has to be calibrated before it can be used. Calibration involves determining the number of molecules that can be generated in one step from a given starting point.

For example, imagine a simpler machine that supports only the following replacements:

H => HO
H => OH
O => HH

Given the replacements above and starting with HOH, the following molecules could be generated:

    HOOH (via H => HO on the first H).
    HOHO (via H => HO on the second H).
    OHOH (via H => OH on the first H).
    HOOH (via H => OH on the second H).
    HHHH (via O => HH).

So, in the example above, there are 4 distinct molecules (not five, because HOOH appears twice) after one replacement from HOH. Santa's favorite molecule, HOHOHO, can become 7 distinct molecules (over nine replacements: six from H, and three from O).

The machine replaces without regard for the surrounding characters. For example, given the string H2O, the transition H => OO would result in OO2O.

Your puzzle input describes all of the possible replacements and, at the bottom, the medicine molecule for which you need to calibrate the machine. How many distinct molecules can be created after all the different ways you can do one replacement on the medicine molecule?

Your puzzle answer was 576.
--- Part Two ---

Now that the machine is calibrated, you're ready to begin molecule fabrication.

Molecule fabrication always begins with just a single electron, e, and applying replacements one at a time, just like the ones during calibration.

For example, suppose you have the following replacements:

e => H
e => O
H => HO
H => OH
O => HH

If you'd like to make HOH, you start with e, and then make the following replacements:

    e => O to get O
    O => HH to get HH
    H => OH (on the second H) to get HOH

So, you could make HOH after 3 steps. Santa's favorite molecule, HOHOHO, can be made in 6 steps.

How long will it take to make the medicine? Given the available replacements and the medicine molecule in your puzzle input, what is the fewest number of steps to go from e to the medicine molecule?

Your puzzle answer was 207.
** data
#+BEGIN_SRC text :padline no :tangle d19.txt
Al => ThF
Al => ThRnFAr
B => BCa
B => TiB
B => TiRnFAr
Ca => CaCa
Ca => PB
Ca => PRnFAr
Ca => SiRnFYFAr
Ca => SiRnMgAr
Ca => SiTh
F => CaF
F => PMg
F => SiAl
H => CRnAlAr
H => CRnFYFYFAr
H => CRnFYMgAr
H => CRnMgYFAr
H => HCa
H => NRnFYFAr
H => NRnMgAr
H => NTh
H => OB
H => ORnFAr
Mg => BF
Mg => TiMg
N => CRnFAr
N => HSi
O => CRnFYFAr
O => CRnMgAr
O => HP
O => NRnFAr
O => OTi
P => CaP
P => PTi
P => SiRnFAr
Si => CaSi
Th => ThCa
Ti => BP
Ti => TiTi
e => HF
e => NAl
e => OMg

ORnPBPMgArCaCaCaSiThCaCaSiThCaCaPBSiRnFArRnFArCaCaSiThCaCaSiThCaCaCaCaCaCaSiRnFYFArSiRnMgArCaSiRnPTiTiBFYPBFArSiRnCaSiRnTiRnFArSiAlArPTiBPTiRnCaSiAlArCaPTiTiBPMgYFArPTiRnFArSiRnCaCaFArRnCaFArCaSiRnSiRnMgArFYCaSiRnMgArCaCaSiThPRnFArPBCaSiRnMgArCaCaSiThCaSiRnTiMgArFArSiThSiThCaCaSiRnMgArCaCaSiRnFArTiBPTiRnCaSiAlArCaPTiRnFArPBPBCaCaSiThCaPBSiThPRnFArSiThCaSiThCaSiThCaPTiBSiRnFYFArCaCaPRnFArPBCaCaPBSiRnTiRnFArCaPRnFArSiRnCaCaCaSiThCaRnCaFArYCaSiRnFArBCaCaCaSiThFArPBFArCaSiRnFArRnCaCaCaFArSiRnFArTiRnPMgArF
#+END_SRC
** test data
#+BEGIN_SRC text :padline no :tangle d19t.txt
H => HO
H => OH
O => HH

HOHOHO
#+END_SRC
** test data2
#+BEGIN_SRC text :padline no :tangle d19t2.txt
HH => OO

HHOHH
#+END_SRC
** test data3
#+BEGIN_SRC text :padline no :tangle d19t3.txt
e => H
e => O
H => HO
H => OH
O => HH

HOH
#+END_SRC
** puzzle 1
#+BEGIN_SRC cpp :results output :tangle d19p1.c
  #include <stdio.h>
  #include <string.h>

  #define DIFFSIZE 1024

  typedef struct repl_t {
    char from[5];
    char to[64];
  } repl_t;

  typedef struct diff_t {
    int start, end;
    char diff[64];
  } diff_t;

  int main() {
    FILE *f = fopen("d19.txt", "r");
    char line[1024];

    repl_t repls[64] = { 0 };
    int replslen = 0;

    while (fgets(line, 1024, f) != NULL) {
      if (line[0] == '\n')
        break;
      sscanf(line, "%s => %s", repls[replslen].from, repls[replslen].to);
      replslen++;
    }

    char molecule[1024];
    fgets(molecule, 1024, f);
    int moleculelen = strlen(molecule) - 1;
    molecule[moleculelen] = '\0';

    for (int i = 0; i < replslen; i++) {
      printf("## '%s' -> '%s'\n", repls[i].from, repls[i].to);
    }
    printf("## '%s'\n", molecule);

    diff_t diffs[DIFFSIZE] = { 0 };
    int diffslen = 0;

    for (int i = 0; i < replslen; i++) {
      int matchi = 0;
      int matchlen = strlen(repls[i].from);
      for (int j = 0; j < moleculelen; j++) {
        if (molecule[j] == repls[i].from[matchi]) {
          matchi++;
        } else {
          matchi = 0;
        }
        if (matchi == matchlen) {
          diffs[diffslen].start = j;
          diffs[diffslen].end = j + matchlen;
          strcpy(diffs[diffslen].diff, repls[i].to);
          diffslen++;
          matchi = 0;
          if (diffslen == DIFFSIZE) {
            printf("DIFFSIZE too small\n");
            return 0;
          }
        }
      }
    }

    for (int i = 0; i < diffslen; i++) {
      printf("### %d..%d -> '%s'\n", diffs[i].start, diffs[i].end, diffs[i].diff);
    }

    printf("foo");
    return 0;
  }
#+END_SRC

#+RESULTS:
#+begin_example
## 'Al' -> 'ThF'
## 'Al' -> 'ThRnFAr'
## 'B' -> 'BCa'
## 'B' -> 'TiB'
## 'B' -> 'TiRnFAr'
## 'Ca' -> 'CaCa'
## 'Ca' -> 'PB'
## 'Ca' -> 'PRnFAr'
## 'Ca' -> 'SiRnFYFAr'
## 'Ca' -> 'SiRnMgAr'
## 'Ca' -> 'SiTh'
## 'F' -> 'CaF'
## 'F' -> 'PMg'
## 'F' -> 'SiAl'
## 'H' -> 'CRnAlAr'
## 'H' -> 'CRnFYFYFAr'
## 'H' -> 'CRnFYMgAr'
## 'H' -> 'CRnMgYFAr'
## 'H' -> 'HCa'
## 'H' -> 'NRnFYFAr'
## 'H' -> 'NRnMgAr'
## 'H' -> 'NTh'
## 'H' -> 'OB'
## 'H' -> 'ORnFAr'
## 'Mg' -> 'BF'
## 'Mg' -> 'TiMg'
## 'N' -> 'CRnFAr'
## 'N' -> 'HSi'
## 'O' -> 'CRnFYFAr'
## 'O' -> 'CRnMgAr'
## 'O' -> 'HP'
## 'O' -> 'NRnFAr'
## 'O' -> 'OTi'
## 'P' -> 'CaP'
## 'P' -> 'PTi'
## 'P' -> 'SiRnFAr'
## 'Si' -> 'CaSi'
## 'Th' -> 'ThCa'
## 'Ti' -> 'BP'
## 'Ti' -> 'TiTi'
## 'e' -> 'HF'
## 'e' -> 'NAl'
## 'e' -> 'OMg'
## 'ORnPBPMgArCaCaCaSiThCaCaSiThCaCaPBSiRnFArRnFArCaCaSiThCaCaSiThCaCaCaCaCaCaSiRnFYFArSiRnMgArCaSiRnPTiTiBFYPBFArSiRnCaSiRnTiRnFArSiAlArPTiBPTiRnCaSiAlArCaPTiTiBPMgYFArPTiRnFArSiRnCaCaFArRnCaFArCaSiRnSiRnMgArFYCaSiRnMgArCaCaSiThPRnFArPBCaSiRnMgArCaCaSiThCaSiRnTiMgArFArSiThSiThCaCaSiRnMgArCaCaSiRnFArTiBPTiRnCaSiAlArCaPTiRnFArPBPBCaCaSiThCaPBSiThPRnFArSiThCaSiThCaSiThCaPTiBSiRnFYFArCaCaPRnFArPBCaCaPBSiRnTiRnFArCaPRnFArSiRnCaCaCaSiThCaRnCaFArYCaSiRnFArBCaCaCaSiThFArPBFArCaSiRnFArRnCaCaCaFArSiRnFArTiRnPMgArF'
### 130..132 -> 'ThF'
### 147..149 -> 'ThF'
### 310..312 -> 'ThF'
### 130..132 -> 'ThRnFAr'
### 147..149 -> 'ThRnFAr'
### 310..312 -> 'ThRnFAr'
### 4..5 -> 'BCa'
### 33..34 -> 'BCa'
### 102..103 -> 'BCa'
### 106..107 -> 'BCa'
### 136..137 -> 'BCa'
### 157..158 -> 'BCa'
### 232..233 -> 'BCa'
### 299..300 -> 'BCa'
### 324..325 -> 'BCa'
### 326..327 -> 'BCa'
### 338..339 -> 'BCa'
### 370..371 -> 'BCa'
### 391..392 -> 'BCa'
### 397..398 -> 'BCa'
### 450..451 -> 'BCa'
### 465..466 -> 'BCa'
### 4..5 -> 'TiB'
### 33..34 -> 'TiB'
### 102..103 -> 'TiB'
### 106..107 -> 'TiB'
### 136..137 -> 'TiB'
### 157..158 -> 'TiB'
### 232..233 -> 'TiB'
### 299..300 -> 'TiB'
### 324..325 -> 'TiB'
### 326..327 -> 'TiB'
### 338..339 -> 'TiB'
### 370..371 -> 'TiB'
### 391..392 -> 'TiB'
### 397..398 -> 'TiB'
### 450..451 -> 'TiB'
### 465..466 -> 'TiB'
### 4..5 -> 'TiRnFAr'
### 33..34 -> 'TiRnFAr'
### 102..103 -> 'TiRnFAr'
### 106..107 -> 'TiRnFAr'
### 136..137 -> 'TiRnFAr'
### 157..158 -> 'TiRnFAr'
### 232..233 -> 'TiRnFAr'
### 299..300 -> 'TiRnFAr'
### 324..325 -> 'TiRnFAr'
### 326..327 -> 'TiRnFAr'
### 338..339 -> 'TiRnFAr'
### 370..371 -> 'TiRnFAr'
### 391..392 -> 'TiRnFAr'
### 397..398 -> 'TiRnFAr'
### 450..451 -> 'TiRnFAr'
### 465..466 -> 'TiRnFAr'
### 11..13 -> 'CaCa'
### 13..15 -> 'CaCa'
### 15..17 -> 'CaCa'
### 21..23 -> 'CaCa'
### 23..25 -> 'CaCa'
### 29..31 -> 'CaCa'
### 31..33 -> 'CaCa'
### 47..49 -> 'CaCa'
### 49..51 -> 'CaCa'
### 55..57 -> 'CaCa'
### 57..59 -> 'CaCa'
### 63..65 -> 'CaCa'
### 65..67 -> 'CaCa'
### 67..69 -> 'CaCa'
### 69..71 -> 'CaCa'
### 71..73 -> 'CaCa'
### 73..75 -> 'CaCa'
### 92..94 -> 'CaCa'
### 115..117 -> 'CaCa'
### 143..145 -> 'CaCa'
### 151..153 -> 'CaCa'
### 178..180 -> 'CaCa'
### 180..182 -> 'CaCa'
### 187..189 -> 'CaCa'
### 192..194 -> 'CaCa'
### 208..210 -> 'CaCa'
### 218..220 -> 'CaCa'
### 220..222 -> 'CaCa'
### 234..236 -> 'CaCa'
### 244..246 -> 'CaCa'
### 246..248 -> 'CaCa'
### 252..254 -> 'CaCa'
### 275..277 -> 'CaCa'
### 277..279 -> 'CaCa'
### 287..289 -> 'CaCa'
### 289..291 -> 'CaCa'
### 306..308 -> 'CaCa'
### 314..316 -> 'CaCa'
### 328..330 -> 'CaCa'
### 330..332 -> 'CaCa'
### 336..338 -> 'CaCa'
### 354..356 -> 'CaCa'
### 360..362 -> 'CaCa'
### 366..368 -> 'CaCa'
### 381..383 -> 'CaCa'
### 383..385 -> 'CaCa'
### 393..395 -> 'CaCa'
### 395..397 -> 'CaCa'
### 410..412 -> 'CaCa'
### 422..424 -> 'CaCa'
### 424..426 -> 'CaCa'
### 426..428 -> 'CaCa'
### 432..434 -> 'CaCa'
### 436..438 -> 'CaCa'
### 442..444 -> 'CaCa'
### 452..454 -> 'CaCa'
### 454..456 -> 'CaCa'
### 456..458 -> 'CaCa'
### 470..472 -> 'CaCa'
### 481..483 -> 'CaCa'
### 483..485 -> 'CaCa'
### 485..487 -> 'CaCa'
### 11..13 -> 'PB'
### 13..15 -> 'PB'
### 15..17 -> 'PB'
### 21..23 -> 'PB'
### 23..25 -> 'PB'
### 29..31 -> 'PB'
### 31..33 -> 'PB'
### 47..49 -> 'PB'
### 49..51 -> 'PB'
### 55..57 -> 'PB'
### 57..59 -> 'PB'
### 63..65 -> 'PB'
### 65..67 -> 'PB'
### 67..69 -> 'PB'
### 69..71 -> 'PB'
### 71..73 -> 'PB'
### 73..75 -> 'PB'
### 92..94 -> 'PB'
### 115..117 -> 'PB'
### 143..145 -> 'PB'
### 151..153 -> 'PB'
### 178..180 -> 'PB'
### 180..182 -> 'PB'
### 187..189 -> 'PB'
### 192..194 -> 'PB'
### 208..210 -> 'PB'
### 218..220 -> 'PB'
### 220..222 -> 'PB'
### 234..236 -> 'PB'
### 244..246 -> 'PB'
### 246..248 -> 'PB'
### 252..254 -> 'PB'
### 275..277 -> 'PB'
### 277..279 -> 'PB'
### 287..289 -> 'PB'
### 289..291 -> 'PB'
### 306..308 -> 'PB'
### 314..316 -> 'PB'
### 328..330 -> 'PB'
### 330..332 -> 'PB'
### 336..338 -> 'PB'
### 354..356 -> 'PB'
### 360..362 -> 'PB'
### 366..368 -> 'PB'
### 381..383 -> 'PB'
### 383..385 -> 'PB'
### 393..395 -> 'PB'
### 395..397 -> 'PB'
### 410..412 -> 'PB'
### 422..424 -> 'PB'
### 424..426 -> 'PB'
### 426..428 -> 'PB'
### 432..434 -> 'PB'
### 436..438 -> 'PB'
### 442..444 -> 'PB'
### 452..454 -> 'PB'
### 454..456 -> 'PB'
### 456..458 -> 'PB'
### 470..472 -> 'PB'
### 481..483 -> 'PB'
### 483..485 -> 'PB'
### 485..487 -> 'PB'
### 11..13 -> 'PRnFAr'
### 13..15 -> 'PRnFAr'
### 15..17 -> 'PRnFAr'
### 21..23 -> 'PRnFAr'
### 23..25 -> 'PRnFAr'
### 29..31 -> 'PRnFAr'
### 31..33 -> 'PRnFAr'
### 47..49 -> 'PRnFAr'
### 49..51 -> 'PRnFAr'
### 55..57 -> 'PRnFAr'
### 57..59 -> 'PRnFAr'
### 63..65 -> 'PRnFAr'
### 65..67 -> 'PRnFAr'
### 67..69 -> 'PRnFAr'
### 69..71 -> 'PRnFAr'
### 71..73 -> 'PRnFAr'
### 73..75 -> 'PRnFAr'
### 92..94 -> 'PRnFAr'
### 115..117 -> 'PRnFAr'
### 143..145 -> 'PRnFAr'
### 151..153 -> 'PRnFAr'
### 178..180 -> 'PRnFAr'
### 180..182 -> 'PRnFAr'
### 187..189 -> 'PRnFAr'
### 192..194 -> 'PRnFAr'
### 208..210 -> 'PRnFAr'
### 218..220 -> 'PRnFAr'
### 220..222 -> 'PRnFAr'
### 234..236 -> 'PRnFAr'
### 244..246 -> 'PRnFAr'
### 246..248 -> 'PRnFAr'
### 252..254 -> 'PRnFAr'
### 275..277 -> 'PRnFAr'
### 277..279 -> 'PRnFAr'
### 287..289 -> 'PRnFAr'
### 289..291 -> 'PRnFAr'
### 306..308 -> 'PRnFAr'
### 314..316 -> 'PRnFAr'
### 328..330 -> 'PRnFAr'
### 330..332 -> 'PRnFAr'
### 336..338 -> 'PRnFAr'
### 354..356 -> 'PRnFAr'
### 360..362 -> 'PRnFAr'
### 366..368 -> 'PRnFAr'
### 381..383 -> 'PRnFAr'
### 383..385 -> 'PRnFAr'
### 393..395 -> 'PRnFAr'
### 395..397 -> 'PRnFAr'
### 410..412 -> 'PRnFAr'
### 422..424 -> 'PRnFAr'
### 424..426 -> 'PRnFAr'
### 426..428 -> 'PRnFAr'
### 432..434 -> 'PRnFAr'
### 436..438 -> 'PRnFAr'
### 442..444 -> 'PRnFAr'
### 452..454 -> 'PRnFAr'
### 454..456 -> 'PRnFAr'
### 456..458 -> 'PRnFAr'
### 470..472 -> 'PRnFAr'
### 481..483 -> 'PRnFAr'
### 483..485 -> 'PRnFAr'
### 485..487 -> 'PRnFAr'
### 11..13 -> 'SiRnFYFAr'
### 13..15 -> 'SiRnFYFAr'
### 15..17 -> 'SiRnFYFAr'
### 21..23 -> 'SiRnFYFAr'
### 23..25 -> 'SiRnFYFAr'
### 29..31 -> 'SiRnFYFAr'
### 31..33 -> 'SiRnFYFAr'
### 47..49 -> 'SiRnFYFAr'
### 49..51 -> 'SiRnFYFAr'
### 55..57 -> 'SiRnFYFAr'
### 57..59 -> 'SiRnFYFAr'
### 63..65 -> 'SiRnFYFAr'
### 65..67 -> 'SiRnFYFAr'
### 67..69 -> 'SiRnFYFAr'
### 69..71 -> 'SiRnFYFAr'
### 71..73 -> 'SiRnFYFAr'
### 73..75 -> 'SiRnFYFAr'
### 92..94 -> 'SiRnFYFAr'
### 115..117 -> 'SiRnFYFAr'
### 143..145 -> 'SiRnFYFAr'
### 151..153 -> 'SiRnFYFAr'
### 178..180 -> 'SiRnFYFAr'
### 180..182 -> 'SiRnFYFAr'
### 187..189 -> 'SiRnFYFAr'
### 192..194 -> 'SiRnFYFAr'
### 208..210 -> 'SiRnFYFAr'
### 218..220 -> 'SiRnFYFAr'
### 220..222 -> 'SiRnFYFAr'
### 234..236 -> 'SiRnFYFAr'
### 244..246 -> 'SiRnFYFAr'
### 246..248 -> 'SiRnFYFAr'
### 252..254 -> 'SiRnFYFAr'
### 275..277 -> 'SiRnFYFAr'
### 277..279 -> 'SiRnFYFAr'
### 287..289 -> 'SiRnFYFAr'
### 289..291 -> 'SiRnFYFAr'
### 306..308 -> 'SiRnFYFAr'
### 314..316 -> 'SiRnFYFAr'
### 328..330 -> 'SiRnFYFAr'
### 330..332 -> 'SiRnFYFAr'
### 336..338 -> 'SiRnFYFAr'
### 354..356 -> 'SiRnFYFAr'
### 360..362 -> 'SiRnFYFAr'
### 366..368 -> 'SiRnFYFAr'
### 381..383 -> 'SiRnFYFAr'
### 383..385 -> 'SiRnFYFAr'
### 393..395 -> 'SiRnFYFAr'
### 395..397 -> 'SiRnFYFAr'
### 410..412 -> 'SiRnFYFAr'
### 422..424 -> 'SiRnFYFAr'
### 424..426 -> 'SiRnFYFAr'
### 426..428 -> 'SiRnFYFAr'
### 432..434 -> 'SiRnFYFAr'
### 436..438 -> 'SiRnFYFAr'
### 442..444 -> 'SiRnFYFAr'
### 452..454 -> 'SiRnFYFAr'
### 454..456 -> 'SiRnFYFAr'
### 456..458 -> 'SiRnFYFAr'
### 470..472 -> 'SiRnFYFAr'
### 481..483 -> 'SiRnFYFAr'
### 483..485 -> 'SiRnFYFAr'
### 485..487 -> 'SiRnFYFAr'
### 11..13 -> 'SiRnMgAr'
### 13..15 -> 'SiRnMgAr'
### 15..17 -> 'SiRnMgAr'
### 21..23 -> 'SiRnMgAr'
### 23..25 -> 'SiRnMgAr'
### 29..31 -> 'SiRnMgAr'
### 31..33 -> 'SiRnMgAr'
### 47..49 -> 'SiRnMgAr'
### 49..51 -> 'SiRnMgAr'
### 55..57 -> 'SiRnMgAr'
### 57..59 -> 'SiRnMgAr'
### 63..65 -> 'SiRnMgAr'
### 65..67 -> 'SiRnMgAr'
### 67..69 -> 'SiRnMgAr'
### 69..71 -> 'SiRnMgAr'
### 71..73 -> 'SiRnMgAr'
### 73..75 -> 'SiRnMgAr'
### 92..94 -> 'SiRnMgAr'
### 115..117 -> 'SiRnMgAr'
### 143..145 -> 'SiRnMgAr'
### 151..153 -> 'SiRnMgAr'
### 178..180 -> 'SiRnMgAr'
### 180..182 -> 'SiRnMgAr'
### 187..189 -> 'SiRnMgAr'
### 192..194 -> 'SiRnMgAr'
### 208..210 -> 'SiRnMgAr'
### 218..220 -> 'SiRnMgAr'
### 220..222 -> 'SiRnMgAr'
### 234..236 -> 'SiRnMgAr'
### 244..246 -> 'SiRnMgAr'
### 246..248 -> 'SiRnMgAr'
### 252..254 -> 'SiRnMgAr'
### 275..277 -> 'SiRnMgAr'
### 277..279 -> 'SiRnMgAr'
### 287..289 -> 'SiRnMgAr'
### 289..291 -> 'SiRnMgAr'
### 306..308 -> 'SiRnMgAr'
### 314..316 -> 'SiRnMgAr'
### 328..330 -> 'SiRnMgAr'
### 330..332 -> 'SiRnMgAr'
### 336..338 -> 'SiRnMgAr'
### 354..356 -> 'SiRnMgAr'
### 360..362 -> 'SiRnMgAr'
### 366..368 -> 'SiRnMgAr'
### 381..383 -> 'SiRnMgAr'
### 383..385 -> 'SiRnMgAr'
### 393..395 -> 'SiRnMgAr'
### 395..397 -> 'SiRnMgAr'
### 410..412 -> 'SiRnMgAr'
### 422..424 -> 'SiRnMgAr'
### 424..426 -> 'SiRnMgAr'
### 426..428 -> 'SiRnMgAr'
### 432..434 -> 'SiRnMgAr'
### 436..438 -> 'SiRnMgAr'
### 442..444 -> 'SiRnMgAr'
### 452..454 -> 'SiRnMgAr'
### 454..456 -> 'SiRnMgAr'
### 456..458 -> 'SiRnMgAr'
### 470..472 -> 'SiRnMgAr'
### 481..483 -> 'SiRnMgAr'
### 483..485 -> 'SiRnMgAr'
### 485..487 -> 'SiRnMgAr'
### 11..13 -> 'SiTh'
### 13..15 -> 'SiTh'
### 15..17 -> 'SiTh'
### 21..23 -> 'SiTh'
### 23..25 -> 'SiTh'
### 29..31 -> 'SiTh'
### 31..33 -> 'SiTh'
### 47..49 -> 'SiTh'
### 49..51 -> 'SiTh'
### 55..57 -> 'SiTh'
### 57..59 -> 'SiTh'
### 63..65 -> 'SiTh'
### 65..67 -> 'SiTh'
### 67..69 -> 'SiTh'
### 69..71 -> 'SiTh'
### 71..73 -> 'SiTh'
### 73..75 -> 'SiTh'
### 92..94 -> 'SiTh'
### 115..117 -> 'SiTh'
### 143..145 -> 'SiTh'
### 151..153 -> 'SiTh'
### 178..180 -> 'SiTh'
### 180..182 -> 'SiTh'
### 187..189 -> 'SiTh'
### 192..194 -> 'SiTh'
### 208..210 -> 'SiTh'
### 218..220 -> 'SiTh'
### 220..222 -> 'SiTh'
### 234..236 -> 'SiTh'
### 244..246 -> 'SiTh'
### 246..248 -> 'SiTh'
### 252..254 -> 'SiTh'
### 275..277 -> 'SiTh'
### 277..279 -> 'SiTh'
### 287..289 -> 'SiTh'
### 289..291 -> 'SiTh'
### 306..308 -> 'SiTh'
### 314..316 -> 'SiTh'
### 328..330 -> 'SiTh'
### 330..332 -> 'SiTh'
### 336..338 -> 'SiTh'
### 354..356 -> 'SiTh'
### 360..362 -> 'SiTh'
### 366..368 -> 'SiTh'
### 381..383 -> 'SiTh'
### 383..385 -> 'SiTh'
### 393..395 -> 'SiTh'
### 395..397 -> 'SiTh'
### 410..412 -> 'SiTh'
### 422..424 -> 'SiTh'
### 424..426 -> 'SiTh'
### 426..428 -> 'SiTh'
### 432..434 -> 'SiTh'
### 436..438 -> 'SiTh'
### 442..444 -> 'SiTh'
### 452..454 -> 'SiTh'
### 454..456 -> 'SiTh'
### 456..458 -> 'SiTh'
### 470..472 -> 'SiTh'
### 481..483 -> 'SiTh'
### 483..485 -> 'SiTh'
### 485..487 -> 'SiTh'
### 38..39 -> 'CaF'
### 43..44 -> 'CaF'
### 78..79 -> 'CaF'
### 80..81 -> 'CaF'
### 103..104 -> 'CaF'
### 107..108 -> 'CaF'
### 124..125 -> 'CaF'
### 162..163 -> 'CaF'
### 170..171 -> 'CaF'
### 181..182 -> 'CaF'
### 188..189 -> 'CaF'
### 205..206 -> 'CaF'
### 228..229 -> 'CaF'
### 263..264 -> 'CaF'
### 294..295 -> 'CaF'
### 320..321 -> 'CaF'
### 346..347 -> 'CaF'
### 375..376 -> 'CaF'
### 377..378 -> 'CaF'
### 387..388 -> 'CaF'
### 406..407 -> 'CaF'
### 414..415 -> 'CaF'
### 437..438 -> 'CaF'
### 447..448 -> 'CaF'
### 461..462 -> 'CaF'
### 466..467 -> 'CaF'
### 475..476 -> 'CaF'
### 486..487 -> 'CaF'
### 493..494 -> 'CaF'
### 505..506 -> 'CaF'
### 38..39 -> 'PMg'
### 43..44 -> 'PMg'
### 78..79 -> 'PMg'
### 80..81 -> 'PMg'
### 103..104 -> 'PMg'
### 107..108 -> 'PMg'
### 124..125 -> 'PMg'
### 162..163 -> 'PMg'
### 170..171 -> 'PMg'
### 181..182 -> 'PMg'
### 188..189 -> 'PMg'
### 205..206 -> 'PMg'
### 228..229 -> 'PMg'
### 263..264 -> 'PMg'
### 294..295 -> 'PMg'
### 320..321 -> 'PMg'
### 346..347 -> 'PMg'
### 375..376 -> 'PMg'
### 377..378 -> 'PMg'
### 387..388 -> 'PMg'
### 406..407 -> 'PMg'
### 414..415 -> 'PMg'
### 437..438 -> 'PMg'
### 447..448 -> 'PMg'
### 461..462 -> 'PMg'
### 466..467 -> 'PMg'
### 475..476 -> 'PMg'
### 486..487 -> 'PMg'
### 493..494 -> 'PMg'
### 505..506 -> 'PMg'
### 38..39 -> 'SiAl'
### 43..44 -> 'SiAl'
### 78..79 -> 'SiAl'
### 80..81 -> 'SiAl'
### 103..104 -> 'SiAl'
### 107..108 -> 'SiAl'
### 124..125 -> 'SiAl'
### 162..163 -> 'SiAl'
### 170..171 -> 'SiAl'
### 181..182 -> 'SiAl'
### 188..189 -> 'SiAl'
### 205..206 -> 'SiAl'
### 228..229 -> 'SiAl'
### 263..264 -> 'SiAl'
### 294..295 -> 'SiAl'
### 320..321 -> 'SiAl'
### 346..347 -> 'SiAl'
### 375..376 -> 'SiAl'
### 377..378 -> 'SiAl'
### 387..388 -> 'SiAl'
### 406..407 -> 'SiAl'
### 414..415 -> 'SiAl'
### 437..438 -> 'SiAl'
### 447..448 -> 'SiAl'
### 461..462 -> 'SiAl'
### 466..467 -> 'SiAl'
### 475..476 -> 'SiAl'
### 486..487 -> 'SiAl'
### 493..494 -> 'SiAl'
### 505..506 -> 'SiAl'
### 7..9 -> 'BF'
### 88..90 -> 'BF'
### 160..162 -> 'BF'
### 202..204 -> 'BF'
### 214..216 -> 'BF'
### 240..242 -> 'BF'
### 260..262 -> 'BF'
### 283..285 -> 'BF'
### 502..504 -> 'BF'
### 7..9 -> 'TiMg'
### 88..90 -> 'TiMg'
### 160..162 -> 'TiMg'
### 202..204 -> 'TiMg'
### 214..216 -> 'TiMg'
### 240..242 -> 'TiMg'
### 260..262 -> 'TiMg'
### 283..285 -> 'TiMg'
### 502..504 -> 'TiMg'
### 0..1 -> 'CRnFYFAr'
### 0..1 -> 'CRnMgAr'
### 0..1 -> 'HP'
### 0..1 -> 'NRnFAr'
### 0..1 -> 'OTi'
### 3..4 -> 'CaP'
### 5..6 -> 'CaP'
### 32..33 -> 'CaP'
### 97..98 -> 'CaP'
### 105..106 -> 'CaP'
### 133..134 -> 'CaP'
### 137..138 -> 'CaP'
### 152..153 -> 'CaP'
### 158..159 -> 'CaP'
### 165..166 -> 'CaP'
### 225..226 -> 'CaP'
### 231..232 -> 'CaP'
### 300..301 -> 'CaP'
### 315..316 -> 'CaP'
### 323..324 -> 'CaP'
### 325..326 -> 'CaP'
### 337..338 -> 'CaP'
### 343..344 -> 'CaP'
### 367..368 -> 'CaP'
### 384..385 -> 'CaP'
### 390..391 -> 'CaP'
### 396..397 -> 'CaP'
### 411..412 -> 'CaP'
### 464..465 -> 'CaP'
### 500..501 -> 'CaP'
### 3..4 -> 'PTi'
### 5..6 -> 'PTi'
### 32..33 -> 'PTi'
### 97..98 -> 'PTi'
### 105..106 -> 'PTi'
### 133..134 -> 'PTi'
### 137..138 -> 'PTi'
### 152..153 -> 'PTi'
### 158..159 -> 'PTi'
### 165..166 -> 'PTi'
### 225..226 -> 'PTi'
### 231..232 -> 'PTi'
### 300..301 -> 'PTi'
### 315..316 -> 'PTi'
### 323..324 -> 'PTi'
### 325..326 -> 'PTi'
### 337..338 -> 'PTi'
### 343..344 -> 'PTi'
### 367..368 -> 'PTi'
### 384..385 -> 'PTi'
### 390..391 -> 'PTi'
### 396..397 -> 'PTi'
### 411..412 -> 'PTi'
### 464..465 -> 'PTi'
### 500..501 -> 'PTi'
### 3..4 -> 'SiRnFAr'
### 5..6 -> 'SiRnFAr'
### 32..33 -> 'SiRnFAr'
### 97..98 -> 'SiRnFAr'
### 105..106 -> 'SiRnFAr'
### 133..134 -> 'SiRnFAr'
### 137..138 -> 'SiRnFAr'
### 152..153 -> 'SiRnFAr'
### 158..159 -> 'SiRnFAr'
### 165..166 -> 'SiRnFAr'
### 225..226 -> 'SiRnFAr'
### 231..232 -> 'SiRnFAr'
### 300..301 -> 'SiRnFAr'
### 315..316 -> 'SiRnFAr'
### 323..324 -> 'SiRnFAr'
### 325..326 -> 'SiRnFAr'
### 337..338 -> 'SiRnFAr'
### 343..344 -> 'SiRnFAr'
### 367..368 -> 'SiRnFAr'
### 384..385 -> 'SiRnFAr'
### 390..391 -> 'SiRnFAr'
### 396..397 -> 'SiRnFAr'
### 411..412 -> 'SiRnFAr'
### 464..465 -> 'SiRnFAr'
### 500..501 -> 'SiRnFAr'
### 17..19 -> 'CaSi'
### 25..27 -> 'CaSi'
### 35..37 -> 'CaSi'
### 51..53 -> 'CaSi'
### 59..61 -> 'CaSi'
### 75..77 -> 'CaSi'
### 84..86 -> 'CaSi'
### 94..96 -> 'CaSi'
### 111..113 -> 'CaSi'
### 117..119 -> 'CaSi'
### 128..130 -> 'CaSi'
### 145..147 -> 'CaSi'
### 174..176 -> 'CaSi'
### 194..196 -> 'CaSi'
### 198..200 -> 'CaSi'
### 210..212 -> 'CaSi'
### 222..224 -> 'CaSi'
### 236..238 -> 'CaSi'
### 248..250 -> 'CaSi'
### 254..256 -> 'CaSi'
### 267..269 -> 'CaSi'
### 271..273 -> 'CaSi'
### 279..281 -> 'CaSi'
### 291..293 -> 'CaSi'
### 308..310 -> 'CaSi'
### 332..334 -> 'CaSi'
### 340..342 -> 'CaSi'
### 350..352 -> 'CaSi'
### 356..358 -> 'CaSi'
### 362..364 -> 'CaSi'
### 372..374 -> 'CaSi'
### 399..401 -> 'CaSi'
### 418..420 -> 'CaSi'
### 428..430 -> 'CaSi'
### 444..446 -> 'CaSi'
### 458..460 -> 'CaSi'
### 472..474 -> 'CaSi'
### 490..492 -> 'CaSi'
### 19..21 -> 'ThCa'
### 27..29 -> 'ThCa'
### 53..55 -> 'ThCa'
### 61..63 -> 'ThCa'
### 224..226 -> 'ThCa'
### 250..252 -> 'ThCa'
### 269..271 -> 'ThCa'
### 273..275 -> 'ThCa'
### 334..336 -> 'ThCa'
### 342..344 -> 'ThCa'
### 352..354 -> 'ThCa'
### 358..360 -> 'ThCa'
### 364..366 -> 'ThCa'
### 430..432 -> 'ThCa'
### 460..462 -> 'ThCa'
### 99..101 -> 'BP'
### 101..103 -> 'BP'
### 121..123 -> 'BP'
### 135..137 -> 'BP'
### 139..141 -> 'BP'
### 154..156 -> 'BP'
### 156..158 -> 'BP'
### 167..169 -> 'BP'
### 258..260 -> 'BP'
### 298..300 -> 'BP'
### 302..304 -> 'BP'
### 317..319 -> 'BP'
### 369..371 -> 'BP'
### 403..405 -> 'BP'
### 497..499 -> 'BP'
### 99..101 -> 'TiTi'
### 101..103 -> 'TiTi'
### 121..123 -> 'TiTi'
### 135..137 -> 'TiTi'
### 139..141 -> 'TiTi'
### 154..156 -> 'TiTi'
### 156..158 -> 'TiTi'
### 167..169 -> 'TiTi'
### 258..260 -> 'TiTi'
### 298..300 -> 'TiTi'
### 302..304 -> 'TiTi'
### 317..319 -> 'TiTi'
### 369..371 -> 'TiTi'
### 403..405 -> 'TiTi'
### 497..499 -> 'TiTi'
foo
#+end_example

** puzzle 1B
#+BEGIN_SRC cpp :results output :tangle d19p1.c
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>

  #define DIFFSIZE 1024

  typedef struct repl_t {
    char from[5];
    char to[64];
  } repl_t;

  int strcompare(const void *va, const void *vb) {
    char *a = (char *) va;
    char *b = (char *) vb;
    return strcmp(a, b);
  }

  int main() {
    FILE *f = fopen("d19.txt", "r");
    char line[1024];

    repl_t repls[64] = { 0 };
    int replslen = 0;

    while (fgets(line, 1024, f) != NULL) {
      if (line[0] == '\n')
        break;
      sscanf(line, "%s => %s", repls[replslen].from, repls[replslen].to);
      replslen++;
    }

    char molecule[1024];
    fgets(molecule, 1024, f);
    int moleculelen = strlen(molecule) - 1;
    molecule[moleculelen] = '\0';

    // for (int i = 0; i < replslen; i++) {
    //   printf("## '%s' -> '%s'\n", repls[i].from, repls[i].to);
    // }
    // printf("## '%s'\n", molecule);

    char molecules[DIFFSIZE][1024] = { 0 };
    int moleculeslen = 0;

    for (int i = 0; i < replslen; i++) {
      int matchi = 0;
      int matchlen = strlen(repls[i].from);
      int repllen = strlen(repls[i].to);
      for (int j = 0; j < moleculelen; j++) {
        if (molecule[j] == repls[i].from[matchi]) {
          matchi++;
        } else {
          matchi = 0;
        }
        if (matchi == matchlen) {
          strcpy(molecules[moleculeslen], molecule);

          int replfrom = j - matchi + 1;
          int replto = j;
          int repladds = repllen - matchlen;
          // printf("## %d..%d: '%s' => '%s'\n", replfrom, replto, repls[i].from, repls[i].to);
          for (int k = moleculelen; k >= replfrom; k--) {
            molecules[moleculeslen][k + repladds] = molecules[moleculeslen][k];
          }
          // printf("##    '%s'\n", molecules[moleculeslen]);
            for (int k = replfrom; k < replfrom + repllen; k++) {
            molecules[moleculeslen][k] = repls[i].to[k - replfrom];
          }
          // printf("##    '%s'\n", molecules[moleculeslen]);
          moleculeslen++;
          matchi = 0;
          if (moleculeslen == DIFFSIZE) {
            printf("DIFFSIZE too small\n");
            return 0;
          }
        }
      }
    }

    qsort(molecules, moleculeslen, 1024, strcompare);

    int uniques = 1;
    for (int i = 1; i < moleculeslen; i++) {
      if (strcmp(molecules[i], molecules[i - 1]) != 0)
        uniques++;
    }

    // for (int i = 0; i < moleculeslen; i++) {
    //   printf("### '%s'\n", molecules[i]);
    // }
    // printf("# %d/%d\n", uniques, moleculeslen);

    printf("%d", uniques);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 576

 - 556 too low
 - 674 too high

** puzzle 2
#+BEGIN_SRC cpp :results output :tangle d19p2_.c
  #include <stdio.h>
  #include <string.h>
  #include <stdlib.h>
  #include <limits.h>

  #define DIFFSIZE 1024

  typedef struct repl_t {
    char from[5];
    char to[64];
  } repl_t;

  char *replace(repl_t repl, int from, char *molecule) {
    int len = strlen(molecule);
    int fromlen = strlen(repl.from);
    int tolen = strlen(repl.to);
    int newlen = len + (tolen - fromlen);
    char *new_molecule = (char*) malloc(newlen + 1);

    for (int newi = 0, i = 0; i < len; i++) {
      if (i == from) {
        for (int j = 0; j < tolen; j++) {
          new_molecule[newi++] = repl.to[j];
        }
        i += fromlen - 1;
      } else {
        new_molecule[newi++] = molecule[i];
      }
    }
    new_molecule[newlen] = '\0';
    return new_molecule;
  }

  int minsteps(repl_t *repls, int replslen, char *molecule, char *target) {

    // printf("#### '%s'\n", molecule);
    // printf("     '%s'\n", target);

    int mlen = strlen(molecule);
    int tlen = strlen(target);
    if (mlen >= tlen) {
      int steps = strcmp(molecule, target) == 0 ? 0 : INT_MAX;
      free(molecule);
      return steps;
    }

    int min = INT_MAX - 1;
    for (int i = 0; i < replslen; i++) {
      int matchi = 0;
      int matchlen = strlen(repls[i].from);
      for (int j = 0; molecule[j] != '\0'; j++) {
        if (molecule[j] == repls[i].from[matchi]) {
          matchi++;
        } else {
          matchi = 0;
        }
        if (matchi == matchlen) {
          int replfrom = j - matchi + 1;
          int steps = minsteps(repls, replslen, replace(repls[i], replfrom, molecule), target);
          if (steps < min) min = steps;
        }
      }
    }
    free(molecule);
    return min + 1;
  }


  int main() {
    FILE *f = fopen("d19.txt", "r");
    char line[1024];

    repl_t repls[64] = { 0 };
    int replslen = 0;

    while (fgets(line, 1024, f) != NULL) {
      if (line[0] == '\n')
        break;
      sscanf(line, "%s => %s", repls[replslen].from, repls[replslen].to);
      replslen++;
    }

    char molecule[1024];
    fgets(molecule, 1024, f);
    int moleculelen = strlen(molecule) - 1;
    molecule[moleculelen] = '\0';

    // for (int i = 0; i < replslen; i++) {
    //   printf("## '%s' -> '%s'\n", repls[i].from, repls[i].to);
    // }
    // printf("## '%s'\n", molecule);

    int steps = minsteps(repls, replslen, strdup("e"), molecule);

    printf("%d", steps);
    return 0;
  }
#+END_SRC

#+RESULTS:

** puzzle 2B
#+BEGIN_SRC cpp :results output :tangle d19p2.c
    #include <stdio.h>
    #include <string.h>
    #include <stdlib.h>
    #include <limits.h>
    #include <time.h>

    #define DIFFSIZE 1024

    typedef struct repl_t {
      char from[5];
      char to[64];
    } repl_t;

    char *unplace(repl_t repl, int from, char *molecule) {
      int len = strlen(molecule);
      int fromlen = strlen(repl.from);
      int tolen = strlen(repl.to);
      int newlen = len - (tolen - fromlen);
      char *new_molecule = (char*) malloc(newlen + 1);

      for (int newi = 0, i = 0; i < len; i++) {
        if (i == from) {
          for (int j = 0; j < fromlen; j++) {
            new_molecule[newi++] = repl.from[j];
          }
          i += tolen - 1;
        } else {
          new_molecule[newi++] = molecule[i];
        }
      }
      new_molecule[newlen] = '\0';
      return new_molecule;
    }

    char last_mc[1024];

    int minsteps(repl_t *repls, int replslen, char *molecule, char *target) {
      if (strcmp(target, molecule) == 0) {
        free(molecule);
        return 0;
      }

      int min = 99999;
      int tries = 1;
      for (int i = 0; i < replslen; i++) {
        char *tmp = strstr(molecule, repls[i].to);
        if (NULL != tmp && tries-- > 0) {
          int from = tmp - molecule;
          int steps = minsteps(repls, replslen, unplace(repls[i], from, molecule), target);
          // printf("### (%s=>%s) %d, steps=%d:\n", repls[i].from, repls[i].to, from, steps);
          // printf("###       %s\n", molecule);
          // printf("###       %s\n", unplace(repls[i], from, molecule));
          if (steps < min) min = steps;
        }
      }
      strcpy(last_mc, molecule);
      free(molecule);
      return min + 1;

      int bestrepl = -1;
      int bestrepllen = 0;
      int bestfrom = 0;
      for (int i = 0; i < replslen; i++) {
        int tolen = strlen(repls[i].to);
        char *tmp;
        if (tolen > bestrepllen && (tmp = strstr(molecule, repls[i].to)) != NULL) {
          bestrepllen = tolen;
          bestrepl = i;
          bestfrom = tmp - molecule;
        }
      }

      if (bestrepl == -1) {
        printf("## no best found\n");
        printf("##     '%s'\n", molecule);
        return 99999;
      }
      printf("## best:'%s'=>'%s' %d\n", repls[bestrepl].from, repls[bestrepl].to, bestfrom);
      printf("##     '%s'\n", molecule);

      return 1 + minsteps(repls, replslen, unplace(repls[bestrepl], bestfrom, molecule), target);
    }

  void shuffle(repl_t *array, int n)
  {
      if (n > 1) 
      {
          size_t i;
          for (i = 0; i < n - 1; i++) 
          {
            size_t j = i + rand() / (RAND_MAX / (n - i) + 1);
            repl_t t = array[j];
            array[j] = array[i];
            array[i] = t;
          }
      }
  }

    int main() {
      srand(time(NULL));
      FILE *f = fopen("d19.txt", "r");
      char line[1024];

      repl_t repls[64] = { 0 };
      int replslen = 0;

      while (fgets(line, 1024, f) != NULL) {
        if (line[0] == '\n')
          break;
        sscanf(line, "%s => %s", repls[replslen].from, repls[replslen].to);
        replslen++;
      }

      char molecule[1024];
      fgets(molecule, 1024, f);
      int moleculelen = strlen(molecule) - 1;
      molecule[moleculelen] = '\0';

      shuffle(repls, replslen);

      // for (int i = 0; i < replslen; i++) {
      //   printf("## '%s' -> '%s'\n", repls[i].from, repls[i].to);
      // }
      // printf("## '%s'\n", molecule);

      // for (int i = 0; i < replslen; i++) {
      //   for (int j = 0; j < replslen; j++) {
      //     if (NULL != strstr(repls[i].to, repls[j].from)) {
      //       printf("##### (%s=>%s) -> (%s=>%s)\n", 
      //              repls[i].from, repls[i].to, repls[j].from, repls[j].to);
      //     }
      //   }
      // }
      // return 0;


      int steps = minsteps(repls, replslen, strdup(molecule), "e");

      // printf("## '%s'\n", last_mc);

      printf("%d", steps);
      return 0;
    }
#+END_SRC

#+RESULTS:
: 207

* day 20
** text
--- Day 20: Infinite Elves and Infinite Houses ---

To keep the Elves busy, Santa has them deliver some presents by hand, door-to-door. He sends them down a street with infinite houses numbered sequentially: 1, 2, 3, 4, 5, and so on.

Each Elf is assigned a number, too, and delivers presents to houses based on that number:

    The first Elf (number 1) delivers presents to every house: 1, 2, 3, 4, 5, ....
    The second Elf (number 2) delivers presents to every second house: 2, 4, 6, 8, 10, ....
    Elf number 3 delivers presents to every third house: 3, 6, 9, 12, 15, ....

There are infinitely many Elves, numbered starting with 1. Each Elf delivers presents equal to ten times his or her number at each house.

So, the first nine houses on the street end up like this:

House 1 got 10 presents.
House 2 got 30 presents.
House 3 got 40 presents.
House 4 got 70 presents.
House 5 got 60 presents.
House 6 got 120 presents.
House 7 got 80 presents.
House 8 got 150 presents.
House 9 got 130 presents.

The first house gets 10 presents: it is visited only by Elf 1, which delivers 1 * 10 = 10 presents. The fourth house gets 70 presents, because it is visited by Elves 1, 2, and 4, for a total of 10 + 20 + 40 = 70 presents.

What is the lowest house number of the house to get at least as many presents as the number in your puzzle input?

Your puzzle answer was 786240.
--- Part Two ---

The Elves decide they don't want to visit an infinite number of houses. Instead, each Elf will stop after delivering presents to 50 houses. To make up for it, they decide to deliver presents equal to eleven times their number at each house.

With these changes, what is the new lowest house number of the house to get at least as many presents as the number in your puzzle input?

Your puzzle answer was 831600.
** puzzle 1
#+BEGIN_SRC cpp :results output
  #include <stdio.h>

  #define HOUSES 1000000

  int main() {
    int puzzle = 34000000;

    int houses[HOUSES] = { 0 };

    for (int elf = 1; elf < HOUSES; elf++) {
      for (int h = elf; h < HOUSES; h += elf) {
        houses[h] += elf * 10;
      }
      if (houses[elf] >= puzzle) {
        printf("%d\n", elf);
        return 0;
      }
    }
    printf("fail: last=%d\n", houses[HOUSES-1]);

    // for (int i = 1; i < HOUSES; i++) {
    //   printf("## %d: %d\n", i, houses[i]);
    // }

    printf("foo\n");
    return 0;
  }
#+END_SRC

#+RESULTS:
: 786240

** puzzle 2
#+BEGIN_SRC cpp :results output
  #include <stdio.h>

  #define HOUSES 1000000

  int main() {
    int puzzle = 34000000;

    int houses[HOUSES] = { 0 };

    for (int elf = 1; elf < HOUSES; elf++) {
      for (int h = elf; h < elf + (elf * 50) && h < HOUSES; h += elf) {
        houses[h] += elf * 11;
      }
      if (houses[elf] >= puzzle) {
        printf("%d\n", elf);
        return 0;
      }
    }
    printf("fail: last=%d\n", houses[HOUSES-1]);

    // for (int i = 1; i < HOUSES; i++) {
    //   printf("## %d: %d\n", i, houses[i]);
    // }

    printf("foo\n");
    return 0;
  }
#+END_SRC

#+RESULTS:
: 831600

* day 21
** text
--- Day 21: RPG Simulator 20XX ---

Little Henry Case got a new video game for Christmas. It's an RPG, and he's stuck on a boss. He needs to know what equipment to buy at the shop. He hands you the controller.

In this game, the player (you) and the enemy (the boss) take turns attacking. The player always goes first. Each attack reduces the opponent's hit points by at least 1. The first character at or below 0 hit points loses.

Damage dealt by an attacker each turn is equal to the attacker's damage score minus the defender's armor score. An attacker always does at least 1 damage. So, if the attacker has a damage score of 8, and the defender has an armor score of 3, the defender loses 5 hit points. If the defender had an armor score of 300, the defender would still lose 1 hit point.

Your damage score and armor score both start at zero. They can be increased by buying items in exchange for gold. You start with no items and have as much gold as you need. Your total damage or armor is equal to the sum of those stats from all of your items. You have 100 hit points.

Here is what the item shop is selling:

Weapons:    Cost  Damage  Armor
Dagger        8     4       0
Shortsword   10     5       0
Warhammer    25     6       0
Longsword    40     7       0
Greataxe     74     8       0

Armor:      Cost  Damage  Armor
Leather      13     0       1
Chainmail    31     0       2
Splintmail   53     0       3
Bandedmail   75     0       4
Platemail   102     0       5

Rings:      Cost  Damage  Armor
Damage +1    25     1       0
Damage +2    50     2       0
Damage +3   100     3       0
Defense +1   20     0       1
Defense +2   40     0       2
Defense +3   80     0       3

You must buy exactly one weapon; no dual-wielding. Armor is optional, but you can't use more than one. You can buy 0-2 rings (at most one for each hand). You must use any items you buy. The shop only has one of each item, so you can't buy, for example, two rings of Damage +3.

For example, suppose you have 8 hit points, 5 damage, and 5 armor, and that the boss has 12 hit points, 7 damage, and 2 armor:

    The player deals 5-2 = 3 damage; the boss goes down to 9 hit points.
    The boss deals 7-5 = 2 damage; the player goes down to 6 hit points.
    The player deals 5-2 = 3 damage; the boss goes down to 6 hit points.
    The boss deals 7-5 = 2 damage; the player goes down to 4 hit points.
    The player deals 5-2 = 3 damage; the boss goes down to 3 hit points.
    The boss deals 7-5 = 2 damage; the player goes down to 2 hit points.
    The player deals 5-2 = 3 damage; the boss goes down to 0 hit points.

In this scenario, the player wins! (Barely.)

You have 100 hit points. The boss's actual stats are in your puzzle input. What is the least amount of gold you can spend and still win the fight?

Your puzzle answer was 91.
--- Part Two ---

Turns out the shopkeeper is working with the boss, and can persuade you to buy whatever items he wants. The other rules still apply, and he still only has one of each item.

What is the most amount of gold you can spend and still lose the fight?

Your puzzle answer was 158.
** data
#+BEGIN_SRC text :padline no :tangle d21.txt
Hit Points: 100
Damage: 8
Armor: 2
#+END_SRC
** puzzle 1
#+BEGIN_SRC cpp :results output
  #include <stdio.h>
  #include <limits.h>

  #define PHP 100
  #define PDMG 0
  #define PAM 0

  #define BHP 100
  #define BDMG 8
  #define BAM 2


  typedef struct item_t {
    int cost, dmg, arm;
  } item_t;

  int main() {
    item_t ws[] = { {.cost =  0, .dmg = 0, .arm = 0 },
                    {.cost =  8, .dmg = 4, .arm = 0 },
                    {.cost = 10, .dmg = 5, .arm = 0 },
                    {.cost = 25, .dmg = 6, .arm = 0 },
                    {.cost = 40, .dmg = 7, .arm = 0 },
                    {.cost = 74, .dmg = 8, .arm = 0 } };

    item_t as[] = { {.cost =   0, .dmg = 0, .arm = 0 },
                    {.cost =  13, .dmg = 0, .arm = 1 },
                    {.cost =  31, .dmg = 0, .arm = 2 },
                    {.cost =  53, .dmg = 0, .arm = 3 },
                    {.cost =  75, .dmg = 0, .arm = 4 },
                    {.cost = 102, .dmg = 0, .arm = 5 } };

    item_t rs[] = { {.cost =   0, .dmg = 0, .arm = 0 },
                    {.cost =   0, .dmg = 0, .arm = 0 },
                    {.cost =  25, .dmg = 1, .arm = 0 },
                    {.cost =  50, .dmg = 2, .arm = 0 },
                    {.cost = 100, .dmg = 3, .arm = 0 },
                    {.cost =  20, .dmg = 0, .arm = 1 },
                    {.cost =  40, .dmg = 0, .arm = 2 },
                    {.cost =  80, .dmg = 0, .arm = 3 } };

    int wslen = sizeof(ws) / sizeof(ws[0]);
    int aslen = sizeof(as) / sizeof(as[0]);
    int rslen = sizeof(rs) / sizeof(rs[0]);
   
    int min = INT_MAX;
    for (int w = 0; w < wslen; w++) {
      for (int a = 0; a < aslen; a++) {
        for (int r1 = 0; r1 < rslen; r1++) {
          for (int r2 = 0; r2 < rslen; r2++) {
            if (r2 != r1) {
              int bhp = BHP;
              int bdmg = BDMG;
              int bam = BAM;
              int php = PHP;
              int pdmg = PDMG + ws[w].dmg + rs[r1].dmg + rs[r2].dmg;
              int pam = PAM + as[a].arm + rs[r1].arm + rs[r2].arm;

              while (1) {
                int pdealth = pdmg - bam;
                if (pdealth < 1) pdealth = 1;
                bhp -= pdealth;
                if (bhp <= 0)
                  break;
                int bdealth = bdmg - pam;
                if (bdealth < 1) bdealth = 1;
                php -= bdealth;
                if (php <= 0)
                  break;
              }
              if (bhp <= 0) {
                int cost = ws[w].cost + as[a].cost + rs[r1].cost + rs[r2].cost;
                if (cost < min) min = cost;
              }
            }
          }
        }
      }
    }


    printf("%d", min);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 91

** puzzle 2
#+BEGIN_SRC cpp :results output
  #include <stdio.h>
  #include <limits.h>

  #define PHP 100

  #define BHP 100
  #define BDMG 8
  #define BAM 2

  typedef struct item_t {
    int cost, dmg, arm;
  } item_t;

  int main() {
    item_t ws[] = { {.cost =  8, .dmg = 4, .arm = 0 },
                    {.cost = 10, .dmg = 5, .arm = 0 },
                    {.cost = 25, .dmg = 6, .arm = 0 },
                    {.cost = 40, .dmg = 7, .arm = 0 },
                    {.cost = 74, .dmg = 8, .arm = 0 } };

    item_t as[] = { {.cost =   0, .dmg = 0, .arm = 0 },
                    {.cost =  13, .dmg = 0, .arm = 1 },
                    {.cost =  31, .dmg = 0, .arm = 2 },
                    {.cost =  53, .dmg = 0, .arm = 3 },
                    {.cost =  75, .dmg = 0, .arm = 4 },
                    {.cost = 102, .dmg = 0, .arm = 5 } };

    item_t rs[] = { {.cost =   0, .dmg = 0, .arm = 0 },
                    {.cost =   0, .dmg = 0, .arm = 0 },
                    {.cost =  25, .dmg = 1, .arm = 0 },
                    {.cost =  50, .dmg = 2, .arm = 0 },
                    {.cost = 100, .dmg = 3, .arm = 0 },
                    {.cost =  20, .dmg = 0, .arm = 1 },
                    {.cost =  40, .dmg = 0, .arm = 2 },
                    {.cost =  80, .dmg = 0, .arm = 3 } };

    int wslen = sizeof(ws) / sizeof(ws[0]);
    int aslen = sizeof(as) / sizeof(as[0]);
    int rslen = sizeof(rs) / sizeof(rs[0]);

    int max = INT_MIN;
    for (int w = 0; w < wslen; w++) {
      for (int a = 0; a < aslen; a++) {
        for (int r1 = 0; r1 < rslen; r1++) {
          for (int r2 = r1 + 1; r2 < rslen; r2++) {
            int bhp = BHP;
            int bdmg = BDMG;
            int bam = BAM;
            int php = PHP;
            int pdmg = ws[w].dmg + rs[r1].dmg + rs[r2].dmg;
            int pam = as[a].arm + rs[r1].arm + rs[r2].arm;

            while (1) {
              int pdealth = pdmg - bam;
              if (pdealth < 1) pdealth = 1;
              bhp -= pdealth;
              if (bhp <= 0) break;
              int bdealth = bdmg - pam;
              if (bdealth < 1) bdealth = 1;
              php -= bdealth;
              if (php <= 0) break;
            }
            if (php <= 0) {
              int cost = ws[w].cost + as[a].cost + rs[r1].cost + rs[r2].cost;
              if (cost > max) max = cost;

              // if (cost == max)
              // printf("## w%d, a%d, r%d&%d, c%3d (php=%2d, bhp=%2d)\n", w, a, r1, r2, cost,
              //        php, bhp);
            }
          }
        }
      }
    }

    printf("%d", max);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 158

 - 233 too high

* day 22
** text
--- Day 22: Wizard Simulator 20XX ---

Little Henry Case decides that defeating bosses with swords and stuff is boring. Now he's playing the game with a wizard. Of course, he gets stuck on another boss and needs your help again.

In this version, combat still proceeds with the player and the boss taking alternating turns. The player still goes first. Now, however, you don't get any equipment; instead, you must choose one of your spells to cast. The first character at or below 0 hit points loses.

Since you're a wizard, you don't get to wear armor, and you can't attack normally. However, since you do magic damage, your opponent's armor is ignored, and so the boss effectively has zero armor as well. As before, if armor (from a spell, in this case) would reduce damage below 1, it becomes 1 instead - that is, the boss' attacks always deal at least 1 damage.

On each of your turns, you must select one of your spells to cast. If you cannot afford to cast any spell, you lose. Spells cost mana; you start with 500 mana, but have no maximum limit. You must have enough mana to cast a spell, and its cost is immediately deducted when you cast it. Your spells are Magic Missile, Drain, Shield, Poison, and Recharge.

    Magic Missile costs 53 mana. It instantly does 4 damage.
    Drain costs 73 mana. It instantly does 2 damage and heals you for 2 hit points.
    Shield costs 113 mana. It starts an effect that lasts for 6 turns. While it is active, your armor is increased by 7.
    Poison costs 173 mana. It starts an effect that lasts for 6 turns. At the start of each turn while it is active, it deals the boss 3 damage.
    Recharge costs 229 mana. It starts an effect that lasts for 5 turns. At the start of each turn while it is active, it gives you 101 new mana.

Effects all work the same way. Effects apply at the start of both the player's turns and the boss' turns. Effects are created with a timer (the number of turns they last); at the start of each turn, after they apply any effect they have, their timer is decreased by one. If this decreases the timer to zero, the effect ends. You cannot cast a spell that would start an effect which is already active. However, effects can be started on the same turn they end.

For example, suppose the player has 10 hit points and 250 mana, and that the boss has 13 hit points and 8 damage:

-- Player turn --
- Player has 10 hit points, 0 armor, 250 mana
- Boss has 13 hit points
Player casts Poison.

-- Boss turn --
- Player has 10 hit points, 0 armor, 77 mana
- Boss has 13 hit points
Poison deals 3 damage; its timer is now 5.
Boss attacks for 8 damage.

-- Player turn --
- Player has 2 hit points, 0 armor, 77 mana
- Boss has 10 hit points
Poison deals 3 damage; its timer is now 4.
Player casts Magic Missile, dealing 4 damage.

-- Boss turn --
- Player has 2 hit points, 0 armor, 24 mana
- Boss has 3 hit points
Poison deals 3 damage. This kills the boss, and the player wins.

Now, suppose the same initial conditions, except that the boss has 14 hit points instead:

-- Player turn --
- Player has 10 hit points, 0 armor, 250 mana
- Boss has 14 hit points
Player casts Recharge.

-- Boss turn --
- Player has 10 hit points, 0 armor, 21 mana
- Boss has 14 hit points
Recharge provides 101 mana; its timer is now 4.
Boss attacks for 8 damage!

-- Player turn --
- Player has 2 hit points, 0 armor, 122 mana
- Boss has 14 hit points
Recharge provides 101 mana; its timer is now 3.
Player casts Shield, increasing armor by 7.

-- Boss turn --
- Player has 2 hit points, 7 armor, 110 mana
- Boss has 14 hit points
Shield's timer is now 5.
Recharge provides 101 mana; its timer is now 2.
Boss attacks for 8 - 7 = 1 damage!

-- Player turn --
- Player has 1 hit point, 7 armor, 211 mana
- Boss has 14 hit points
Shield's timer is now 4.
Recharge provides 101 mana; its timer is now 1.
Player casts Drain, dealing 2 damage, and healing 2 hit points.

-- Boss turn --
- Player has 3 hit points, 7 armor, 239 mana
- Boss has 12 hit points
Shield's timer is now 3.
Recharge provides 101 mana; its timer is now 0.
Recharge wears off.
Boss attacks for 8 - 7 = 1 damage!

-- Player turn --
- Player has 2 hit points, 7 armor, 340 mana
- Boss has 12 hit points
Shield's timer is now 2.
Player casts Poison.

-- Boss turn --
- Player has 2 hit points, 7 armor, 167 mana
- Boss has 12 hit points
Shield's timer is now 1.
Poison deals 3 damage; its timer is now 5.
Boss attacks for 8 - 7 = 1 damage!

-- Player turn --
- Player has 1 hit point, 7 armor, 167 mana
- Boss has 9 hit points
Shield's timer is now 0.
Shield wears off, decreasing armor by 7.
Poison deals 3 damage; its timer is now 4.
Player casts Magic Missile, dealing 4 damage.

-- Boss turn --
- Player has 1 hit point, 0 armor, 114 mana
- Boss has 2 hit points
Poison deals 3 damage. This kills the boss, and the player wins.

You start with 50 hit points and 500 mana points. The boss's actual stats are in your puzzle input. What is the least amount of mana you can spend and still win the fight? (Do not include mana recharge effects as "spending" negative mana.)

Your puzzle answer was 900.
--- Part Two ---

On the next run through the game, you increase the difficulty to hard.

At the start of each player turn (before any other effects apply), you lose 1 hit point. If this brings you to or below 0 hit points, you lose.

With the same starting stats for you and the boss, what is the least amount of mana you can spend and still win the fight?

Your puzzle answer was 1216.
** data
#+BEGIN_SRC text :padline no :tangle d22.txt
Hit Points: 51
Damage: 9
#+END_SRC
** puzzle 1
#+BEGIN_SRC cpp :results output :tangle d22p1.c
  #include <stdio.h>
  #include <limits.h>

  #define BHP 51
  #define BDMG 9

  #define PHP 50
  #define PMANA 500

  int minmana(int php, int mana, int bhp, int shield, 
              int poison, int recharge, int spent) {
    if (spent > 1000) {
      return INT_MAX - 2;
    }
    if (spent > 0) {
      // printf("## boss: p(%3d,%3d), b%3d, s%d p%d r%d, spend%4d\n",
      //        php, mana, bhp, shield, poison, recharge, spent);
      // boss turn
      if (poison > 0) {
        poison--;
        bhp -= 3;
      }
      if (recharge > 0) {
        recharge--;
        mana += 101;
      }

      if (bhp <= 0) {
        return spent;
      }

      int bdealth = BDMG - (shield > 0 ? 7 : 0);
      if (bdealth < 1) bdealth = 1;
      php -= bdealth;

      if (shield > 0)
        shield--;

      if (php <= 0) {
        return INT_MAX - 1;
      }
    }


    // player turn
    // printf("##   pl: p(%3d,%3d), b%3d, s%d p%d r%d, spend%4d\n",
    //        php, mana, bhp, shield, poison, recharge, spent);
    if (shield > 0)
      shield--;
    if (poison > 0) {
      poison--;
      bhp -= 3;
    }
    if (recharge > 0) {
      recharge--;
      mana += 101;
    }

    int min = INT_MAX;
    if (mana >= 53) {
      int m = minmana(php, mana - 53, bhp - 4, shield, poison, recharge, spent + 53);
      if (m < min) min = m;
    }
    if (mana >= 73) {
      int m = minmana(php + 2, mana - 73, bhp - 2, shield, poison, recharge, spent + 73);
      if (m < min) min = m;
    }
    if (mana >= 113 && shield == 0) {
      int m = minmana(php, mana - 113, bhp, 6, poison, recharge, spent + 113);
      if (m < min) min = m;
    }
    if (mana >= 173 && poison == 0) {
      int m = minmana(php, mana - 173, bhp, shield, 6, recharge, spent + 173);
      if (m < min) min = m;
    }
    if (mana >= 229 && recharge == 0) {
      int m = minmana(php, mana - 229, bhp, shield, poison, 5, spent + 229);
      if (m < min) min = m;
    }
    return min;
  }

  int main() {

    int min = minmana(PHP, PMANA, BHP, 0, 0, 0, 0);

    printf("%d\n", min);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 900

** puzzle 2
#+BEGIN_SRC cpp :results output :tangle d22p2.c
  #include <stdio.h>
  #include <limits.h>

  #define BHP 51
  #define BDMG 9

  #define PHP 50
  #define PMANA 500

  int minmana(int php, int mana, int bhp, int shield, 
              int poison, int recharge, int spent) {
    if (spent > 2000) {
      return INT_MAX - 2;
    }
    if (spent > 0) {
      // printf("## boss: p(%3d,%3d), b%3d, s%d p%d r%d, spend%4d\n",
      //        php, mana, bhp, shield, poison, recharge, spent);
      // boss turn
      if (poison > 0) {
        poison--;
        bhp -= 3;
      }
      if (recharge > 0) {
        recharge--;
        mana += 101;
      }

      if (bhp <= 0) {
        return spent;
      }

      int bdealth = BDMG - (shield > 0 ? 7 : 0);
      if (bdealth < 1) bdealth = 1;
      php -= bdealth;

      if (shield > 0)
        shield--;

      if (php <= 0) {
        return INT_MAX - 1;
      }
    }


    // player turn
    // printf("##   pl: p(%3d,%3d), b%3d, s%d p%d r%d, spend%4d\n",
    //        php, mana, bhp, shield, poison, recharge, spent);

    php -= 1;
    if (php <= 0)
      return INT_MAX - 1;

    if (shield > 0)
      shield--;
    if (poison > 0) {
      poison--;
      bhp -= 3;
    }
    if (recharge > 0) {
      recharge--;
      mana += 101;
    }

    int min = INT_MAX;
    if (mana >= 53) {
      int m = minmana(php, mana - 53, bhp - 4, shield, poison, recharge, spent + 53);
      if (m < min) min = m;
    }
    if (mana >= 73) {
      int m = minmana(php + 2, mana - 73, bhp - 2, shield, poison, recharge, spent + 73);
      if (m < min) min = m;
    }
    if (mana >= 113 && shield == 0) {
      int m = minmana(php, mana - 113, bhp, 6, poison, recharge, spent + 113);
      if (m < min) min = m;
    }
    if (mana >= 173 && poison == 0) {
      int m = minmana(php, mana - 173, bhp, shield, 6, recharge, spent + 173);
      if (m < min) min = m;
    }
    if (mana >= 229 && recharge == 0) {
      int m = minmana(php, mana - 229, bhp, shield, poison, 5, spent + 229);
      if (m < min) min = m;
    }
    return min;
  }

  int main() {

    int min = minmana(PHP, PMANA, BHP, 0, 0, 0, 0);

    printf("%d\n", min);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 1216

* day 23
** text
--- Day 23: Opening the Turing Lock ---

Little Jane Marie just got her very first computer for Christmas from some unknown benefactor. It comes with instructions and an example program, but the computer itself seems to be malfunctioning. She's curious what the program does, and would like you to help her run it.

The manual explains that the computer supports two registers and six instructions (truly, it goes on to remind the reader, a state-of-the-art technology). The registers are named a and b, can hold any non-negative integer, and begin with a value of 0. The instructions are as follows:

    hlf r sets register r to half its current value, then continues with the next instruction.
    tpl r sets register r to triple its current value, then continues with the next instruction.
    inc r increments register r, adding 1 to it, then continues with the next instruction.
    jmp offset is a jump; it continues with the instruction offset away relative to itself.
    jie r, offset is like jmp, but only jumps if register r is even ("jump if even").
    jio r, offset is like jmp, but only jumps if register r is 1 ("jump if one", not odd).

All three jump instructions work with an offset relative to that instruction. The offset is always written with a prefix + or - to indicate the direction of the jump (forward or backward, respectively). For example, jmp +1 would simply continue with the next instruction, while jmp +0 would continuously jump back to itself forever.

The program exits when it tries to run an instruction beyond the ones defined.

For example, this program sets a to 2, because the jio instruction causes it to skip the tpl instruction:

inc a
jio a, +2
tpl a
inc a

What is the value in register b when the program in your puzzle input is finished executing?

Your puzzle answer was 255.
--- Part Two ---

The unknown benefactor is very thankful for releasi-- er, helping little Jane Marie with her computer. Definitely not to distract you, what is the value in register b after the program is finished executing if register a starts as 1 instead?

Your puzzle answer was 334.
** data
#+BEGIN_SRC text :padline no :tangle d23.txt
jio a, +22
inc a
tpl a
tpl a
tpl a
inc a
tpl a
inc a
tpl a
inc a
inc a
tpl a
inc a
inc a
tpl a
inc a
inc a
tpl a
inc a
inc a
tpl a
jmp +19
tpl a
tpl a
tpl a
tpl a
inc a
inc a
tpl a
inc a
tpl a
inc a
inc a
tpl a
inc a
inc a
tpl a
inc a
tpl a
tpl a
jio a, +8
inc b
jie a, +4
tpl a
inc a
jmp +2
hlf a
jmp -7
#+END_SRC
** data test
#+BEGIN_SRC text :padline no :tangle d23t.txt
inc a
jio a, +2
tpl a
inc a
#+END_SRC
** puzzle 1
#+BEGIN_SRC cpp :results output
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>

  #define HLF 1
  #define TPL 2
  #define INC 3
  #define JMP 4
  #define JIE 5
  #define JIO 6
  typedef struct ins_t {
    int type;
    char r;
    int offset;
  } ins_t;

  int offset(const char *s) {
     if (s[0] == '+')
       s += 1;
     return atoi(s);
  }

  int run(ins_t *prog, int proglen, int a, int b) {
    int left = 10000;
    int regs[99];
    regs['a'] = a;
    regs['b'] = b;
    for (int pc = 0; pc >= 0 && pc < proglen; pc++) {
      int oldpc = pc;
      ins_t ins = prog[pc];
      switch (ins.type) {
      case HLF: regs[ins.r] /= 2; break;
      case TPL: regs[ins.r] *= 3; break;
      case INC: regs[ins.r] += 1; break;
      case JMP: pc += ins.offset - 1; break;
      case JIE: if (regs[ins.r] % 2 == 0) pc += ins.offset - 1; break;
      case JIO: if (regs[ins.r] == 1) pc += ins.offset - 1; break;
      }
      // printf("## %3d (%d r=%c offset=%d): %d, %d\n", 
      //        oldpc, ins.type, ins.r, ins.offset, regs['a'], regs['b']);
      if (left-- <= 0) { return -1; };
    }
    return regs['b'];
  }

  int main() {
    FILE *f = fopen("d23.txt", "r");
    if (f == NULL) { perror("foo"); return 1; }

    ins_t prog[1024];
    int proglen = 0;

    char line[64];
    while (NULL != fgets(line, 64, f)) {
      char r;
      if (sscanf(line, "hlf %c", &r) > 0) {
        prog[proglen].type = HLF;
        prog[proglen].r = r;
        proglen++;
      } else if (sscanf(line, "tpl %c", &r) > 0) {
        prog[proglen].type = TPL;
        prog[proglen].r = r;
        proglen++;
      } else if (sscanf(line, "inc %c", &r) > 0) {
        prog[proglen].type = INC;
        prog[proglen].r = r;
        proglen++;
      } else if (strncmp("jmp ", line, 4) == 0) {
        prog[proglen].type = JMP;
        prog[proglen].offset = offset(line + strlen("jmp "));
        proglen++;
      } else if (sscanf(line, "jie %c", &r) > 0) {
        prog[proglen].type = JIE;
        prog[proglen].r = r;
        prog[proglen].offset = offset(line + strlen("jie a, "));
        proglen++;
      } else if (sscanf(line, "jio %c", &r) > 0) {
        prog[proglen].type = JIO;
        prog[proglen].r = r;
        prog[proglen].offset = offset(line + strlen("jie a, "));
        proglen++;
      } else {
        fprintf(stderr, "Bad line: %s", line); return 1;
      }
    }

    // for (int i = 0; i < proglen; i++) {
    //   printf("## %d: r=%c, offset=%d\n", prog[i].type, prog[i].r, prog[i].offset);
    // }

    printf("1: %d\n", run(prog, proglen, 0, 0));
    printf("2: %d\n", run(prog, proglen, 1, 0));
    return 0;
  }
#+END_SRC

#+RESULTS:
: 1: 255
: 2: 334

* day 24
** text
--- Part Two ---

That's weird... the sleigh still isn't balancing.

"Ho ho ho", Santa muses to himself. "I forgot the trunk".

Balance the sleigh again, but this time, separate the packages into four groups instead of three. The other constraints still apply.

Given the example packages above, this would be some of the new unique first groups, their quantum entanglements, and one way to divide the remaining packages:


11 4    (QE=44); 10 5;   9 3 2 1; 8 7
10 5    (QE=50); 11 4;   9 3 2 1; 8 7
9 5 1   (QE=45); 11 4;   10 3 2;  8 7
9 4 2   (QE=72); 11 3 1; 10 5;    8 7
9 3 2 1 (QE=54); 11 4;   10 5;    8 7
8 7     (QE=56); 11 4;   10 5;    9 3 2 1

Of these, there are three arrangements that put the minimum (two) number of packages in the first group: 11 4, 10 5, and 8 7. Of these, 11 4 has the lowest quantum entanglement, and so it is selected.

Now, what is the quantum entanglement of the first group of packages in the ideal configuration?

Your puzzle answer was 72050269.
** data
#+BEGIN_SRC text :padline no :tangle d24.txt
1
3
5
11
13
17
19
23
29
31
37
41
43
47
53
59
67
71
73
79
83
89
97
101
103
107
109
113
#+END_SRC
** data test
#+BEGIN_SRC text :padline no :tangle d24t.txt
1
2
3
4
5
7
8
9
10
11
#+END_SRC
** puzzle
#+BEGIN_SRC cpp :results output
  #include <stdio.h>
  #include <limits.h>

  #define GROUPS 3
  #define SIZESHIFT 10

  int run(int *weights, int weightslen, int *sets, int cur) {
    if (cur == weightslen) {
      int gweights[GROUPS] = { 0 };
      int group0size = 0;
      int qe = 1;
      for (int i = 0; i < weightslen; i++) {
        gweights[sets[i]] += weights[i];
        if (sets[i] == 0) {
          group0size++;
          qe *= weights[i];
        }
      }

      for (int i = 1; i < GROUPS; i++) {
        if (gweights[i - 1] != gweights[i])
          return INT_MAX;
      }

      int valsize = group0size << SIZESHIFT;
      int valqe = qe;

      // for (int g = 0; g < GROUPS; g++) {
      //   printf("%d=(", g + 1);
      //   for (int i = 0; i < weightslen; i++) {
      //     if (sets[i] == g)
      //       printf("%d ", weights[i]);
      //   }
      //   printf("), ");
      // }
      // printf("qe=%d, val=%d(%X)\n", qe, valsize + valqe, valsize + valqe);

      return valsize + valqe;
    } else {
      int gweights[GROUPS] = { 0 };
      int sum = 0;
      for (int i = 0; i < cur; i++) {
        gweights[sets[i]] += weights[i];
        sum += weights[i];
      }
      for (int i = cur; i < weightslen; i++)
        sum += weights[i];
      
      int min = INT_MAX;
      for (int i = 0; i < GROUPS; i++) {
        if (gweights[i] + weights[cur] <= sum / GROUPS) {
          sets[cur] = i;
          int val = run(weights, weightslen, sets, cur + 1);
          if (val < min) min = val;
        }
      }
      return min;
    }
  }

  int main() {
    FILE *f = fopen("d24.txt", "r");
    if (f == NULL) { perror(""); return 1; }

    int weights[64];
    int weightslen = 0;

    int w;
    while (fscanf(f, "%d", &w) > 0) {
      weights[weightslen++] = w;
    }

    // for (int i = 0; i < weightslen; i++)
    //   printf("%d ", weights[i]);
    // printf("\n");

    int sets[weightslen];
    int val = run(weights, weightslen, sets, 0);
    int qe = val & ((1 << SIZESHIFT) - 1);
    printf("1= %d\n", qe);
    return 0;
  };
#+END_SRC

#+RESULTS:
: 1= 39

 - ? too low

** puzzle B
#+BEGIN_SRC cpp :results output :tangle d24.c
  #include <stdio.h>
  #include <limits.h>
  #include <time.h>

  #define SIZESHIFT 40

  long minqe(int *wgroups, int curw, int curg, int w, int *g0minsize, long *g0minqe, 
             int *weights, int weightslen, int groups, int targetw) {
    // printf("## minqe curw=%d, curg=%d, w=%d, tw=%d: ", curw, curg, w, targetw);
    // for (int i = 0; i < weightslen; i++)
    //   printf("%d=%d ", weights[i], wgroups[i]);
    // printf("\n");

    if (curg == 0) {
      int g0size = 0;
      long g0qe = 1;
      for (int i = 0; i < weightslen; i++)
        if (wgroups[i] == 0) {
          g0size++;
          g0qe *= weights[i];
        }
      if (g0size > *g0minsize) {
        return LONG_MAX;
      }
      if (g0qe >= *g0minqe) {
        return LONG_MAX;
      }
    }

    if (w == targetw) {
      if (curg == 0) {
        int g0size = 0;
        long g0qe = 1;
        for (int i = 0; i < weightslen; i++)
          if (wgroups[i] == 0) {
            g0size++;
            g0qe *= weights[i];
          }
        if (g0size <= *g0minsize) {
          ,*g0minsize = g0size;
        } else {
          return LONG_MAX;
        }
        if (g0qe < *g0minqe) {
          ,*g0minqe = g0qe;
        } else {
          return LONG_MAX;
        }
      }
      if (curg < groups - 2) {
        return minqe(wgroups, 0, curg + 1, 0, g0minsize, g0minqe, 
                     weights, weightslen, groups, targetw);
      } else {
        int lastw = 0;
        for (int i = 0; i < weightslen; i++)
          if (wgroups[i] == -1)
            lastw += weights[i];
        if (lastw != targetw)
          return LONG_MAX;

        int g0size = 0;
        long g0qe = 1;
        for (int i = 0; i < weightslen; i++)
          if (wgroups[i] == 0) {
            g0size++;
            g0qe *= weights[i];
          }
        long g0size_ = (long) g0size << SIZESHIFT;
        // printf("## s=%d, qe=%ld, val=%ld\n", g0size, g0qe, g0size_ + g0qe);
        return g0size_ + g0qe;
      }
    }

    if (curw == weightslen || w > targetw)
      return LONG_MAX;

    long min = LONG_MAX;
    long qe = minqe(wgroups, curw + 1, curg, w, g0minsize, g0minqe, 
                    weights, weightslen, groups, targetw);
    if (qe < min) min = qe;
    if (wgroups[curw] == -1) {
      wgroups[curw] = curg;
      qe = minqe(wgroups, curw + 1, curg, w + weights[curw], g0minsize, g0minqe, 
                 weights, weightslen, groups, targetw);
      wgroups[curw] = -1;
      if (qe < min) min = qe;
    }
    return min;
  }

  long minqe_(int *weights, int weightslen, int groups) {
    int wgroups[weightslen];
    int sum = 0;
    for (int i = 0; i < weightslen; i++) {
      wgroups[i] = -1;
      sum += weights[i];
    }
    int g0minsize = INT_MAX;
    long g0minqe = LONG_MAX;
    long out = minqe(wgroups, 0, 0, 0, &g0minsize, &g0minqe, 
                     weights, weightslen, groups, sum / groups);
    long qe = out & ((1L << SIZESHIFT) - 1L);
    long size = out >> SIZESHIFT;
    return qe;
  }


  int main() {
    FILE *f = fopen("d24.txt", "r");
    if (f == NULL) { perror(""); return 1; }

    int weights[64];
    int weightslen = 0;

    int w;
    while (fscanf(f, "%d", &w) > 0) {
      weights[weightslen++] = w;
    }

    int sum = 0;
    for (int i = 0; i < weightslen; i++)
      sum += weights[i];

    // for (int i = 0; i < weightslen; i++)
    //   printf("%d ", weights[i]);
    // printf("\nsum=%d\n", sum);

    time_t t = time(NULL);

    printf("%ld\n", minqe_(weights, weightslen, 3));
    printf("  %lds\n", time(NULL) - t);
    t = time(NULL);
    printf("%ld\n", minqe_(weights, weightslen, 4));
    printf("  %lds\n", time(NULL) - t);

    return 0;

  };
#+END_SRC

#+RESULTS:
: 10439961859
:   11s
: 72050269
:   659s

- results:
: 10439961859
:   11s
: 72050269
:   659s

* day 25
** text
--- Day 25: Let It Snow ---

Merry Christmas! Santa is booting up his weather machine; looks like you might get a white Christmas after all.

The weather machine beeps! On the console of the machine is a copy protection message asking you to enter a code from the instruction manual. Apparently, it refuses to run unless you give it that code. No problem; you'll just look up the code in the--

"Ho ho ho", Santa ponders aloud. "I can't seem to find the manual."

You look up the support number for the manufacturer and give them a call. Good thing, too - that 49th star wasn't going to earn itself.

"Oh, that machine is quite old!", they tell you. "That model went out of support six minutes ago, and we just finished shredding all of the manuals. I bet we can find you the code generation algorithm, though."

After putting you on hold for twenty minutes (your call is very important to them, it reminded you repeatedly), they finally find an engineer that remembers how the code system works.

The codes are printed on an infinite sheet of paper, starting in the top-left corner. The codes are filled in by diagonals: starting with the first row with an empty first box, the codes are filled in diagonally up and to the right. This process repeats until the infinite paper is covered. So, the first few codes are filled in in this order:

   | 1   2   3   4   5   6  
---+---+---+---+---+---+---+
 1 |  1   3   6  10  15  21
 2 |  2   5   9  14  20
 3 |  4   8  13  19
 4 |  7  12  18
 5 | 11  17
 6 | 16

For example, the 12th code would be written to row 4, column 2; the 15th code would be written to row 1, column 5.

The voice on the other end of the phone continues with how the codes are actually generated. The first code is 20151125. After that, each code is generated by taking the previous one, multiplying it by 252533, and then keeping the remainder from dividing that value by 33554393.

So, to find the second code (which ends up in row 2, column 1), start with the previous value, 20151125. Multiply it by 252533 to get 5088824049625. Then, divide that by 33554393, which leaves a remainder of 31916031. That remainder is the second code.

"Oh!", says the voice. "It looks like we missed a scrap from one of the manuals. Let me read it to you." You write down his numbers:

   |    1         2         3         4         5         6
---+---------+---------+---------+---------+---------+---------+
 1 | 20151125  18749137  17289845  30943339  10071777  33511524
 2 | 31916031  21629792  16929656   7726640  15514188   4041754
 3 | 16080970   8057251   1601130   7981243  11661866  16474243
 4 | 24592653  32451966  21345942   9380097  10600672  31527494
 5 |    77061  17552253  28094349   6899651   9250759  31663883
 6 | 33071741   6796745  25397450  24659492   1534922  27995004

"Now remember", the voice continues, "that's not even all of the first few numbers; for example, you're missing the one at 7,1 that would come before 6,2. But, it should be enough to let your-- oh, it's time for lunch! Bye!" The call disconnects.

Santa looks nervous. Your puzzle input contains the message on the machine's console. What code do you give the machine?

Your puzzle answer was 9132360.
--- Part Two ---

The machine springs to life, then falls silent again. It beeps. "Insufficient fuel", the console reads. "Fifty stars are required before proceeding. One star is available."

..."one star is available"? You check the fuel tank; sure enough, a lone star sits at the bottom, awaiting its friends. Looks like you need to provide 49 yourself.
** data
#+BEGIN_SRC text :padline no :tangle d25.txt
To continue, please consult the code grid in the manual.  Enter the code at row 2981, column 3075.
#+END_SRC
** puzzle
#+BEGIN_SRC cpp :results output
  #include <stdio.h>

  #define ROW 2981
  #define COL 3075

  int main() {
    //int grid[10000][10000] = { 0 };
    
    int row = 1;
    int col = 1;
    int val = 20151125;
    for (int i = 0; i < 100000000; i++) {
      if (row == ROW && col == COL) {
        printf("1: %d\n", val);
        break;
      }
      if (row == 1) {
        row = col + 1;
        col = 1;
      } else {
        row--;
        col++;
      }
      val = (252533L * val) % 33554393;
    }


    printf("foo\n");
    return 0;
  }
#+END_SRC

#+RESULTS:
: 1: 9132360
: foo

* java
(require 'ob-java)
(require 'ob-sh)
** helpers
#+NAME: java_imports
#+BEGIN_SRC java
  import java.util.*;
#+END_SRC java

#+NAME: java_begin
#+BEGIN_SRC java
   <<java_imports>>

   public class Org {
     public static void main(String[] args) {
#+END_SRC java

#+NAME: java_end
#+BEGIN_SRC java
     }
   }
#+END_SRC java
** examples
#+BEGIN_SRC java :classname Foo
  class Foo {
      public static void main(String[] args) {
          System.out.println("foo");
      }
  }
#+END_SRC

#+RESULTS:
: foo

#+BEGIN_SRC java :classname Org :noweb yes
<<java_begin>>
System.out.println(Arrays.asList("Hello", "World"));
<<java_end>>
#+END_SRC

#+RESULTS:
: [Hello, World]

