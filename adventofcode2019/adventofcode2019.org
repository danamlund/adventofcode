* setup
(require 'ob-org)
(require 'ob-python)
** stdout/stderr on bad exit-code
#+BEGIN_SRC elisp
(defun org-babel-eval (cmd body)
  "Run CMD on BODY.
If CMD succeeds then return its results, otherwise display
STDERR with `org-babel-eval-error-notify'."
  (let ((err-buff (get-buffer-create " *Org-Babel Error*")) exit-code)
    (with-current-buffer err-buff (erase-buffer))
    (with-temp-buffer
      (insert body)
      (setq exit-code
	    (org-babel--shell-command-on-region
	     (point-min) (point-max) cmd err-buff))
      (if (or (not (numberp exit-code)) (> exit-code 0))
	  (progn
	    (with-current-buffer err-buff
	      (org-babel-eval-error-notify exit-code (buffer-string)))
	    (save-excursion
	      (when (get-buffer org-babel-error-buffer-name)
		(with-current-buffer org-babel-error-buffer-name
		  (unless (derived-mode-p 'compilation-mode)
		    (compilation-mode))
		  ;; Compilation-mode enforces read-only, but Babel expects the buffer modifiable.
		  (setq buffer-read-only nil))))
	    (concat (buffer-string) "STDERR:\n" (with-current-buffer err-buff (buffer-string))))
	(buffer-string)))))
#+END_SRC
* make work
 - tangle file: C-c C-v t
 - C-c C-c code src

* day 1
** puzzle
--- Day 1: The Tyranny of the Rocket Equation ---

Santa has become stranded at the edge of the Solar System while delivering presents to other planets! To accurately calculate his position in space, safely align his warp drive, and return to Earth in time to save Christmas, he needs you to bring him measurements from fifty stars.

Collect stars by solving puzzles. Two puzzles will be made available on each day in the Advent calendar; the second puzzle is unlocked when you complete the first. Each puzzle grants one star. Good luck!

The Elves quickly load you into a spacecraft and prepare to launch.

At the first Go / No Go poll, every Elf is Go until the Fuel Counter-Upper. They haven't determined the amount of fuel required yet.

Fuel required to launch a given module is based on its mass. Specifically, to find the fuel required for a module, take its mass, divide by three, round down, and subtract 2.

For example:

    For a mass of 12, divide by 3 and round down to get 4, then subtract 2 to get 2.
    For a mass of 14, dividing by 3 and rounding down still yields 4, so the fuel required is also 2.
    For a mass of 1969, the fuel required is 654.
    For a mass of 100756, the fuel required is 33583.

The Fuel Counter-Upper needs to know the total fuel requirement. To find it, individually calculate the fuel needed for the mass of each module (your puzzle input), then add together all the fuel values.

What is the sum of the fuel requirements for all of the modules on your spacecraft?

Your puzzle answer was 3360301.
--- Part Two ---

During the second Go / No Go poll, the Elf in charge of the Rocket Equation Double-Checker stops the launch sequence. Apparently, you forgot to include additional fuel for the fuel you just added.

Fuel itself requires fuel just like a module - take its mass, divide by three, round down, and subtract 2. However, that fuel also requires fuel, and that fuel requires fuel, and so on. Any mass that would require negative fuel should instead be treated as if it requires zero fuel; the remaining mass, if any, is instead handled by wishing really hard, which has no mass and is outside the scope of this calculation.

So, for each module mass, calculate its fuel and add it to the total. Then, treat the fuel amount you just calculated as the input mass and repeat the process, continuing until a fuel requirement is zero or negative. For example:

    A module of mass 14 requires 2 fuel. This fuel requires no further fuel (2 divided by 3 and rounded down is 0, which would call for a negative fuel), so the total fuel required is still just 2.
    At first, a module of mass 1969 requires 654 fuel. Then, this fuel requires 216 more fuel (654 / 3 - 2). 216 then requires 70 more fuel, which requires 21 fuel, which requires 5 fuel, which requires no further fuel. So, the total fuel required for a module of mass 1969 is 654 + 216 + 70 + 21 + 5 = 966.
    The fuel required by a module of mass 100756 and its fuel is: 33583 + 11192 + 3728 + 1240 + 411 + 135 + 43 + 12 + 2 = 50346.

What is the sum of the fuel requirements for all of the modules on your spacecraft when also taking into account the mass of the added fuel? (Calculate the fuel requirements for each module separately, then add them all up at the end.)

Your puzzle answer was 5037595.

Both parts of this puzzle are complete! They provide two gold stars: **
** star 1
 - <2019-12-01 Sun 08:53>
#+BEGIN_SRC cpp :results output
#include <stdio.h>
int main(int argc, char** args) {
  FILE *f = fopen("01.txt", "r");

  int fuelsum = 0;
  int mass = -1;
  while (1 == fscanf(f, "%d\n", &mass)) {
    int fuel = (int) (mass / 3) - 2;
    fuelsum += fuel;
  }
  printf("= %d\n", fuelsum);
}
#+END_SRC

#+RESULTS:
: = 3360301
 - <2019-12-01 Sun 09:00>
** star 2
 - <2019-12-01 Sun>
#+BEGIN_SRC cpp :results output
  #include <stdio.h>
  int main(int argc, char** args) {
    FILE *f = fopen("01.txt", "r");

    int sum = 0;
    int mass;
    while (1 == fscanf(f, "%d\n", &mass)) {
      int fuelsum = 0;
      while (mass > 0) {
        int fuel = (int) (mass / 3) - 2;
        if (fuel > 0) {
          fuelsum += fuel;
        }
        mass = fuel;
      }
      sum += fuelsum;
    }
    printf("= %d\n", sum);
  }
#+END_SRC

#+RESULTS:
: = 5037595
 - <2019-12-01 Sun 09:05>
* day 2
** puzzle
--- Day 2: 1202 Program Alarm ---

On the way to your gravity assist around the Moon, your ship computer beeps angrily about a "1202 program alarm". On the radio, an Elf is already explaining how to handle the situation: "Don't worry, that's perfectly norma--" The ship computer bursts into flames.

You notify the Elves that the computer's magic smoke seems to have escaped. "That computer ran Intcode programs like the gravity assist program it was working on; surely there are enough spare parts up there to build a new Intcode computer!"

An Intcode program is a list of integers separated by commas (like 1,0,0,3,99). To run one, start by looking at the first integer (called position 0). Here, you will find an opcode - either 1, 2, or 99. The opcode indicates what to do; for example, 99 means that the program is finished and should immediately halt. Encountering an unknown opcode means something went wrong.

Opcode 1 adds together numbers read from two positions and stores the result in a third position. The three integers immediately after the opcode tell you these three positions - the first two indicate the positions from which you should read the input values, and the third indicates the position at which the output should be stored.

For example, if your Intcode computer encounters 1,10,20,30, it should read the values at positions 10 and 20, add those values, and then overwrite the value at position 30 with their sum.

Opcode 2 works exactly like opcode 1, except it multiplies the two inputs instead of adding them. Again, the three integers after the opcode indicate where the inputs and outputs are, not their values.

Once you're done processing an opcode, move to the next one by stepping forward 4 positions.

For example, suppose you have the following program:

1,9,10,3,2,3,11,0,99,30,40,50

For the purposes of illustration, here is the same program split into multiple lines:

1,9,10,3,
2,3,11,0,
99,
30,40,50

The first four integers, 1,9,10,3, are at positions 0, 1, 2, and 3. Together, they represent the first opcode (1, addition), the positions of the two inputs (9 and 10), and the position of the output (3). To handle this opcode, you first need to get the values at the input positions: position 9 contains 30, and position 10 contains 40. Add these numbers together to get 70. Then, store this value at the output position; here, the output position (3) is at position 3, so it overwrites itself. Afterward, the program looks like this:

1,9,10,70,
2,3,11,0,
99,
30,40,50

Step forward 4 positions to reach the next opcode, 2. This opcode works just like the previous, but it multiplies instead of adding. The inputs are at positions 3 and 11; these positions contain 70 and 50 respectively. Multiplying these produces 3500; this is stored at position 0:

3500,9,10,70,
2,3,11,0,
99,
30,40,50

Stepping forward 4 more positions arrives at opcode 99, halting the program.

Here are the initial and final states of a few more small programs:

    1,0,0,0,99 becomes 2,0,0,0,99 (1 + 1 = 2).
    2,3,0,3,99 becomes 2,3,0,6,99 (3 * 2 = 6).
    2,4,4,5,99,0 becomes 2,4,4,5,99,9801 (99 * 99 = 9801).
    1,1,1,4,99,5,6,0,99 becomes 30,1,1,4,2,5,6,0,99.

Once you have a working computer, the first step is to restore the gravity assist program (your puzzle input) to the "1202 program alarm" state it had just before the last computer caught fire. To do this, before running the program, replace position 1 with the value 12 and replace position 2 with the value 2. What value is left at position 0 after the program halts?

Your puzzle answer was 4945026.
--- Part Two ---

"Good, the new computer seems to be working correctly! Keep it nearby during this mission - you'll probably use it again. Real Intcode computers support many more features than your new one, but we'll let you know what they are as you need them."

"However, your current priority should be to complete your gravity assist around the Moon. For this mission to succeed, we should settle on some terminology for the parts you've already built."

Intcode programs are given as a list of integers; these values are used as the initial state for the computer's memory. When you run an Intcode program, make sure to start by initializing memory to the program's values. A position in memory is called an address (for example, the first value in memory is at "address 0").

Opcodes (like 1, 2, or 99) mark the beginning of an instruction. The values used immediately after an opcode, if any, are called the instruction's parameters. For example, in the instruction 1,2,3,4, 1 is the opcode; 2, 3, and 4 are the parameters. The instruction 99 contains only an opcode and has no parameters.

The address of the current instruction is called the instruction pointer; it starts at 0. After an instruction finishes, the instruction pointer increases by the number of values in the instruction; until you add more instructions to the computer, this is always 4 (1 opcode + 3 parameters) for the add and multiply instructions. (The halt instruction would increase the instruction pointer by 1, but it halts the program instead.)

"With terminology out of the way, we're ready to proceed. To complete the gravity assist, you need to determine what pair of inputs produces the output 19690720."

The inputs should still be provided to the program by replacing the values at addresses 1 and 2, just like before. In this program, the value placed in address 1 is called the noun, and the value placed in address 2 is called the verb. Each of the two input values will be between 0 and 99, inclusive.

Once the program has halted, its output is available at address 0, also just like before. Each time you try a pair of inputs, make sure you first reset the computer's memory to the values in the program (your puzzle input) - in other words, don't reuse memory from a previous attempt.

Find the input noun and verb that cause the program to produce the output 19690720. What is 100 * noun + verb? (For example, if noun=12 and verb=2, the answer would be 1202.)

Your puzzle answer was 5296.

Both parts of this puzzle are complete! They provide two gold stars: **
** part 1
 - <2019-12-02 Mon 20:19>
#+BEGIN_SRC cpp :results output
  #include <stdio.h>
  int main(int argc, char **args) {
      int positions[100000];
      FILE *f = fopen("02.txt", "r");

      for (int i = 0; i < 10000; i++) {
          if (fscanf(f, "%d", &positions[i]) != 1) {
              break;
          }
          fscanf(f, ",");
      }

      positions[1] = 12;
      positions[2] = 2;

      // int k = 0;
      // positions[k++] = 1;
      // positions[k++] = 1;
      // positions[k++] = 1;
      // positions[k++] = 4;
      // positions[k++] = 99;
      // positions[k++] = 5;
      // positions[k++] = 6;
      // positions[k++] = 0;
      // positions[k++] = 99;

      // int k = 0;
      // positions[k++] = 1;
      // positions[k++] = 0;
      // positions[k++] = 0;
      // positions[k++] = 0;
      // positions[k++] = 99;

      for (int i = 0; i < 10000; i += 4) {
        if (positions[i] == 99) {
          break;
        } else if (positions[i] == 1) {
          positions[positions[i+3]] = positions[positions[i+1]] + positions[positions[i+2]];
        } else if (positions[i] == 2) {
          positions[positions[i+3]] = positions[positions[i+1]] * positions[positions[i+2]];
        } else {
          printf("Error: %d: %d\n", i, positions[i]);
          return 0;
        }
      }

      printf("= %d\n", positions[0]);
      return 0;
  }
#+END_SRC

#+RESULTS:
: = 4945026

 - 145 too low <2019-12-02 Mon 20:37>
 - 4945026 <2019-12-02 Mon 20:40>
** part 2
 - <2019-12-02 Mon 20:41>
#+BEGIN_SRC cpp :results output
  #include <stdio.h>
  #define MAX 100000

  int run(int program[]) {
    int p[MAX];
    for (int i = 0; i < MAX; i++) {
      p[i] = program[i];
    }

      for (int i = 0; i < 10000; i += 4) {
        if (p[i] == 99) {
          break;
        } else if (p[i] == 1) {
          p[p[i+3]] = p[p[i+1]] + p[p[i+2]];
        } else if (p[i] == 2) {
          p[p[i+3]] = p[p[i+1]] * p[p[i+2]];
        } else {
          printf("Error: %d: %d\n", i, p[i]);
          return 0;
        }
      }
      return p[0];
  }

  int main(int argc, char **args) {
      int positions[MAX];
      FILE *f = fopen("02.txt", "r");

      for (int i = 0; i < 10000; i++) {
          if (fscanf(f, "%d", &positions[i]) != 1) {
              break;
          }
          fscanf(f, ",");
      }

      for (int noun = 0; noun <= 99; noun++) {
        for (int verb = 0; verb <= 99; verb++) {
          positions[1] = noun;
          positions[2] = verb;
          if (run(positions) == 19690720) {
            printf("verb=%d, noun=%d\n", verb, noun);
            printf("= %d\n", 100 * noun + verb);
            return 0;
          }
        }
      }
      printf("Not found!");
      return 0;
  }
#+END_SRC

#+RESULTS:
: verb=96, noun=52
: = 5296

 - 499200 too high <2019-12-02 Mon 20:46>
 - 5296 right answer <2019-12-02 Mon 20:48>
* day 3
** puzzle
--- Day 3: Crossed Wires ---

The gravity assist was successful, and you're well on your way to the Venus refuelling station. During the rush back on Earth, the fuel management system wasn't completely installed, so that's next on the priority list.

Opening the front panel reveals a jumble of wires. Specifically, two wires are connected to a central port and extend outward on a grid. You trace the path each wire takes as it leaves the central port, one wire per line of text (your puzzle input).

The wires twist and turn, but the two wires occasionally cross paths. To fix the circuit, you need to find the intersection point closest to the central port. Because the wires are on a grid, use the Manhattan distance for this measurement. While the wires do technically cross right at the central port where they both start, this point does not count, nor does a wire count as crossing with itself.

For example, if the first wire's path is R8,U5,L5,D3, then starting from the central port (o), it goes right 8, up 5, left 5, and finally down 3:

...........
...........
...........
....+----+.
....|....|.
....|....|.
....|....|.
.........|.
.o-------+.
...........

Then, if the second wire's path is U7,R6,D4,L4, it goes up 7, right 6, down 4, and left 4:

...........
.+-----+...
.|.....|...
.|..+--X-+.
.|..|..|.|.
.|.-X--+.|.
.|..|....|.
.|.......|.
.o-------+.
...........

These wires cross at two locations (marked X), but the lower-left one is closer to the central port: its distance is 3 + 3 = 6.

Here are a few more examples:

    R75,D30,R83,U83,L12,D49,R71,U7,L72
    U62,R66,U55,R34,D71,R55,D58,R83 = distance 159
    R98,U47,R26,D63,R33,U87,L62,D20,R33,U53,R51
    U98,R91,D20,R16,D67,R40,U7,R15,U6,R7 = distance 135

What is the Manhattan distance from the central port to the closest intersection?

Your puzzle answer was 221.
--- Part Two ---

It turns out that this circuit is very timing-sensitive; you actually need to minimize the signal delay.

To do this, calculate the number of steps each wire takes to reach each intersection; choose the intersection where the sum of both wires' steps is lowest. If a wire visits a position on the grid multiple times, use the steps value from the first time it visits that position when calculating the total value of a specific intersection.

The number of steps a wire takes is the total number of grid squares the wire has entered to get to that location, including the intersection being considered. Again consider the example from above:

...........
.+-----+...
.|.....|...
.|..+--X-+.
.|..|..|.|.
.|.-X--+.|.
.|..|....|.
.|.......|.
.o-------+.
...........

In the above example, the intersection closest to the central port is reached after 8+5+5+2 = 20 steps by the first wire and 7+6+4+3 = 20 steps by the second wire for a total of 20+20 = 40 steps.

However, the top-right intersection is better: the first wire takes only 8+5+2 = 15 and the second wire takes only 7+6+2 = 15, a total of 15+15 = 30 steps.

Here are the best steps for the extra examples from above:

    R75,D30,R83,U83,L12,D49,R71,U7,L72
    U62,R66,U55,R34,D71,R55,D58,R83 = 610 steps
    R98,U47,R26,D63,R33,U87,L62,D20,R33,U53,R51
    U98,R91,D20,R16,D67,R40,U7,R15,U6,R7 = 410 steps

What is the fewest combined steps the wires must take to reach an intersection?

Your puzzle answer was 18542.

Both parts of this puzzle are complete! They provide two gold stars: **
** part 1
 - <2019-12-03 Tue 18:46>
#+BEGIN_SRC cpp :results output
  #include <stdio.h>
  #include <stdlib.h>
  #define BUF 30000
  int main(int argc, char **args) {
    // char grid[BUF][BUF] = { 0 };

    int **grid = (int **) malloc(BUF * sizeof(int *));
    for (int i = 0; i < BUF; i++) {
      grid[i] = (int *) malloc(BUF * sizeof(int));
      for (int j = 0; j < BUF; j++) {
        grid[i][j] = 0;
      }
    }

    FILE *f = fopen("03.txt", "r");
    int x = BUF/2;
    int y = BUF/2;
    while (true) {
      char c;
      int i;
      if (fscanf(f, "%c%d", &c, &i) != 2) {
        break;
      }
      // printf("%c%d\n", c, i);

      for (int j = 0; j < i; j++) {
        if (c == 'L') x--;
        if (c == 'R') x++;
        if (c == 'U') y--;
        if (c == 'D') y++;
        if (y >= BUF || y < 0 || x >= BUF || x < 0) {
          printf("!!! %d,%d\n", x, y);
          return 0;
        }
        grid[y][x] = 1;
        // printf("1 %d,%d\n", x, y);
      }

      fscanf(f, ",");
    }
    fscanf(f, "\n");

    x = y = BUF/2;

    int closestIntersectionDistance = 99999;

    while (true) {
      char c;
      int i;
      if (fscanf(f, "%c%d", &c, &i) != 2) {
        break;
      }

      for (int j = 0; j < i; j++) {
        if (c == 'L') x--;
        if (c == 'R') x++;
        if (c == 'U') y--;
        if (c == 'D') y++;
        if (y >= BUF || y < 0 || x >= BUF || x < 0) {
          printf("!!! %d,%d\n", x, y);
          return 0;
        }
        // printf("2 %d,%d = %d\n", x, y, grid[y][x]);
        if (grid[y][x] == 1) {
          int dist = (x > BUF/2 ? x - BUF/2 : BUF/2 - x) + (y > BUF/2 ? y - BUF/2 : BUF/2 - y);
          if (dist < closestIntersectionDistance) {
            closestIntersectionDistance = dist;
          }
        }
        grid[y][x] = 2;
      }
      fscanf(f, ",");
    }


    printf("= %d\n", closestIntersectionDistance);
    return 0;
  }
#+END_SRC

#+RESULTS:
: = 221

 - 11917 too high <2019-12-03 Tue 19:27>
 - 211 correct <2019-12-03 Tue 19:33>
** part 2
#+BEGIN_SRC cpp :results output
  #include <stdio.h>
  #include <stdlib.h>
  #define BUF 30000
  int main(int argc, char **args) {
    // char grid[BUF][BUF] = { 0 };

    int **grid = (int **) malloc(BUF * sizeof(int *));
    for (int i = 0; i < BUF; i++) {
      grid[i] = (int *) malloc(BUF * sizeof(int));
      for (int j = 0; j < BUF; j++) {
        grid[i][j] = 0;
      }
    }

    FILE *f = fopen("03.txt", "r");
    int x = BUF/2;
    int y = BUF/2;
    int step = 1;
    while (true) {
      char c;
      int i;
      if (fscanf(f, "%c%d", &c, &i) != 2) {
        break;
      }
      // printf("%c%d\n", c, i);

      for (int j = 0; j < i; j++) {
        if (c == 'L') x--;
        if (c == 'R') x++;
        if (c == 'U') y--;
        if (c == 'D') y++;
        if (y >= BUF || y < 0 || x >= BUF || x < 0) {
          printf("!!! %d,%d\n", x, y);
          return 0;
        }
        if (grid[y][x] == 0) {
          grid[y][x] = step;
        }
        step++;
        // printf("1 %d,%d\n", x, y);
      }

      fscanf(f, ",");
    }
    fscanf(f, "\n");

    x = y = BUF/2;

    int minimumSteps = 999999;

    step = 1;
    while (true) {
      char c;
      int i;
      if (fscanf(f, "%c%d", &c, &i) != 2) {
        break;
      }

      for (int j = 0; j < i; j++) {
        if (c == 'L') x--;
        if (c == 'R') x++;
        if (c == 'U') y--;
        if (c == 'D') y++;
        if (y >= BUF || y < 0 || x >= BUF || x < 0) {
          printf("!!! %d,%d\n", x, y);
          return 0;
        }
        // printf("2 %d,%d = %d\n", x, y, grid[y][x]);
        if (grid[y][x] >= 1) {
          if (grid[y][x] + step < minimumSteps) {
            minimumSteps = grid[y][x] + step;
          }
        }
        step++;
      }
      fscanf(f, ",");
    }


    printf("= %d\n", minimumSteps);
    return 0;
  }
#+END_SRC

#+RESULTS:
: = 18542

 - 18542 correct <2019-12-03 Tue 19:39> 
* day 4
** puzzle
--- Day 4: Secure Container ---

You arrive at the Venus fuel depot only to discover it's protected by a password. The Elves had written the password on a sticky note, but someone threw it out.

However, they do remember a few key facts about the password:

    It is a six-digit number.
    The value is within the range given in your puzzle input.
    Two adjacent digits are the same (like 22 in 122345).
    Going from left to right, the digits never decrease; they only ever increase or stay the same (like 111123 or 135679).

Other than the range rule, the following are true:

    111111 meets these criteria (double 11, never decreases).
    223450 does not meet these criteria (decreasing pair of digits 50).
    123789 does not meet these criteria (no double).

How many different passwords within the range given in your puzzle input meet these criteria?

Your puzzle answer was 1169.
--- Part Two ---

An Elf just remembered one more important detail: the two adjacent matching digits are not part of a larger group of matching digits.

Given this additional criterion, but still ignoring the range rule, the following are now true:

    112233 meets these criteria because the digits never decrease and all repeated digits are exactly two digits long.
    123444 no longer meets the criteria (the repeated 44 is part of a larger group of 444).
    111122 meets the criteria (even though 1 is repeated more than twice, it still contains a double 22).

How many different passwords within the range given in your puzzle input meet all of the criteria?

Your puzzle answer was 757.

Both parts of this puzzle are complete! They provide two gold stars: **
** part 1
 - <2019-12-04 Wed 18:20>
#+BEGIN_SRC cpp :results output
  #include <stdio.h>
  int main(int argc, char **args) {
      char s[1024];
      int valids = 0;
      for (int i = 236491; i <= 713787; i++) {
          sprintf(s, "%d", i);
          int foundDuplicate = 0;
          int increasing = 1;
          int prev = s[0];
          for (int j = 1; s[j] != 0; j++) {
              if (prev == s[j]) foundDuplicate = 1;
              if (prev > s[j]) { 
                increasing = 0; 
                break; 
              }
              prev = s[j];
          }
          if (foundDuplicate && increasing) {
              //printf("= %d\n", i);
              valids++;
          }
      }
      printf("= %d\n", valids);
      return 0;
  }
#+END_SRC

#+RESULTS:
: = 1169

 - 1169 correct <2019-12-04 Wed 18:28>
** part 2
#+BEGIN_SRC cpp :results output
  #include <stdio.h>
  int main(int argc, char **args) {
      char s[1024];
      int valids = 0;
      for (int i = 236491; i <= 713787; i++) {
      //{ int i = 111122;
          sprintf(s, "%d", i);
          int foundDuplicate = 0;
          int increasing = 1;
          for (int j = 1; s[j] != 0; j++) {
            if (s[j] == s[j-1]) {
              if (j >= 2 && s[j-2] == s[j])
                ; // no
              else if (s[j+1] == s[j])
                ; // no
              else
                foundDuplicate = 1;
            }
            if (s[j-1] > s[j]) {
                increasing = 0; 
                break; 
              }
          }
          if (foundDuplicate && increasing) {
              //printf("= %d\n", i);
              valids++;
          }
      }
      printf("= %d\n", valids);
      return 0;
  }
#+END_SRC

#+RESULTS:
: = 757

 - 487 too low <2019-12-04 Wed 18:30>
 - 1165 too high <2019-12-04 Wed 18:34>
 - 757 right answer <2019-12-04 Wed 18:45>
* day 5
** puzzle
--- Day 5: Sunny with a Chance of Asteroids ---

You're starting to sweat as the ship makes its way toward Mercury. The Elves suggest that you get the air conditioner working by upgrading your ship computer to support the Thermal Environment Supervision Terminal.

The Thermal Environment Supervision Terminal (TEST) starts by running a diagnostic program (your puzzle input). The TEST diagnostic program will run on your existing Intcode computer after a few modifications:

First, you'll need to add two new instructions:

    Opcode 3 takes a single integer as input and saves it to the position given by its only parameter. For example, the instruction 3,50 would take an input value and store it at address 50.
    Opcode 4 outputs the value of its only parameter. For example, the instruction 4,50 would output the value at address 50.

Programs that use these instructions will come with documentation that explains what should be connected to the input and output. The program 3,0,4,0,99 outputs whatever it gets as input, then halts.

Second, you'll need to add support for parameter modes:

Each parameter of an instruction is handled based on its parameter mode. Right now, your ship computer already understands parameter mode 0, position mode, which causes the parameter to be interpreted as a position - if the parameter is 50, its value is the value stored at address 50 in memory. Until now, all parameters have been in position mode.

Now, your ship computer will also need to handle parameters in mode 1, immediate mode. In immediate mode, a parameter is interpreted as a value - if the parameter is 50, its value is simply 50.

Parameter modes are stored in the same value as the instruction's opcode. The opcode is a two-digit number based only on the ones and tens digit of the value, that is, the opcode is the rightmost two digits of the first value in an instruction. Parameter modes are single digits, one per parameter, read right-to-left from the opcode: the first parameter's mode is in the hundreds digit, the second parameter's mode is in the thousands digit, the third parameter's mode is in the ten-thousands digit, and so on. Any missing modes are 0.

For example, consider the program 1002,4,3,4,33.

The first instruction, 1002,4,3,4, is a multiply instruction - the rightmost two digits of the first value, 02, indicate opcode 2, multiplication. Then, going right to left, the parameter modes are 0 (hundreds digit), 1 (thousands digit), and 0 (ten-thousands digit, not present and therefore zero):

ABCDE
 1002

DE - two-digit opcode,      02 == opcode 2
 C - mode of 1st parameter,  0 == position mode
 B - mode of 2nd parameter,  1 == immediate mode
 A - mode of 3rd parameter,  0 == position mode,
                                  omitted due to being a leading zero

This instruction multiplies its first two parameters. The first parameter, 4 in position mode, works like it did before - its value is the value stored at address 4 (33). The second parameter, 3 in immediate mode, simply has value 3. The result of this operation, 33 * 3 = 99, is written according to the third parameter, 4 in position mode, which also works like it did before - 99 is written to address 4.

Parameters that an instruction writes to will never be in immediate mode.

Finally, some notes:

    It is important to remember that the instruction pointer should increase by the number of values in the instruction after the instruction finishes. Because of the new instructions, this amount is no longer always 4.
    Integers can be negative: 1101,100,-1,4,0 is a valid program (find 100 + -1, store the result in position 4).

The TEST diagnostic program will start by requesting from the user the ID of the system to test by running an input instruction - provide it 1, the ID for the ship's air conditioner unit.

It will then perform a series of diagnostic tests confirming that various parts of the Intcode computer, like parameter modes, function correctly. For each test, it will run an output instruction indicating how far the result of the test was from the expected value, where 0 means the test was successful. Non-zero outputs mean that a function is not working correctly; check the instructions that were run before the output instruction to see which one failed.

Finally, the program will output a diagnostic code and immediately halt. This final output isn't an error; an output followed immediately by a halt means the program finished. If all outputs were zero except the diagnostic code, the diagnostic program ran successfully.

After providing 1 to the only input instruction and passing all the tests, what diagnostic code does the program produce?

Your puzzle answer was 12234644.
--- Part Two ---

The air conditioner comes online! Its cold air feels good for a while, but then the TEST alarms start to go off. Since the air conditioner can't vent its heat anywhere but back into the spacecraft, it's actually making the air inside the ship warmer.

Instead, you'll need to use the TEST to extend the thermal radiators. Fortunately, the diagnostic program (your puzzle input) is already equipped for this. Unfortunately, your Intcode computer is not.

Your computer is only missing a few opcodes:

    Opcode 5 is jump-if-true: if the first parameter is non-zero, it sets the instruction pointer to the value from the second parameter. Otherwise, it does nothing.
    Opcode 6 is jump-if-false: if the first parameter is zero, it sets the instruction pointer to the value from the second parameter. Otherwise, it does nothing.
    Opcode 7 is less than: if the first parameter is less than the second parameter, it stores 1 in the position given by the third parameter. Otherwise, it stores 0.
    Opcode 8 is equals: if the first parameter is equal to the second parameter, it stores 1 in the position given by the third parameter. Otherwise, it stores 0.

Like all instructions, these instructions need to support parameter modes as described above.

Normally, after an instruction is finished, the instruction pointer increases by the number of values in that instruction. However, if the instruction modifies the instruction pointer, that value is used and the instruction pointer is not automatically increased.

For example, here are several programs that take one input, compare it to the value 8, and then produce one output:

    3,9,8,9,10,9,4,9,99,-1,8 - Using position mode, consider whether the input is equal to 8; output 1 (if it is) or 0 (if it is not).
    3,9,7,9,10,9,4,9,99,-1,8 - Using position mode, consider whether the input is less than 8; output 1 (if it is) or 0 (if it is not).
    3,3,1108,-1,8,3,4,3,99 - Using immediate mode, consider whether the input is equal to 8; output 1 (if it is) or 0 (if it is not).
    3,3,1107,-1,8,3,4,3,99 - Using immediate mode, consider whether the input is less than 8; output 1 (if it is) or 0 (if it is not).

Here are some jump tests that take an input, then output 0 if the input was zero or 1 if the input was non-zero:

    3,12,6,12,15,1,13,14,13,4,13,99,-1,0,1,9 (using position mode)
    3,3,1105,-1,9,1101,0,0,12,4,12,99,1 (using immediate mode)

Here's a larger example:

3,21,1008,21,8,20,1005,20,22,107,8,21,20,1006,20,31,
1106,0,36,98,0,0,1002,21,125,20,4,20,1105,1,46,104,
999,1105,1,46,1101,1000,1,20,4,20,1105,1,46,98,99

The above example program uses an input instruction to ask for a single number. The program will then output 999 if the input value is below 8, output 1000 if the input value is equal to 8, or output 1001 if the input value is greater than 8.

This time, when the TEST diagnostic program runs its input instruction to get the ID of the system to test, provide it 5, the ID for the ship's thermal radiator controller. This diagnostic test suite only outputs one number, the diagnostic code.

What is the diagnostic code for system ID 5?

Your puzzle answer was 3508186.

Both parts of this puzzle are complete! They provide two gold stars: **
** part 1
 - <2019-12-05 Thu 18:16>
#+BEGIN_SRC cpp :results output
  #include <stdio.h>
  #include <stdlib.h>
  #include <stdarg.h>
  #define MAX 100000

  void die(const char *s) {
    printf("%s\n", s);
    exit(1);
  }

  void info(const char * format, ...) {
    return;
    va_list arglist;
    va_start(arglist, format);
    vprintf(format, arglist);
    va_end(arglist);
  }

  int run(int program[]) {
    int p[MAX];
    for (int i = 0; i < MAX; i++) {
      p[i] = program[i];
    }

      for (int i = 0; i < 10000;) {
        int opcode = p[i] % 100;
        int p1mode = (p[i] / 100) % 10;
        int p2mode = (p[i] / 1000) % 10;
        int p3mode = (p[i] / 10000) % 10;
        if (opcode == 99) {
          break;
        } else if (opcode == 1) { // +
          info("%4d: %d %d %d %d\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          if (p3mode == 1) die("opcode 1 had p3mode");
          p[p[i+3]] = (p1mode ? p[i+1] : p[p[i+1]]) + (p2mode ? p[i+2] : p[p[i+2]]);
          i += 4;
        } else if (opcode == 2) { // *
          info("%4d: %d %d %d %d\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          if (p3mode == 1) die("opcode 2 had p3mode");
          p[p[i+3]] = (p1mode ? p[i+1] : p[p[i+1]]) * (p2mode ? p[i+2] : p[p[i+2]]);
          i += 4;
        } else if (opcode == 3) { // input
          info("%4d: %d %d\n", i, p[i], p[i+1]);
          p[p[i+1]] = 1;
          i += 2;
        } else if (opcode == 4) { // output
          info("%4d: %d %d\n", i, p[i], p[i+1]);
          printf("output %d\n", p1mode ? p[i+1] : p[p[i+1]]);
          i += 2;
        } else {
          printf("Error: %d: %d\n", i, p[i]);
          return 0;
        }
      }
      return p[0];
  }

  int main(int argc, char **args) {
      int positions[MAX];
      FILE *f = fopen("05.txt", "r");

      for (int i = 0; i < MAX; i++) {
          if (fscanf(f, "%d", &positions[i]) != 1) {
              break;
          }
          fscanf(f, ",");
      }

      run(positions);

      return 0;
  }
#+END_SRC

#+RESULTS:
#+begin_example
output 0
output 0
output 0
output 0
output 0
output 0
output 0
output 0
output 0
output 12234644
#+end_example

 - 12234644 correct <2019-12-05 Thu 18:46>
** part 2
 - <2019-12-05 Thu 18:46>
#+BEGIN_SRC cpp :results output
  #include <stdio.h>
  #include <stdlib.h>
  #include <stdarg.h>
  #define MAX 100000

  void die(const char *s) {
    printf("%s\n", s);
    exit(0);
  }

  void info(const char * format, ...) {
    return;
    va_list arglist;
    va_start(arglist, format);
    vprintf(format, arglist);
    va_end(arglist);
  }

  int run(int program[], int input) {
    int p[MAX];
    for (int i = 0; i < MAX; i++) {
      p[i] = program[i];
    }
    int lastoutput = -1;
      for (int i = 0; i < 10000;) {
        int opcode = p[i] % 100;
        int p1mode = (p[i] / 100) % 10;
        int p2mode = (p[i] / 1000) % 10;
        int p3mode = (p[i] / 10000) % 10;
        if (opcode == 99) {
          break;
        } else if (opcode == 1) { // +
          info("%4d: %d %d %d %d\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          if (p3mode == 1) die("opcode 1 had p3mode");
          p[p[i+3]] = (p1mode ? p[i+1] : p[p[i+1]]) + (p2mode ? p[i+2] : p[p[i+2]]);
          i += 4;
        } else if (opcode == 2) { // *
          info("%4d: %d %d %d %d\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          if (p3mode == 1) die("opcode 2 had p3mode");
          p[p[i+3]] = (p1mode ? p[i+1] : p[p[i+1]]) * (p2mode ? p[i+2] : p[p[i+2]]);
          i += 4;
        } else if (opcode == 3) { // input
          info("%4d: %d %d\n", i, p[i], p[i+1]);
          p[p[i+1]] = input;
          i += 2;
        } else if (opcode == 4) { // output
          info("%4d: %d %d\n", i, p[i], p[i+1]);
          lastoutput = p1mode ? p[i+1] : p[p[i+1]];
          printf("output %d\n", lastoutput);
          i += 2;
        } else if (opcode == 5) { // jump-if-true
          info("%4d: %d %d %d\n", i, p[i], p[i+1], p[i+2]);
          if (0 != (p1mode ? p[i+1] : p[p[i+1]]))
            i = p2mode ? p[i+2] : p[p[i+2]];
          else
            i += 3;
        } else if (opcode == 6) { // jump-if-false
          info("%4d: %d %d %d\n", i, p[i], p[i+1], p[i+2]);
          if (0 == (p1mode ? p[i+1] : p[p[i+1]]))
            i = p2mode ? p[i+2] : p[p[i+2]];
          else
            i += 3;
        } else if (opcode == 7) { // less than
          info("%4d: %d %d %d %d\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          if ((p1mode ? p[i+1] : p[p[i+1]]) < (p2mode ? p[i+2] : p[p[i+2]]))
            p[p[i+3]] = 1;
          else
            p[p[i+3]] = 0;
          i += 4;
        } else if (opcode == 8) { // equal to
          info("%4d: %d %d %d %d\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          if ((p1mode ? p[i+1] : p[p[i+1]]) == (p2mode ? p[i+2] : p[p[i+2]]))
            p[p[i+3]] = 1;
          else
            p[p[i+3]] = 0;
          i += 4;
        } else {
          printf("Error: %d: %d\n", i, p[i]);
          return 0;
        }
      }
      return lastoutput;
  }

  int main(int argc, char **args) {
      int positions[MAX];
      FILE *f = fopen("05.txt", "r");

      for (int i = 0; i < MAX; i++) {
          if (fscanf(f, "%d", &positions[i]) != 1) {
              break;
          }
          fscanf(f, ",");
      }

      run(positions, 5);

      // int test1[] = { 3,9,8,9,10,9,4,9,99,-1,8 };
      // run(test1, 8);
      // int test2[] = { 3,9,7,9,10,9,4,9,99,-1,8 };
      // run(test2, -9);
      // int test3[] = { 3,3,1108,-1,8,3,4,3,99 };
      // run(test3, 8);
      // int test4[] = { 3,3,1107,-1,8,3,4,3,99 };
      // run(test4, 2);
      // int test5[] = { 3,12,6,12,15,1,13,14,13,4,13,99,-1,0,1,9 };
      // run(test5, 5);
      // int test6[] = { 3,3,1105,-1,9,1101,0,0,12,4,12,99,1 };
      // run(test6, 0);
      // int test7[] = {3,21,1008,21,8,20,1005,20,22,107,8,21,20,1006,20,31,
      //                1106,0,36,98,0,0,1002,21,125,20,4,20,1105,1,46,104,
      //                999,1105,1,46,1101,1000,1,20,4,20,1105,1,46,98,99};
      // run(test7, 9);

      return 0;
  }
#+END_SRC

#+RESULTS:
: output 3508186

 - correct 3508186 <2019-12-05 Thu 19:04>

* day 6
** puzzle
--- Day 6: Universal Orbit Map ---

You've landed at the Universal Orbit Map facility on Mercury. Because navigation in space often involves transferring between orbits, the orbit maps here are useful for finding efficient routes between, for example, you and Santa. You download a map of the local orbits (your puzzle input).

Except for the universal Center of Mass (COM), every object in space is in orbit around exactly one other object. An orbit looks roughly like this:

                  \
                   \
                    |
                    |
AAA--> o            o <--BBB
                    |
                    |
                   /
                  /

In this diagram, the object BBB is in orbit around AAA. The path that BBB takes around AAA (drawn with lines) is only partly shown. In the map data, this orbital relationship is written AAA)BBB, which means "BBB is in orbit around AAA".

Before you use your map data to plot a course, you need to make sure it wasn't corrupted during the download. To verify maps, the Universal Orbit Map facility uses orbit count checksums - the total number of direct orbits (like the one shown above) and indirect orbits.

Whenever A orbits B and B orbits C, then A indirectly orbits C. This chain can be any number of objects long: if A orbits B, B orbits C, and C orbits D, then A indirectly orbits D.

For example, suppose you have the following map:

COM)B
B)C
C)D
D)E
E)F
B)G
G)H
D)I
E)J
J)K
K)L

Visually, the above map of orbits looks like this:

        G - H       J - K - L
       /           /
COM - B - C - D - E - F
               \
                I

In this visual representation, when two objects are connected by a line, the one on the right directly orbits the one on the left.

Here, we can count the total number of orbits as follows:

    D directly orbits C and indirectly orbits B and COM, a total of 3 orbits.
    L directly orbits K and indirectly orbits J, E, D, C, B, and COM, a total of 7 orbits.
    COM orbits nothing.

The total number of direct and indirect orbits in this example is 42.

What is the total number of direct and indirect orbits in your map data?

Your puzzle answer was 119831.
--- Part Two ---

Now, you just need to figure out how many orbital transfers you (YOU) need to take to get to Santa (SAN).

You start at the object YOU are orbiting; your destination is the object SAN is orbiting. An orbital transfer lets you move from any object to an object orbiting or orbited by that object.

For example, suppose you have the following map:

COM)B
B)C
C)D
D)E
E)F
B)G
G)H
D)I
E)J
J)K
K)L
K)YOU
I)SAN

Visually, the above map of orbits looks like this:

                          YOU
                         /
        G - H       J - K - L
       /           /
COM - B - C - D - E - F
               \
                I - SAN

In this example, YOU are in orbit around K, and SAN is in orbit around I. To move from K to I, a minimum of 4 orbital transfers are required:

    K to J
    J to E
    E to D
    D to I

Afterward, the map of orbits looks like this:

        G - H       J - K - L
       /           /
COM - B - C - D - E - F
               \
                I - SAN
                 \
                  YOU

What is the minimum number of orbital transfers required to move from the object YOU are orbiting to the object SAN is orbiting? (Between the objects they are orbiting - not between YOU and SAN.)

Your puzzle answer was 322.

Both parts of this puzzle are complete! They provide two gold stars: **
** part 1
 - <2019-12-07 Sat 10:37>
#+BEGIN_SRC cpp :results output
#include <stdio.h>
#include <string.h>
#define DEBUG 0
struct orbit {
  char *orbiter;
  char *orbitee;
};
int main(int argc, char **args) {
  struct orbit orbits[1000];
  
  int orbiti = 0;
  FILE *f = fopen("06.txt", "r");
  char line[10];
  while (NULL != fgets(line, 10, f)) {
    *strchr(line, '\n') = 0;
    char *orbiter = strchr(line, ')');
    orbiter[0] = 0;
    orbiter++;

    orbits[orbiti].orbiter = strdup(orbiter);
    orbits[orbiti].orbitee = strdup(line);
    orbiti++;
  }

  int allorbitssum = 0;
  for (int i = 0; i < orbiti; i++) {
    char *orbitee = orbits[i].orbitee;
    int orbitssum = 1;
    int foundNewOrbitee = 1;
    if (DEBUG) printf("## %s: %s", orbits[i].orbiter, orbitee);
    while (foundNewOrbitee) {
      foundNewOrbitee = 0;
      for (int j = 0; j < orbiti; j++) {
        if (0 == strcmp(orbitee, orbits[j].orbiter)) {
          if (DEBUG) printf(", %s", orbits[j].orbitee);
          foundNewOrbitee = 1;
          orbitssum++;
          orbitee = orbits[j].orbitee;
          break;
        }
      }
    }
    if (DEBUG) printf("\n");
    allorbitssum += orbitssum;
  }

  printf("= %d\n", allorbitssum);
  return 0;
}
#+END_SRC

#+RESULTS:
: = 119831

 - 119831 correct <2019-12-07 Sat 11:08>
** part 2
#+BEGIN_SRC cpp :results output
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #define DEBUG 1
  #define IDLEN 4
  struct orbit {
      char orbiter[IDLEN];
      char orbitee[IDLEN];
  };
  int findOrbit(const char *orbiter, struct orbit *orbits) {
      for (int i = 0; orbits[i].orbiter[0] != 0; i++) {
          if (0 == strcmp(orbiter, orbits[i].orbiter)) {
              return i;
          }
      }
      printf("Not found!\n");
      exit(0);
      return 0;
  }
  void getOrbitees(char **orbitees, const char *orbiter, struct orbit *orbits) {
      int i = findOrbit(orbiter, orbits);
      printf("## %d\n", i);
      char *orbitee = orbits[i].orbitee;
      int k = 0;
      orbitees[k++] = orbitee;
      int foundNewOrbitee = 1;
      if (DEBUG) printf("## %s: %s", orbits[i].orbiter, orbitee);
      while (foundNewOrbitee) {
          foundNewOrbitee = 0;
          for (int j = 0; orbits[j].orbiter[0] != 0; j++) {
              if (0 == strcmp(orbitee, orbits[j].orbiter)) {
                  if (DEBUG) printf(", %s", orbits[j].orbitee);
                  foundNewOrbitee = 1;
                  orbitee = orbits[j].orbitee;
                  orbitees[k++] = orbitee;
                  break;
              }
          }
      }
      if (DEBUG) printf("\n");
      orbitees[k] = NULL;
  }
  int main(int argc, char **args) {
      struct orbit orbits[1000];

      int orbiti = 0;
      FILE *f = fopen("06.txt", "r");
      char line[20];
      while (NULL != fgets(line, 20, f)) {
          ,*strchr(line, '\n') = 0;
          char *orbiter = strchr(line, ')');
          orbiter[0] = 0;
          orbiter++;

          strncpy(orbits[orbiti].orbiter, orbiter, IDLEN);
          strncpy(orbits[orbiti].orbitee, line, IDLEN);
          orbiti++;
      }
      orbits[orbiti].orbiter[0] = 0;
      orbits[orbiti].orbitee[0] = 0;

      char *youOrbitees[1000];
      getOrbitees(youOrbitees, "YOU", orbits);
      char *sanOrbitees[1000];
      getOrbitees(sanOrbitees, "SAN", orbits);

      for (int i = 0; youOrbitees[i] != NULL; i++) {
          for (int j = 0; sanOrbitees[j] != NULL; j++) {
              if (0 == strcmp(youOrbitees[i], sanOrbitees[j])) {
                  printf("you %d(%s), san %d(%s)\n", i, youOrbitees[i], j, sanOrbitees[j]);
                  printf("= %d\n", i + j);
                  return 0;
              }
          }
      }

      //printf("= %d\n", allorbitssum);
      return 0;
  }
#+END_SRC

#+RESULTS:
: ## 93
: ## YOU: 3LN, 9LY, BNZ, 9Z9, MRM, VD5, LR4, BJH, Y7B, 9CB, PWQ, Y7M, 9KL, HRK, KB8, ZWJ, 14X, FWY, ZT8, 2JQ, NCQ, 4Q5, RMB, HQC, YHR, 7ZP, 49N, S9Z, HNB, BHR, 57R, R87, WF9, CN9, 66V, GHS, 9WF, NDM, DH1, RP8, 51Y, 4VK, 967, ZW2, 7Q6, 7J9, GKK, C5G, C2S, G6D, XQV, YHX, 5HT, NKG, RNM, HMN, FPB, T2B, WPF, B8Z, 82K, FQK, KW3, HX8, PS1, QS2, CK4, 7SQ, P1W, PSM, 2PT, FN8, H42, FJ2, 8D8, PWV, FRD, 9CJ, MK4, 66S, 2MQ, SCR, 8MQ, MXD, 8WJ, Q84, 25X, NHB, Q1L, GD9, JPY, 8WS, 4T5, F74, 6V1, FB6, DBK, LQR, JNL, 3VV, 62D, 2M9, CPQ, LVG, RCQ, 5HN, BN2, C4K, 25G, X4N, G5S, M29, 8TZ, 6MS, 689, 17B, MNL, XGN, Y64, YN2, MNY, CLX, YCW, 622, HMC, HML, 326, 58J, GQ1, MF7, SCQ, GMM, 22B, 14K, XDD, BG3, MR7, 5VH, N57, X94, 2PS, TVQ, 4XF, BFL, FCQ, 6LF, DFW, F62, MJN, Q4C, 21T, TDZ, 1Q1, 3XK, ZXH, JH5, BDC, DZ7, K6G, 6ZB, RRX, JTG, BDB, TQ8, ZJ3, LML, NJ2, LGH, 54W, 2QC, 45M, QD9, JNB, 3J9, Q1M, 3Q3, YJG, DQT, TJW, 31C, CKQ, NWT, V6S, WLB, 8F8, 2VV, ZVZ, 232, DNZ, T95, GNS, Y86, X2M, DSP, 888, QH5, FR8, W5Y, DHN, ZLF, 4Y2, LGS, WQY, 3BN, PS9, S87, JGB, 8K3, 632, NDH, KJ8, BGW, L7H, DT8, J6R, HGJ, LJH, 7Y9, PMX, 5MZ, R28, JSK, Z4V, YBF, NM6, GMP, 17N, PQP, 18D, LK7, CBJ, SCY, TV5, 8CC, 2NX, S14, QDL, CJW, S45, 6XS, TMR, 9T3, N7Y, L94, XQ6, QXF, BXW, COM
: ## 31
: ## SAN: Q8B, B4D, LL9, F89, J8T, ZL4, Q2W, 96Q, 14F, HQL, TJD, KRR, 3VR, 5BT, VC9, YYL, KDN, 82D, 2RN, LYJ, FTN, BSN, F7D, LX6, W6D, SF6, W5M, 8SP, NGV, PR8, FHY, 2PV, X9N, 5CV, XWS, YVZ, T7S, 1QJ, 8ZL, Z8W, Y9F, 1RH, RWX, FFY, QRY, RY5, DQ4, HBK, RHQ, YPK, LM3, J6S, 69V, T4H, GQ3, 511, JL3, SLS, K8K, 29K, 8F1, 3RD, DCJ, T1Z, 6R1, H12, Z2L, 5KX, DDD, MKY, VPH, P66, 67Y, K2M, GYG, D13, 99V, DZG, Y34, PDK, YDC, 1JP, JR9, WCS, GK8, HWF, FDR, SND, FF3, NF1, NYY, 2JM, WZ4, 8PM, R7R, RYS, QBT, J55, BTJ, M4Y, TQ4, JG6, 1YC, XWV, QKX, PDY, ZDY, NHF, KNC, 3GN, Y27, 57D, SC4, X2J, HYC, Z21, 2Y2, ZTZ, 3JF, WKM, NBF, PGC, 3X2, K2Y, BZK, 9VZ, MLX, GK2, WNL, 42M, VK9, 2SM, KML, DQW, D98, CQD, 3PV, LMK, Z7P, C9D, JHL, NWT, V6S, WLB, 8F8, 2VV, ZVZ, 232, DNZ, T95, GNS, Y86, X2M, DSP, 888, QH5, FR8, W5Y, DHN, ZLF, 4Y2, LGS, WQY, 3BN, PS9, S87, JGB, 8K3, 632, NDH, KJ8, BGW, L7H, DT8, J6R, HGJ, LJH, 7Y9, PMX, 5MZ, R28, JSK, Z4V, YBF, NM6, GMP, 17N, PQP, 18D, LK7, CBJ, SCY, TV5, 8CC, 2NX, S14, QDL, CJW, S45, 6XS, TMR, 9T3, N7Y, L94, XQ6, QXF, BXW, COM
: you 181(NWT), san 141(NWT)
: = 322

 - 322 correct <2019-12-07 Sat 11:50>
* day 7
** puzzle
--- Day 7: Amplification Circuit ---

Based on the navigational maps, you're going to need to send more power to your ship's thrusters to reach Santa in time. To do this, you'll need to configure a series of amplifiers already installed on the ship.

There are five amplifiers connected in series; each one receives an input signal and produces an output signal. They are connected such that the first amplifier's output leads to the second amplifier's input, the second amplifier's output leads to the third amplifier's input, and so on. The first amplifier's input value is 0, and the last amplifier's output leads to your ship's thrusters.

    O-------O  O-------O  O-------O  O-------O  O-------O
0 ->| Amp A |->| Amp B |->| Amp C |->| Amp D |->| Amp E |-> (to thrusters)
    O-------O  O-------O  O-------O  O-------O  O-------O

The Elves have sent you some Amplifier Controller Software (your puzzle input), a program that should run on your existing Intcode computer. Each amplifier will need to run a copy of the program.

When a copy of the program starts running on an amplifier, it will first use an input instruction to ask the amplifier for its current phase setting (an integer from 0 to 4). Each phase setting is used exactly once, but the Elves can't remember which amplifier needs which phase setting.

The program will then call another input instruction to get the amplifier's input signal, compute the correct output signal, and supply it back to the amplifier with an output instruction. (If the amplifier has not yet received an input signal, it waits until one arrives.)

Your job is to find the largest output signal that can be sent to the thrusters by trying every possible combination of phase settings on the amplifiers. Make sure that memory is not shared or reused between copies of the program.

For example, suppose you want to try the phase setting sequence 3,1,2,4,0, which would mean setting amplifier A to phase setting 3, amplifier B to setting 1, C to 2, D to 4, and E to 0. Then, you could determine the output signal that gets sent from amplifier E to the thrusters with the following steps:

    Start the copy of the amplifier controller software that will run on amplifier A. At its first input instruction, provide it the amplifier's phase setting, 3. At its second input instruction, provide it the input signal, 0. After some calculations, it will use an output instruction to indicate the amplifier's output signal.
    Start the software for amplifier B. Provide it the phase setting (1) and then whatever output signal was produced from amplifier A. It will then produce a new output signal destined for amplifier C.
    Start the software for amplifier C, provide the phase setting (2) and the value from amplifier B, then collect its output signal.
    Run amplifier D's software, provide the phase setting (4) and input value, and collect its output signal.
    Run amplifier E's software, provide the phase setting (0) and input value, and collect its output signal.

The final output signal from amplifier E would be sent to the thrusters. However, this phase setting sequence may not have been the best one; another sequence might have sent a higher signal to the thrusters.

Here are some example programs:

    Max thruster signal 43210 (from phase setting sequence 4,3,2,1,0):

    3,15,3,16,1002,16,10,16,1,16,15,15,4,15,99,0,0

    Max thruster signal 54321 (from phase setting sequence 0,1,2,3,4):

    3,23,3,24,1002,24,10,24,1002,23,-1,23,
    101,5,23,23,1,24,23,23,4,23,99,0,0

    Max thruster signal 65210 (from phase setting sequence 1,0,4,3,2):

    3,31,3,32,1002,32,10,32,1001,31,-2,31,1007,31,0,33,
    1002,33,7,33,1,33,31,31,1,32,31,31,4,31,99,0,0,0

Try every combination of phase settings on the amplifiers. What is the highest signal that can be sent to the thrusters?

Your puzzle answer was 30940.
--- Part Two ---

It's no good - in this configuration, the amplifiers can't generate a large enough output signal to produce the thrust you'll need. The Elves quickly talk you through rewiring the amplifiers into a feedback loop:

      O-------O  O-------O  O-------O  O-------O  O-------O
0 -+->| Amp A |->| Amp B |->| Amp C |->| Amp D |->| Amp E |-.
   |  O-------O  O-------O  O-------O  O-------O  O-------O |
   |                                                        |
   '--------------------------------------------------------+
                                                            |
                                                            v
                                                     (to thrusters)

Most of the amplifiers are connected as they were before; amplifier A's output is connected to amplifier B's input, and so on. However, the output from amplifier E is now connected into amplifier A's input. This creates the feedback loop: the signal will be sent through the amplifiers many times.

In feedback loop mode, the amplifiers need totally different phase settings: integers from 5 to 9, again each used exactly once. These settings will cause the Amplifier Controller Software to repeatedly take input and produce output many times before halting. Provide each amplifier its phase setting at its first input instruction; all further input/output instructions are for signals.

Don't restart the Amplifier Controller Software on any amplifier during this process. Each one should continue receiving and sending signals until it halts.

All signals sent or received in this process will be between pairs of amplifiers except the very first signal and the very last signal. To start the process, a 0 signal is sent to amplifier A's input exactly once.

Eventually, the software on the amplifiers will halt after they have processed the final loop. When this happens, the last output signal from amplifier E is sent to the thrusters. Your job is to find the largest output signal that can be sent to the thrusters using the new phase settings and feedback loop arrangement.

Here are some example programs:

    Max thruster signal 139629729 (from phase setting sequence 9,8,7,6,5):

    3,26,1001,26,-4,26,3,27,1002,27,2,27,1,27,26,
    27,4,27,1001,28,-1,28,1005,28,6,99,0,0,5

    Max thruster signal 18216 (from phase setting sequence 9,7,8,5,6):

    3,52,1001,52,-5,52,3,53,1,52,56,54,1007,54,5,55,1005,55,26,1001,54,
    -5,54,1105,1,12,1,53,54,53,1008,54,0,55,1001,55,1,55,2,53,55,53,4,
    53,1001,56,-1,56,1005,56,6,99,0,0,0,0,10

Try every combination of the new phase settings on the amplifier feedback loop. What is the highest signal that can be sent to the thrusters?

Your puzzle answer was 76211147.

Both parts of this puzzle are complete! They provide two gold stars: **
** part 1
 - <2019-12-07 Sat 13:29>
#+BEGIN_SRC C :results output
  #include <stdio.h>
  #include <stdlib.h>
  #include <stdarg.h>
  #define MAX 100000

  void die(const char *s) {
    printf("%s\n", s);
    exit(0);
  }

  void info(const char * format, ...) {
    return;
    va_list arglist;
    va_start(arglist, format);
    vprintf(format, arglist);
    va_end(arglist);
  }

  int run(int program[], int inputc, int inputs[]) {
    int p[MAX];
    for (int i = 0; i < MAX; i++) {
      p[i] = program[i];
    }
    int inputi = 0;
    int lastoutput = -1;
      for (int i = 0; i < 10000;) {
        int opcode = p[i] % 100;
        int p1mode = (p[i] / 100) % 10;
        int p2mode = (p[i] / 1000) % 10;
        int p3mode = (p[i] / 10000) % 10;
        if (opcode == 99) {
          break;
        } else if (opcode == 1) { // +
          info("%4d: %d %d %d %d\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          if (p3mode == 1) die("opcode 1 had p3mode");
          p[p[i+3]] = (p1mode ? p[i+1] : p[p[i+1]]) + (p2mode ? p[i+2] : p[p[i+2]]);
          i += 4;
        } else if (opcode == 2) { // *
          info("%4d: %d %d %d %d\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          if (p3mode == 1) die("opcode 2 had p3mode");
          p[p[i+3]] = (p1mode ? p[i+1] : p[p[i+1]]) * (p2mode ? p[i+2] : p[p[i+2]]);
          i += 4;
        } else if (opcode == 3) { // input
          info("%4d: %d %d\n", i, p[i], p[i+1]);
          if (inputi >= inputc) die("inputs exausted");
          p[p[i+1]] = inputs[inputi++];
          i += 2;
        } else if (opcode == 4) { // output
          info("%4d: %d %d\n", i, p[i], p[i+1]);
          lastoutput = p1mode ? p[i+1] : p[p[i+1]];
          info("output %d\n", lastoutput);
          i += 2;
        } else if (opcode == 5) { // jump-if-true
          info("%4d: %d %d %d\n", i, p[i], p[i+1], p[i+2]);
          if (0 != (p1mode ? p[i+1] : p[p[i+1]]))
            i = p2mode ? p[i+2] : p[p[i+2]];
          else
            i += 3;
        } else if (opcode == 6) { // jump-if-false
          info("%4d: %d %d %d\n", i, p[i], p[i+1], p[i+2]);
          if (0 == (p1mode ? p[i+1] : p[p[i+1]]))
            i = p2mode ? p[i+2] : p[p[i+2]];
          else
            i += 3;
        } else if (opcode == 7) { // less than
          info("%4d: %d %d %d %d\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          if ((p1mode ? p[i+1] : p[p[i+1]]) < (p2mode ? p[i+2] : p[p[i+2]]))
            p[p[i+3]] = 1;
          else
            p[p[i+3]] = 0;
          i += 4;
        } else if (opcode == 8) { // equal to
          info("%4d: %d %d %d %d\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          if ((p1mode ? p[i+1] : p[p[i+1]]) == (p2mode ? p[i+2] : p[p[i+2]]))
            p[p[i+3]] = 1;
          else
            p[p[i+3]] = 0;
          i += 4;
        } else {
          printf("Error: %d: %d\n", i, p[i]);
          return 0;
        }
      }
      return lastoutput;
  }
  int run2(int program[], int input1, int input2) {
    int inputs[] = {input1, input2};
    return run(program, 2, inputs);
  }

  int main(int argc, char **args) {
      int positions[MAX];
      FILE *f = fopen("07.txt", "r");
      for (int i = 0; i < MAX; i++) {
          if (fscanf(f, "%d", &positions[i]) != 1) break;
          fscanf(f, ",");
      }
      int max = 0;
      for (int p1 = 0; p1 < 5; p1++) {
        int o1 = run2(positions, p1, 0);
        for (int p2 = 0; p2 < 5; p2++) {
          if (p2 == p1) continue;
          int o2 = run2(positions, p2, o1);
          for (int p3 = 0; p3 < 5; p3++) {
            if (p3 == p2 || p3 == p1) continue;
            int o3 = run2(positions, p3, o2);
            for (int p4 = 0; p4 < 5; p4++) {
              if (p4 == p3 || p4 == p2 || p4 == p1) continue;
              int o4 = run2(positions, p4, o3);
              for (int p5 = 0; p5 < 5; p5++) {
              if (p5 == p4 || p5 == p3 || p5 == p2 || p5 == p1) continue;
              int o5 = run2(positions, p5, o4);
              if (o5 > max) max = o5;
              if (o5 == max) info("%d  (%d %d %d %d %d)\n", max, p1, p2, p3, p4, p5);
      }}}}}
      printf("= %d\n", max);
      return 0;
  }
#+END_SRC

#+RESULTS:
: = 30940

 - 30940 correct <2019-12-07 Sat 13:54>
** part 2
#+BEGIN_SRC C :results output
  #include <stdio.h>
  #include <stdlib.h>
  #include <stdarg.h>
  #define MAX 100000

  void die(const char *s) {
    printf("%s\n", s);
    exit(0);
  }

  void info(const char * format, ...) {
    return;
    va_list arglist;
    va_start(arglist, format);
    vprintf(format, arglist);
    va_end(arglist);
  }

  #define PSTATE_NOT_STARTED 0
  #define PSTATE_STOPPED 1
  #define PSTATE_WAITING_INPUT 2
  #define PSTATE_OUTPUT 3

  struct program {
    int program[MAX];
    int pc;
    int state;
  };

  int run(struct program *program, int input) {
    int *p = program->program;
    int lastoutput = -1;
    int i = program->pc;
    int usedinput = 0;
    while (i < MAX) {
        int opcode = p[i] % 100;
        int p1mode = (p[i] / 100) % 10;
        int p2mode = (p[i] / 1000) % 10;
        int p3mode = (p[i] / 10000) % 10;
        if (opcode == 99) {
          program->state = PSTATE_STOPPED;
          program->pc = i;
          return -1;
        } else if (opcode == 1) { // +
          info("%4d: %d %d %d %d\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          if (p3mode == 1) die("opcode 1 had p3mode");
          p[p[i+3]] = (p1mode ? p[i+1] : p[p[i+1]]) + (p2mode ? p[i+2] : p[p[i+2]]);
          i += 4;
        } else if (opcode == 2) { // *
          info("%4d: %d %d %d %d\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          if (p3mode == 1) die("opcode 2 had p3mode");
          p[p[i+3]] = (p1mode ? p[i+1] : p[p[i+1]]) * (p2mode ? p[i+2] : p[p[i+2]]);
          i += 4;
        } else if (opcode == 3) { // input
          info("%4d: %d %d\n", i, p[i], p[i+1]);
          if (usedinput) {
            program->state = PSTATE_WAITING_INPUT;
            program->pc = i;
            return -2;
          }
          p[p[i+1]] = input;
          i += 2;
          usedinput = 1;
        } else if (opcode == 4) { // output
          info("%4d: %d %d\n", i, p[i], p[i+1]);
          lastoutput = p1mode ? p[i+1] : p[p[i+1]];
          info("output %d\n", lastoutput);
          i += 2;
          program->state = PSTATE_OUTPUT;
          program->pc = i;
          return lastoutput;
        } else if (opcode == 5) { // jump-if-true
          info("%4d: %d %d %d\n", i, p[i], p[i+1], p[i+2]);
          if (0 != (p1mode ? p[i+1] : p[p[i+1]]))
            i = p2mode ? p[i+2] : p[p[i+2]];
          else
            i += 3;
        } else if (opcode == 6) { // jump-if-false
          info("%4d: %d %d %d\n", i, p[i], p[i+1], p[i+2]);
          if (0 == (p1mode ? p[i+1] : p[p[i+1]]))
            i = p2mode ? p[i+2] : p[p[i+2]];
          else
            i += 3;
        } else if (opcode == 7) { // less than
          info("%4d: %d %d %d %d\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          if ((p1mode ? p[i+1] : p[p[i+1]]) < (p2mode ? p[i+2] : p[p[i+2]]))
            p[p[i+3]] = 1;
          else
            p[p[i+3]] = 0;
          i += 4;
        } else if (opcode == 8) { // equal to
          info("%4d: %d %d %d %d\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          if ((p1mode ? p[i+1] : p[p[i+1]]) == (p2mode ? p[i+2] : p[p[i+2]]))
            p[p[i+3]] = 1;
          else
            p[p[i+3]] = 0;
          i += 4;
        } else {
          info("%d: %d %d %d %d\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          die("Error: unknown opcode");
          return -2;
        }
      }
      die("Error: program outside MAX\n");
      return -3;
  }

  int main(int argc, char **args) {
      int positions[MAX];
      FILE *f = fopen("07.txt", "r");
      for (int i = 0; i < MAX; i++) {
          if (fscanf(f, "%d", &positions[i]) != 1) break;
          fscanf(f, ",");
      }

      int max = 0;
      for (int p1 = 5; p1 <= 9; p1++) {
        for (int p2 = 0; p2 <= 9; p2++) {
          if (p2 == p1) continue;
          for (int p3 = 5; p3 <= 9; p3++) {
            if (p3 == p2 || p3 == p1) continue;
            for (int p4 = 5; p4 <= 9; p4++) {
              if (p4 == p3 || p4 == p2 || p4 == p1) continue;
              for (int p5 = 5; p5 <= 9; p5++) {
                if (p5 == p4 || p5 == p3 || p5 == p2 || p5 == p1) continue;
                struct program progs[6];
                for (int j = 0; j < 6; j++) {
                  progs[j].pc = 0;
                  progs[j].state = PSTATE_NOT_STARTED;
                  for (int i = 0; i < MAX; i++) 
                    progs[j].program[i] = positions[i];
                }

                run(&progs[1], p1);
                run(&progs[2], p2);
                run(&progs[3], p3);
                run(&progs[4], p4);
                run(&progs[5], p5);
                int output = 0;
                int realoutput = 0;
                while (progs[1].state != PSTATE_STOPPED) {
                  output = run(&progs[1], output);
                  info("## 1 out=%d, state=%d\n", output, progs[1].state);
                  output = run(&progs[2], output);
                  info("## 2 out=%d, state=%d\n", output, progs[2].state);
                  output = run(&progs[3], output);
                  info("## 3 out=%d, state=%d\n", output, progs[3].state);
                  output = run(&progs[4], output);
                  info("## 4 out=%d, state=%d\n", output, progs[4].state);
                  output = run(&progs[5], output);
                  info("## 5 out=%d, state=%d\n", output, progs[5].state);
                  if (progs[5].state == PSTATE_OUTPUT)
                    realoutput = output;
                }
                if (realoutput > max) max = realoutput;
      }}}}}
      printf("= %d\n", max);
      return 0;
  }
#+END_SRC

#+RESULTS:
: = 76211147

 - 75935428 too low <2019-12-07 Sat 14:42>
 - 76211147 correct <2019-12-07 Sat 14:43>
* day 8
** puzzle
--- Day 8: Space Image Format ---

The Elves' spirits are lifted when they realize you have an opportunity to reboot one of their Mars rovers, and so they are curious if you would spend a brief sojourn on Mars. You land your ship near the rover.

When you reach the rover, you discover that it's already in the process of rebooting! It's just waiting for someone to enter a BIOS password. The Elf responsible for the rover takes a picture of the password (your puzzle input) and sends it to you via the Digital Sending Network.

Unfortunately, images sent via the Digital Sending Network aren't encoded with any normal encoding; instead, they're encoded in a special Space Image Format. None of the Elves seem to remember why this is the case. They send you the instructions to decode it.

Images are sent as a series of digits that each represent the color of a single pixel. The digits fill each row of the image left-to-right, then move downward to the next row, filling rows top-to-bottom until every pixel of the image is filled.

Each image actually consists of a series of identically-sized layers that are filled in this way. So, the first digit corresponds to the top-left pixel of the first layer, the second digit corresponds to the pixel to the right of that on the same layer, and so on until the last digit, which corresponds to the bottom-right pixel of the last layer.

For example, given an image 3 pixels wide and 2 pixels tall, the image data 123456789012 corresponds to the following image layers:

Layer 1: 123
         456

Layer 2: 789
         012

The image you received is 25 pixels wide and 6 pixels tall.

To make sure the image wasn't corrupted during transmission, the Elves would like you to find the layer that contains the fewest 0 digits. On that layer, what is the number of 1 digits multiplied by the number of 2 digits?

Your puzzle answer was 1072.
--- Part Two ---

Now you're ready to decode the image. The image is rendered by stacking the layers and aligning the pixels with the same positions in each layer. The digits indicate the color of the corresponding pixel: 0 is black, 1 is white, and 2 is transparent.

The layers are rendered with the first layer in front and the last layer in back. So, if a given position has a transparent pixel in the first and second layers, a black pixel in the third layer, and a white pixel in the fourth layer, the final image would have a black pixel at that position.

For example, given an image 2 pixels wide and 2 pixels tall, the image data 0222112222120000 corresponds to the following image layers:

Layer 1: 02
         22

Layer 2: 11
         22

Layer 3: 22
         12

Layer 4: 00
         00

Then, the full image can be found by determining the top visible pixel in each position:

    The top-left pixel is black because the top layer is 0.
    The top-right pixel is white because the top layer is 2 (transparent), but the second layer is 1.
    The bottom-left pixel is white because the top two layers are 2, but the third layer is 1.
    The bottom-right pixel is black because the only visible pixel in that position is 0 (from layer 4).

So, the final image looks like this:

01
10

What message is produced after decoding your image?

Your puzzle answer was YLFPJ.

Both parts of this puzzle are complete! They provide two gold stars: **
** part 1
#+BEGIN_SRC C :results output
#include <stdio.h>
int main(int argc, char **args) {
  FILE *f = fopen("08.txt", "r");

  int width = 25;
  int height = 6;

  int minzeros = 99999;
  int minzerosones = 0;
  int minzerostwos = 0;
  for (int layer = 0; ; layer++) {
    int zeros = 0;
    int ones = 0;
    int twos = 0;
    for (int y = 0; y < height; y++) {
      for (int x = 0; x < width; x++) {
        int c = fgetc(f);
        if (c < '0' || c > '9') {
          printf("= %d\n", minzerosones * minzerostwos);
          return 0;
        }
        if (c == '0') zeros++;
        if (c == '1') ones++;
        if (c == '2') twos++;
      }
    }
    if (zeros < minzeros) {
      minzeros = zeros;
      minzerosones = ones;
      minzerostwos = twos;
    }
  }
  return 0;
}
#+END_SRC

#+RESULTS:
: = 1072

 - 1072 correct <2019-12-08 Sun 14:24>
** part 2
#+BEGIN_SRC C :results output
#include <stdio.h>
int main(int argc, char **args) {
  FILE *f = fopen("08.txt", "r");

  int width = 25;
  int height = 6;

  int img[height][width];
  for (int y = 0; y < height; y++)
    for (int x = 0; x < width; x++)
      img[y][x] = '2';

  for (int layer = 0; ; layer++) {
    for (int y = 0; y < height; y++) {
      for (int x = 0; x < width; x++) {
        int c = fgetc(f);
        if (c < '0' || c > '9') {
          goto output;
        }
        if (img[y][x] == '2') img[y][x] = c;
      }
    }
  }

  output:
  for (int y = 0; y < height; y++) {
    for (int x = 0; x < width; x++)
      printf("%c", img[y][x] == '0' ? ' ' : '#');
    printf("\n");
  }

  return 0;
}
#+END_SRC

#+RESULTS:
: #   ##    #### ###    ## 
: #   ##    #    #  #    # 
:  # # #    ###  #  #    # 
:   #  #    #    ###     # 
:   #  #    #    #    #  # 
:   #  #### #    #     ##

 - YLFPJ correct <2019-12-08 Sun>
* day 9
** puzzle
--- Day 9: Sensor Boost ---

You've just said goodbye to the rebooted rover and left Mars when you receive a faint distress signal coming from the asteroid belt. It must be the Ceres monitoring station!

In order to lock on to the signal, you'll need to boost your sensors. The Elves send up the latest BOOST program - Basic Operation Of System Test.

While BOOST (your puzzle input) is capable of boosting your sensors, for tenuous safety reasons, it refuses to do so until the computer it runs on passes some checks to demonstrate it is a complete Intcode computer.

Your existing Intcode computer is missing one key feature: it needs support for parameters in relative mode.

Parameters in mode 2, relative mode, behave very similarly to parameters in position mode: the parameter is interpreted as a position. Like position mode, parameters in relative mode can be read from or written to.

The important difference is that relative mode parameters don't count from address 0. Instead, they count from a value called the relative base. The relative base starts at 0.

The address a relative mode parameter refers to is itself plus the current relative base. When the relative base is 0, relative mode parameters and position mode parameters with the same value refer to the same address.

For example, given a relative base of 50, a relative mode parameter of -7 refers to memory address 50 + -7 = 43.

The relative base is modified with the relative base offset instruction:

    Opcode 9 adjusts the relative base by the value of its only parameter. The relative base increases (or decreases, if the value is negative) by the value of the parameter.

For example, if the relative base is 2000, then after the instruction 109,19, the relative base would be 2019. If the next instruction were 204,-34, then the value at address 1985 would be output.

Your Intcode computer will also need a few other capabilities:

    The computer's available memory should be much larger than the initial program. Memory beyond the initial program starts with the value 0 and can be read or written like any other memory. (It is invalid to try to access memory at a negative address, though.)
    The computer should have support for large numbers. Some instructions near the beginning of the BOOST program will verify this capability.

Here are some example programs that use these features:

    109,1,204,-1,1001,100,1,100,1008,100,16,101,1006,101,0,99 takes no input and produces a copy of itself as output.
    1102,34915192,34915192,7,4,7,99,0 should output a 16-digit number.
    104,1125899906842624,99 should output the large number in the middle.

The BOOST program will ask for a single input; run it in test mode by providing it the value 1. It will perform a series of checks on each opcode, output any opcodes (and the associated parameter modes) that seem to be functioning incorrectly, and finally output a BOOST keycode.

Once your Intcode computer is fully functional, the BOOST program should report no malfunctioning opcodes when run in test mode; it should only output a single value, the BOOST keycode. What BOOST keycode does it produce?

Your puzzle answer was 2662308295.
--- Part Two ---

You now have a complete Intcode computer.

Finally, you can lock on to the Ceres distress signal! You just need to boost your sensors using the BOOST program.

The program runs in sensor boost mode by providing the input instruction the value 2. Once run, it will boost the sensors automatically, but it might take a few seconds to complete the operation on slower hardware. In sensor boost mode, the program will output a single value: the coordinates of the distress signal.

Run the BOOST program in sensor boost mode. What are the coordinates of the distress signal?

Your puzzle answer was 63441.

Both parts of this puzzle are complete! They provide two gold stars: **
** part 1
 - <2019-12-09 Mon 19:26>
#+BEGIN_SRC C :results output
  #include <stdio.h>
  #include <stdlib.h>
  #include <stdarg.h>
  #define MAX 10000

  void die(const char *format, ...) {
    va_list arglist;
    va_start(arglist, format);
    vprintf(format, arglist);
    va_end(arglist);
    exit(0);
  }

  void info(const char * format, ...) {
    return;
    va_list arglist;
    va_start(arglist, format);
    vprintf(format, arglist);
    va_end(arglist);
  }

  #define PSTATE_NOT_STARTED 0
  #define PSTATE_STOPPED 1
  #define PSTATE_WAITING_INPUT 2
  #define PSTATE_OUTPUT 3

  struct program {
    long program[MAX];
    int pc;
    int state;
    long base;
  };

  long paramref(struct program *program, int mode, int i) {
      if (mode == 0) {
          long val = program->program[i];
          if (val > MAX) die("param too big: mode=%d, i=%d, val=%ld", mode, i, val);
          return program->program[i];
      } else if (mode == 1) {
          return i;
      } else if (mode == 2) {
          long val = program->base + program->program[i];
          if (val > MAX) die("param too big");
          return val;
      } else {
          die("Invalid parameter mode");
      }
  }
  long param(struct program *program, int mode, int i) {
    long val = paramref(program, mode, i);
    if (val > MAX) die("param too big: mode=%d, i=%d, val=%ld", mode, i, val);
    return program->program[val];
  }

  long run(struct program *program, int input) {
    int stopper = 10000;
    long *p = program->program;
    long lastoutput = -1;
    int i = program->pc;
    int usedinput = 0;
    while (stopper-- >= 0) {
       if (i > MAX-5) die("pc outside range");
        int opcode = p[i] % 100;
        int p1mode = (p[i] / 100) % 10;
        int p2mode = (p[i] / 1000) % 10;
        int p3mode = (p[i] / 10000) % 10;
        if (opcode == 99) {
          program->state = PSTATE_STOPPED;
          program->pc = i;
          return -1;
        } else if (opcode == 1) { // +
          info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          p[paramref(program, p3mode, i+3)] = param(program, p1mode, i+1) + param(program, p2mode, i+2);
          i += 4;
        } else if (opcode == 2) { // *
          info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          p[paramref(program, p3mode, i+3)] = param(program, p1mode, i+1) * param(program, p2mode, i+2);
          i += 4;
        } else if (opcode == 3) { // input
          info("%4d: %ld %ld\n", i, p[i], p[i+1]);
          if (usedinput) {
            program->state = PSTATE_WAITING_INPUT;
            program->pc = i;
            return -2;
          }
          p[paramref(program, p1mode, i+1)] = input;
          i += 2;
          usedinput = 1;
        } else if (opcode == 4) { // output
          info("%4d: %ld %ld\n", i, p[i], p[i+1]);
          lastoutput = param(program, p1mode, i+1);
          info("output %ld\n", lastoutput);
          i += 2;
          program->state = PSTATE_OUTPUT;
          program->pc = i;
          return lastoutput;
        } else if (opcode == 5) { // jump-if-true
          info("%4d: %ld %ld %ld\n", i, p[i], p[i+1], p[i+2]);
          if (0 != param(program, p1mode, i+1))
            i = param(program, p2mode, i+2);
          else
            i += 3;
        } else if (opcode == 6) { // jump-if-false
          info("%4d: %ld %ld %ld\n", i, p[i], p[i+1], p[i+2]);
          if (0 == param(program, p1mode, i+1))
            i = param(program, p2mode, i+2);
          else
            i += 3;
        } else if (opcode == 7) { // less than
          info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          if (param(program, p1mode, i+1) < param(program, p2mode, i+2))
            p[paramref(program, p3mode, i+3)] = 1;
          else
            p[paramref(program, p3mode, i+3)] = 0;
          i += 4;
        } else if (opcode == 8) { // equal to
          info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          if (param(program, p1mode, i+1) == param(program, p2mode, i+2))
            p[paramref(program, p3mode, i+3)] = 1;
          else
            p[paramref(program, p3mode, i+3)] = 0;
          i += 4;
        } else if (opcode == 9) {
          info("%4d: %ld %ld\n", i, p[i], p[i+1]);
          program->base += param(program, p1mode, i+1);
          i += 2;
        } else {
          info("%ld: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          die("Error: unknown opcode %d: %ld, %ld, %ld, %ld", i, p[i], p[i+1], p[i+2], p[i+3]);
          return -2;
        }
      }
      die("Error: program outside MAX\n");
      return -3;
  }

  int main(int argc, char **args) {
      long positions[MAX] = {0};
      FILE *f = fopen("09.txt", "r");
      for (int i = 0; i < MAX; i++) {
          if (fscanf(f, "%ld", &positions[i]) != 1) break;
          fscanf(f, ",");
      }

      struct program prog;
      prog.pc = 0;
      prog.state = PSTATE_NOT_STARTED;
      prog.base = 0;
      for (int i = 0; i < MAX; i++)
        prog.program[i] = positions[i];

      while (prog.state != PSTATE_STOPPED) {
        long output = run(&prog, 1);
        if (prog.state == PSTATE_OUTPUT)
          printf("OUTPUT %ld\n", output);
      }
      return 0;
  }
#+END_SRC

#+RESULTS:
: OUTPUT 2662308295

 - 203 too low <2019-12-09 Mon 20:08>
 - 2662308295 correct <2019-12-09 Mon 20:15>
** part 2
#+BEGIN_SRC C :results output
  #include <stdio.h>
  #include <stdlib.h>
  #include <stdarg.h>
  #define MAX 100000000

  void die(const char *format, ...) {
    va_list arglist;
    va_start(arglist, format);
    vprintf(format, arglist);
    va_end(arglist);
    exit(0);
  }

  void info(const char * format, ...) {
    return;
    va_list arglist;
    va_start(arglist, format);
    vprintf(format, arglist);
    va_end(arglist);
  }

  #define PSTATE_NOT_STARTED 0
  #define PSTATE_STOPPED 1
  #define PSTATE_WAITING_INPUT 2
  #define PSTATE_OUTPUT 3

  struct program {
    long *program;
    int pc;
    int state;
    long base;
  };

  long paramref(struct program *program, int mode, int i) {
      if (mode == 0) {
          long val = program->program[i];
          if (val > MAX) die("param too big: mode=%d, i=%d, val=%ld", mode, i, val);
          return program->program[i];
      } else if (mode == 1) {
          return i;
      } else if (mode == 2) {
          long val = program->base + program->program[i];
          if (val > MAX) die("param too big");
          return val;
      } else {
          die("Invalid parameter mode");
      }
  }
  long param(struct program *program, int mode, int i) {
    long val = paramref(program, mode, i);
    if (val > MAX) die("param too big: mode=%d, i=%d, val=%ld", mode, i, val);
    return program->program[val];
  }

  long run(struct program *program, int input) {
    int stopper = 999999999;
    long *p = program->program;
    long lastoutput = -1;
    int i = program->pc;
    int usedinput = 0;
    while (stopper-- >= 0) {
       if (i > MAX-5) die("pc outside range");
        int opcode = p[i] % 100;
        int p1mode = (p[i] / 100) % 10;
        int p2mode = (p[i] / 1000) % 10;
        int p3mode = (p[i] / 10000) % 10;
        if (opcode == 99) {
          program->state = PSTATE_STOPPED;
          program->pc = i;
          return -1;
        } else if (opcode == 1) { // +
          info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          p[paramref(program, p3mode, i+3)] = param(program, p1mode, i+1) + param(program, p2mode, i+2);
          i += 4;
        } else if (opcode == 2) { // *
          info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          p[paramref(program, p3mode, i+3)] = param(program, p1mode, i+1) * param(program, p2mode, i+2);
          i += 4;
        } else if (opcode == 3) { // input
          info("%4d: %ld %ld\n", i, p[i], p[i+1]);
          if (usedinput) {
            program->state = PSTATE_WAITING_INPUT;
            program->pc = i;
            return -2;
          }
          p[paramref(program, p1mode, i+1)] = input;
          i += 2;
          usedinput = 1;
        } else if (opcode == 4) { // output
          info("%4d: %ld %ld\n", i, p[i], p[i+1]);
          lastoutput = param(program, p1mode, i+1);
          info("output %ld\n", lastoutput);
          i += 2;
          program->state = PSTATE_OUTPUT;
          program->pc = i;
          return lastoutput;
        } else if (opcode == 5) { // jump-if-true
          info("%4d: %ld %ld %ld\n", i, p[i], p[i+1], p[i+2]);
          if (0 != param(program, p1mode, i+1))
            i = param(program, p2mode, i+2);
          else
            i += 3;
        } else if (opcode == 6) { // jump-if-false
          info("%4d: %ld %ld %ld\n", i, p[i], p[i+1], p[i+2]);
          if (0 == param(program, p1mode, i+1))
            i = param(program, p2mode, i+2);
          else
            i += 3;
        } else if (opcode == 7) { // less than
          info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          if (param(program, p1mode, i+1) < param(program, p2mode, i+2))
            p[paramref(program, p3mode, i+3)] = 1;
          else
            p[paramref(program, p3mode, i+3)] = 0;
          i += 4;
        } else if (opcode == 8) { // equal to
          info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          if (param(program, p1mode, i+1) == param(program, p2mode, i+2))
            p[paramref(program, p3mode, i+3)] = 1;
          else
            p[paramref(program, p3mode, i+3)] = 0;
          i += 4;
        } else if (opcode == 9) {
          info("%4d: %ld %ld\n", i, p[i], p[i+1]);
          program->base += param(program, p1mode, i+1);
          i += 2;
        } else {
          info("%ld: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          die("Error: unknown opcode %d: %ld, %ld, %ld, %ld", i, p[i], p[i+1], p[i+2], p[i+3]);
          return -2;
        }
      }
      die("Error: program outside MAX: %d\n", i);
      return -3;
  }

  int main(int argc, char **args) {
      long *positions = malloc(MAX * sizeof(long));
      //long positions[MAX] = {0};
      FILE *f = fopen("09.txt", "r");
      for (int i = 0; i < MAX; i++) {
          if (fscanf(f, "%ld", &positions[i]) != 1) break;
          fscanf(f, ",");
      }

      struct program prog;
      prog.pc = 0;
      prog.state = PSTATE_NOT_STARTED;
      prog.base = 0;
      prog.program = positions;

      while (prog.state != PSTATE_STOPPED) {
        long output = run(&prog, 2);
        if (prog.state == PSTATE_OUTPUT)
          printf("OUTPUT %ld\n", output);
      }
      return 0;
  }
#+END_SRC

#+RESULTS:
: OUTPUT 63441

 - 63441 correct <2019-12-09 Mon 20:18>
* day 10
** puzzle
--- Day 10: Monitoring Station ---

You fly into the asteroid belt and reach the Ceres monitoring station. The Elves here have an emergency: they're having trouble tracking all of the asteroids and can't be sure they're safe.

The Elves would like to build a new monitoring station in a nearby area of space; they hand you a map of all of the asteroids in that region (your puzzle input).

The map indicates whether each position is empty (.) or contains an asteroid (#). The asteroids are much smaller than they appear on the map, and every asteroid is exactly in the center of its marked position. The asteroids can be described with X,Y coordinates where X is the distance from the left edge and Y is the distance from the top edge (so the top-left corner is 0,0 and the position immediately to its right is 1,0).

Your job is to figure out which asteroid would be the best place to build a new monitoring station. A monitoring station can detect any asteroid to which it has direct line of sight - that is, there cannot be another asteroid exactly between them. This line of sight can be at any angle, not just lines aligned to the grid or diagonally. The best location is the asteroid that can detect the largest number of other asteroids.

For example, consider the following map:

.#..#
.....
#####
....#
...##

The best location for a new monitoring station on this map is the highlighted asteroid at 3,4 because it can detect 8 asteroids, more than any other location. (The only asteroid it cannot detect is the one at 1,0; its view of this asteroid is blocked by the asteroid at 2,2.) All other asteroids are worse locations; they can detect 7 or fewer other asteroids. Here is the number of other asteroids a monitoring station on each asteroid could detect:

.7..7
.....
67775
....7
...87

Here is an asteroid (#) and some examples of the ways its line of sight might be blocked. If there were another asteroid at the location of a capital letter, the locations marked with the corresponding lowercase letter would be blocked and could not be detected:

#.........
...A......
...B..a...
.EDCG....a
..F.c.b...
.....c....
..efd.c.gb
.......c..
....f...c.
...e..d..c

Here are some larger examples:

    Best is 5,8 with 33 other asteroids detected:

    ......#.#.
    #..#.#....
    ..#######.
    .#.#.###..
    .#..#.....
    ..#....#.#
    #..#....#.
    .##.#..###
    ##...#..#.
    .#....####

    Best is 1,2 with 35 other asteroids detected:

    #.#...#.#.
    .###....#.
    .#....#...
    ##.#.#.#.#
    ....#.#.#.
    .##..###.#
    ..#...##..
    ..##....##
    ......#...
    .####.###.

    Best is 6,3 with 41 other asteroids detected:

    .#..#..###
    ####.###.#
    ....###.#.
    ..###.##.#
    ##.##.#.#.
    ....###..#
    ..#.#..#.#
    #..#.#.###
    .##...##.#
    .....#.#..

    Best is 11,13 with 210 other asteroids detected:

    .#..##.###...#######
    ##.############..##.
    .#.######.########.#
    .###.#######.####.#.
    #####.##.#.##.###.##
    ..#####..#.#########
    ####################
    #.####....###.#.#.##
    ##.#################
    #####.##.###..####..
    ..######..##.#######
    ####.##.####...##..#
    .#####..#.######.###
    ##...#.##########...
    #.##########.#######
    .####.#.###.###.#.##
    ....##.##.###..#####
    .#.#.###########.###
    #.#.#.#####.####.###
    ###.##.####.##.#..##

Find the best location for a new monitoring station. How many other asteroids can be detected from that location?

Your puzzle answer was 296.
--- Part Two ---

Once you give them the coordinates, the Elves quickly deploy an Instant Monitoring Station to the location and discover the worst: there are simply too many asteroids.

The only solution is complete vaporization by giant laser.

Fortunately, in addition to an asteroid scanner, the new monitoring station also comes equipped with a giant rotating laser perfect for vaporizing asteroids. The laser starts by pointing up and always rotates clockwise, vaporizing any asteroid it hits.

If multiple asteroids are exactly in line with the station, the laser only has enough power to vaporize one of them before continuing its rotation. In other words, the same asteroids that can be detected can be vaporized, but if vaporizing one asteroid makes another one detectable, the newly-detected asteroid won't be vaporized until the laser has returned to the same position by rotating a full 360 degrees.

For example, consider the following map, where the asteroid with the new monitoring station (and laser) is marked X:

.#....#####...#..
##...##.#####..##
##...#...#.#####.
..#.....X...###..
..#.#.....#....##

The first nine asteroids to get vaporized, in order, would be:

.#....###24...#..
##...##.13#67..9#
##...#...5.8####.
..#.....X...###..
..#.#.....#....##

Note that some asteroids (the ones behind the asteroids marked 1, 5, and 7) won't have a chance to be vaporized until the next full rotation. The laser continues rotating; the next nine to be vaporized are:

.#....###.....#..
##...##...#.....#
##...#......1234.
..#.....X...5##..
..#.9.....8....76

The next nine to be vaporized are then:

.8....###.....#..
56...9#...#.....#
34...7...........
..2.....X....##..
..1..............

Finally, the laser completes its first full rotation (1 through 3), a second rotation (4 through 8), and vaporizes the last asteroid (9) partway through its third rotation:

......234.....6..
......1...5.....7
.................
........X....89..
.................

In the large example above (the one with the best monitoring station location at 11,13):

    The 1st asteroid to be vaporized is at 11,12.
    The 2nd asteroid to be vaporized is at 12,1.
    The 3rd asteroid to be vaporized is at 12,2.
    The 10th asteroid to be vaporized is at 12,8.
    The 20th asteroid to be vaporized is at 16,0.
    The 50th asteroid to be vaporized is at 16,9.
    The 100th asteroid to be vaporized is at 10,16.
    The 199th asteroid to be vaporized is at 9,6.
    The 200th asteroid to be vaporized is at 8,2.
    The 201st asteroid to be vaporized is at 10,9.
    The 299th and final asteroid to be vaporized is at 11,1.

The Elves are placing bets on which will be the 200th asteroid to be vaporized. Win the bet by determining which asteroid that will be; what do you get if you multiply its X coordinate by 100 and then add its Y coordinate? (For example, 8,2 becomes 802.)

Your puzzle answer was 204.

Both parts of this puzzle are complete! They provide two gold stars: **
** part 1
 - <2019-12-10 Tue 19:47>
#+BEGIN_SRC C :results output
  #include <stdio.h>
  int gcd(int a, int b) { 
    if (a == 0 || b == 0) return 0;
    else if (a == b) return a;
    else if (a > b) return gcd(a - b, b);
    else/*if (a < b)*/return gcd(a, b - a);
  }
  int abs(int a) {
    return a < 0 ? -a: a;
  }
  int main(int argc, char **args) {
    int yxs[30][30] = {0};
    FILE *f = fopen("10.txt", "r");
    int w, h;
    {
      int c, x, y;
      x = y = w = h = 0;
      while ((c = fgetc(f)) != EOF) {
        if (c == '\n') {
          y++;
          x = 0;
        } else {
          if (x > w) w = x;
          if (y > h) h = y;
          if (c == '#') yxs[y][x] = 1;
          x++;
        }
      }
      w++;
      h++;
    }

    int detecteds[30][30] = {0};
    int maxDetected = 0;
    int maxx, maxy;

    //printf("w=%d, h=%d\n", w, h);
    for (int y = 0; y < h; y++) {
      for (int x = 0; x < w; x++) {
        if (yxs[y][x]) {
          int detected = 0;
          for (int yy = 0; yy < h; yy++) {
            for (int xx = 0; xx < w; xx++) {
              if (!(xx == x && yy == y) && yxs[yy][xx]) {
                int xadd, yadd;
                int xygcd = gcd(abs(x - xx), abs(y - yy));
                if (xygcd == 0 && x - xx == 0) {
                  xadd = 0; yadd = y - yy < 0 ? 1 : -1;
                } else if (xygcd == 0 && y - yy == 0) {
                  xadd = x - xx < 0 ? 1 : -1; yadd = 0;
                } else {
                  xadd = (xx - x) / xygcd; yadd = (yy - y) / xygcd;
                }
                int blocked = 0;
                for (int xxx = x+xadd, yyy = y+yadd; !(xxx == xx && yyy == yy); xxx += xadd, yyy += yadd) {
                  if (yxs[yyy][xxx]) blocked = 1;
                }
                if (!blocked) detected++;
                //printf("## %d,%d +%d,%d -> %d,%d  %d\n", x, y, xadd, yadd, xx, yy, blocked);
              }
            }
          }
          if (detected > maxDetected) { maxDetected = detected; maxx = x; maxy = y; }
          //printf("(%d,%d) = %d\n", x, y, detected);
        }
      }
    }

    printf("%d,%d\n", maxx, maxy);
    printf("= %d\n", maxDetected);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 17,23
: = 296

 - 296 correct <2019-12-10 Tue>
** part 2 (wrong approach)
#+BEGIN_SRC C :results output
  #include <stdio.h>
  int gcd(int a, int b) { 
    if (a == 0 || b == 0) return 0;
    else if (a == b) return a;
    else if (a > b) return gcd(a - b, b);
    else/*if (a < b)*/return gcd(a, b - a);
  }
  int abs(int a) {
    return a < 0 ? -a: a;
  }
  int main(int argc, char **args) {
    int yxs[30][30] = {0};
    FILE *f = fopen("10b.txt", "r");
    int w, h;
    {
      int c, x, y;
      x = y = w = h = 0;
      while ((c = fgetc(f)) != EOF) {
        if (c == '\n') {
          y++;
          x = 0;
        } else {
          if (x > w) w = x;
          if (y > h) h = y;
          if (c == '#') yxs[y][x] = 1;
          x++;
        }
      }
      w++;
      h++;
    }

    /* for (int y = 0; y < h; y++) */
    /*   for (int x = 0; x < w; x++) */
    /*     if (yxs[y][x]) printf("## %d,%d\n", x, y); */

    //int x = 17, y = 23;
    int x = 8, y = 3; // 10b.txt
    int xx1 = -10*w;
    int xx2 = 10*w;
    int yy1 = -10*h;
    int yy2 = 10*h;
    int xx = x;
    int yy = yy1;
    int nth = 1;
    for (int rotations = 0; rotations < 2; rotations++) {
      do {
                int xadd, yadd;
                int xygcd = gcd(abs(x - xx), abs(y - yy));
                if (xygcd == 0 && x - xx == 0) {
                  xadd = 0; yadd = y - yy < 0 ? 1 : -1;
                } else if (xygcd == 0 && y - yy == 0) {
                  xadd = x - xx < 0 ? 1 : -1; yadd = 0;
                } else {
                  xadd = (xx - x) / xygcd; yadd = (yy - y) / xygcd;
                }
                //printf("## %d,%d +%d,%d -> %d,%d\n", x, y, xadd, yadd, xx, yy);
                for (int xxx = x+xadd, yyy = y+yadd; 1; xxx += xadd, yyy += yadd) {
                  if (xxx < 0 || xxx > w || yyy < 0 || yyy > h) break;
                  if (yxs[yyy][xxx]) { 
                    //printf("%d: %d,%d\n", nth++, xxx, yyy); 
                    yxs[yyy][xxx] = 0;
                    break; 
                  }
                  if (xxx == xx && yyy == yy) break;
                }
        if (xx < xx2 && yy == yy1) xx++;
        else if (xx == xx2 && yy < yy2) yy++;
        else if (xx > xx1 && yy == yy2) xx--;
        else if (xx == xx1 && yy > yy1) yy--;
      } while (xx != x || yy != yy1);
    }

    printf("= %d\n", nth);
    return 0;
  }
/*
          1
01234567890123456
.#....###24...#..0
##...##.13#67..9#1
##...#...5.8####.2
..#.....X...###..3
..#.#.....#....##4

1: 8,1
2: 9,0
3: 9,1
4: 10,0
5: 9,2
*/
#+END_SRC

#+RESULTS:
: = 1
** part 2 B
#+BEGIN_SRC C :results output :libs -lm
    #include <stdio.h>
    #include <math.h>
    int gcd(int a, int b) { 
      if (a == 0 || b == 0) return 0;
      else if (a == b) return a;
      else if (a > b) return gcd(a - b, b);
      else/*if (a < b)*/return gcd(a, b - a);
    }
    int abs(int a) {
      return a < 0 ? -a: a;
    }
    double angle(int y, int x) {
      double rad = atan2(y, x);
      rad -= M_PI/2;
      rad -= 0.0000000001;
      if (rad < 0.0) rad += 2*M_PI;
      rad = 2*M_PI - rad;
      return rad;
    }
    int main(int argc, char **args) {
      int yxs[30][30] = {0};
      FILE *f = fopen("10.txt", "r");
      int w, h;
      {
        int c, x, y;
        x = y = w = h = 0;
        while ((c = fgetc(f)) != EOF) {
          if (c == '\n') {
            y++;
            x = 0;
          } else {
            if (x > w) w = x;
            if (y > h) h = y;
            if (c == '#') yxs[y][x] = 1;
            x++;
          }
        }
        w++;
        h++;
      }

      int x = 17, y = 23; // 10.txt
      //int x = 8, y = 3; // 10b.txt
      //int x = 11, y = 13; // 10c.txt

      float radians[30][30] = {-1};
      int detecteds[30][30] = {0};
      int maxDetected = 0;
      int maxx, maxy;
      /* printf("a\n"); */
      /* printf(" 1, 0 = %lf\n", angle(1, 0)); */
      /* printf(" 1, 1 = %lf\n", angle(1, 1)); */
      /* printf(" 0, 1 = %lf\n", angle(0, 1)); */
      /* printf("-1, 1 = %lf\n", angle(-1, 1)); */
      /* printf("-1, 0 = %lf\n", angle(-1, 0)); */
      /* printf("-1,-1 = %lf\n", angle(-1, -1)); */
      /* printf(" 0,-1 = %lf\n", angle(0, -1)); */
      /* printf(" 1,-1 = %lf\n", angle(1, -1)); */

      //printf("w=%d, h=%d\n", w, h);
      //for (int rotations = 0; rotations < 1; rotations++) {
      double radian = 0.0;
      for (int nth = 1; nth <= 200; nth++) {
        double minradian = 99.0;
        int mindist = 9999;
        int minx, miny;
            for (int yy = 0; yy < h; yy++) {
              for (int xx = 0; xx < w; xx++) {
                if (yxs[yy][xx]) {
                  double rad = angle(y-yy, xx-x);
                  /* printf("%d,%d rad=%.2lf\n", xx,yy, rad); */
                  int dist = abs(y - yy) + abs(x - xx);
                  double radianToLazer = rad - radian;
                  if (rad > radian && rad < minradian) {
                    minradian = rad;
                    minx = xx;
                    miny = yy;
                  }
                  if (rad > radian && rad == minradian && dist < mindist) {
                    mindist = dist;
                    minx = xx;
                    miny = yy;
                  }
                }
              }
            }

            if (nth == 200)
              printf("= %d\n", minx * 100 + miny);

            //printf("## %d: %d,%d rad=%.2lf dist=%d\n", nth, minx, miny, minradian, mindist);
            yxs[miny][minx] = 0;
            radian = minradian + 0.000000001;
      }

      //printf("= %d\n", maxDetected);
      return 0;
    }
  /*
            1
  01234567890123456
  .#....###24...#..0
  ##...##.13#67..9#1
  ##...#...5.8####.2
  ..#.....X...###..3
  ..#.#.....#....##4

  1: 8,1
  2: 9,0
  3: 9,1
  4: 10,0
  5: 9,2
  ,*/
#+END_SRC

#+RESULTS:
: = 204

 - ? <2019-12-10 Tue 21:50>
 - ? <2019-12-11 Wed 18:09>
 - 320 too high <2019-12-11 Wed 18:49>
 - 204 correct <2019-12-11 Wed 18:51>
* day 11
** puzzle
--- Day 11: Space Police ---

On the way to Jupiter, you're pulled over by the Space Police.

"Attention, unmarked spacecraft! You are in violation of Space Law! All spacecraft must have a clearly visible registration identifier! You have 24 hours to comply or be sent to Space Jail!"

Not wanting to be sent to Space Jail, you radio back to the Elves on Earth for help. Although it takes almost three hours for their reply signal to reach you, they send instructions for how to power up the emergency hull painting robot and even provide a small Intcode program (your puzzle input) that will cause it to paint your ship appropriately.

There's just one problem: you don't have an emergency hull painting robot.

You'll need to build a new emergency hull painting robot. The robot needs to be able to move around on the grid of square panels on the side of your ship, detect the color of its current panel, and paint its current panel black or white. (All of the panels are currently black.)

The Intcode program will serve as the brain of the robot. The program uses input instructions to access the robot's camera: provide 0 if the robot is over a black panel or 1 if the robot is over a white panel. Then, the program will output two values:

    First, it will output a value indicating the color to paint the panel the robot is over: 0 means to paint the panel black, and 1 means to paint the panel white.
    Second, it will output a value indicating the direction the robot should turn: 0 means it should turn left 90 degrees, and 1 means it should turn right 90 degrees.

After the robot turns, it should always move forward exactly one panel. The robot starts facing up.

The robot will continue running for a while like this and halt when it is finished drawing. Do not restart the Intcode computer inside the robot during this process.

For example, suppose the robot is about to start running. Drawing black panels as ., white panels as #, and the robot pointing the direction it is facing (< ^ > v), the initial state and region near the robot looks like this:

.....
.....
..^..
.....
.....

The panel under the robot (not visible here because a ^ is shown instead) is also black, and so any input instructions at this point should be provided 0. Suppose the robot eventually outputs 1 (paint white) and then 0 (turn left). After taking these actions and moving forward one panel, the region now looks like this:

.....
.....
.<#..
.....
.....

Input instructions should still be provided 0. Next, the robot might output 0 (paint black) and then 0 (turn left):

.....
.....
..#..
.v...
.....

After more outputs (1,0, 1,0):

.....
.....
..^..
.##..
.....

The robot is now back where it started, but because it is now on a white panel, input instructions should be provided 1. After several more outputs (0,1, 1,0, 1,0), the area looks like this:

.....
..<#.
...#.
.##..
.....

Before you deploy the robot, you should probably have an estimate of the area it will cover: specifically, you need to know the number of panels it paints at least once, regardless of color. In the example above, the robot painted 6 panels at least once. (It painted its starting panel twice, but that panel is still only counted once; it also never painted the panel it ended on.)

Build a new emergency hull painting robot and run the Intcode program on it. How many panels does it paint at least once?

Your puzzle answer was 2322.
--- Part Two ---

You're not sure what it's trying to paint, but it's definitely not a registration identifier. The Space Police are getting impatient.

Checking your external ship cameras again, you notice a white panel marked "emergency hull painting robot starting panel". The rest of the panels are still black, but it looks like the robot was expecting to start on a white panel, not a black one.

Based on the Space Law Space Brochure that the Space Police attached to one of your windows, a valid registration identifier is always eight capital letters. After starting the robot on a single white panel instead, what registration identifier does it paint on your hull?

Your puzzle answer was JHARBGCU.

Both parts of this puzzle are complete! They provide two gold stars: **
** part 1
 - <2019-12-15 Sun 08:31>
#+BEGIN_SRC C :results output
  #include <stdio.h>
  #include <stdlib.h>
  #include <stdarg.h>
  #define MAX 10000

  void die(const char *format, ...) {
    va_list arglist;
    va_start(arglist, format);
    vprintf(format, arglist);
    va_end(arglist);
    exit(0);
  }

  void info(const char * format, ...) {
    return;
    va_list arglist;
    va_start(arglist, format);
    vprintf(format, arglist);
    va_end(arglist);
  }

  #define PSTATE_NOT_STARTED 0
  #define PSTATE_STOPPED 1
  #define PSTATE_WAITING_INPUT 2
  #define PSTATE_OUTPUT 3

  struct program {
    long *program;
    int pc;
    int state;
    long base;
  };

  long paramref(struct program *program, int mode, int i) {
      if (mode == 0) {
          long val = program->program[i];
          if (val > MAX) die("param too big: mode=%d, i=%d, val=%ld", mode, i, val);
          return program->program[i];
      } else if (mode == 1) {
          return i;
      } else if (mode == 2) {
          long val = program->base + program->program[i];
          if (val > MAX) die("param too big");
          return val;
      } else {
          die("Invalid parameter mode");
      }
  }
  long param(struct program *program, int mode, int i) {
    long val = paramref(program, mode, i);
    if (val > MAX) die("param too big: mode=%d, i=%d, val=%ld", mode, i, val);
    return program->program[val];
  }

  long run(struct program *program, int input) {
    int stopper = 999999999;
    long *p = program->program;
    long lastoutput = -1;
    int i = program->pc;
    int usedinput = 0;
    while (stopper-- >= 0) {
       if (i > MAX-5) die("pc outside range");
        int opcode = p[i] % 100;
        int p1mode = (p[i] / 100) % 10;
        int p2mode = (p[i] / 1000) % 10;
        int p3mode = (p[i] / 10000) % 10;
        if (opcode == 99) {
          program->state = PSTATE_STOPPED;
          program->pc = i;
          return -1;
        } else if (opcode == 1) { // +
          info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          p[paramref(program, p3mode, i+3)] = param(program, p1mode, i+1) + param(program, p2mode, i+2);
          i += 4;
        } else if (opcode == 2) { // *
          info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          p[paramref(program, p3mode, i+3)] = param(program, p1mode, i+1) * param(program, p2mode, i+2);
          i += 4;
        } else if (opcode == 3) { // input
          info("%4d: %ld %ld\n", i, p[i], p[i+1]);
          if (usedinput) {
            program->state = PSTATE_WAITING_INPUT;
            program->pc = i;
            return -2;
          }
          p[paramref(program, p1mode, i+1)] = input;
          i += 2;
          usedinput = 1;
        } else if (opcode == 4) { // output
          info("%4d: %ld %ld\n", i, p[i], p[i+1]);
          lastoutput = param(program, p1mode, i+1);
          info("output %ld\n", lastoutput);
          i += 2;
          program->state = PSTATE_OUTPUT;
          program->pc = i;
          return lastoutput;
        } else if (opcode == 5) { // jump-if-true
          info("%4d: %ld %ld %ld\n", i, p[i], p[i+1], p[i+2]);
          if (0 != param(program, p1mode, i+1))
            i = param(program, p2mode, i+2);
          else
            i += 3;
        } else if (opcode == 6) { // jump-if-false
          info("%4d: %ld %ld %ld\n", i, p[i], p[i+1], p[i+2]);
          if (0 == param(program, p1mode, i+1))
            i = param(program, p2mode, i+2);
          else
            i += 3;
        } else if (opcode == 7) { // less than
          info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          if (param(program, p1mode, i+1) < param(program, p2mode, i+2))
            p[paramref(program, p3mode, i+3)] = 1;
          else
            p[paramref(program, p3mode, i+3)] = 0;
          i += 4;
        } else if (opcode == 8) { // equal to
          info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          if (param(program, p1mode, i+1) == param(program, p2mode, i+2))
            p[paramref(program, p3mode, i+3)] = 1;
          else
            p[paramref(program, p3mode, i+3)] = 0;
          i += 4;
        } else if (opcode == 9) {
          info("%4d: %ld %ld\n", i, p[i], p[i+1]);
          program->base += param(program, p1mode, i+1);
          i += 2;
        } else {
          info("%ld: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          die("Error: unknown opcode %d: %ld, %ld, %ld, %ld", i, p[i], p[i+1], p[i+2], p[i+3]);
          return -2;
        }
      }
      die("Error: program outside MAX: %d\n", i);
      return -3;
  }

  #define BUF 200
  int main(int argc, char **args) {
      long *positions = malloc(MAX * sizeof(long));
      //long positions[MAX] = {0};
      FILE *f = fopen("11.txt", "r");
      for (int i = 0; i < MAX; i++) {
          if (fscanf(f, "%ld", &positions[i]) != 1) break;
          fscanf(f, ",");
      }

      struct program prog;
      prog.pc = 0;
      prog.state = PSTATE_NOT_STARTED;
      prog.base = 0;
      prog.program = positions;

      char painted[BUF][BUF] = {0};

      char panels[BUF][BUF] = {0};
      int y = BUF/2, x = BUF/2, dir = 0;

      while (prog.state != PSTATE_STOPPED) {
        long newcolor = run(&prog, panels[y][x]);
        if (prog.state != PSTATE_OUTPUT) break;
        panels[y][x] = newcolor;
        painted[y][x]++;
        long turn = run(&prog, panels[y][x]);
        //printf("## %d,%d, newcolor=%d, turn=%d\n", x,y, newcolor, turn);
        if (turn == 0) dir--; else dir++;
        dir = (dir + 4) % 4;
        if (dir == 0) y--;
        else if (dir == 1) x++;
        else if (dir == 2) y++;
        else if (dir == 3) x--;
        if (x < 0 || x >= BUF || y < 0 || y >= BUF) die("outside BUF");
      }

      int whites = 0;
      for (int y = 0; y < BUF; y++) {
        for (int x = 0; x < BUF; x++) {
          if (painted[y][x] >= 1)
            whites++;
        }
      }
      printf("= %d\n", whites);


      return 0;
  }
#+END_SRC

#+RESULTS:
: = 2322

 - 1303 too low <2019-12-15 Sun 08:46>
 - 2322 correct <2019-12-15 Sun 08:47>
** part 2
#+BEGIN_SRC C :results output
  #include <stdio.h>
  #include <stdlib.h>
  #include <stdarg.h>
  #define MAX 10000

  void die(const char *format, ...) {
    va_list arglist;
    va_start(arglist, format);
    vprintf(format, arglist);
    va_end(arglist);
    exit(0);
  }

  void info(const char * format, ...) {
    return;
    va_list arglist;
    va_start(arglist, format);
    vprintf(format, arglist);
    va_end(arglist);
  }

  #define PSTATE_NOT_STARTED 0
  #define PSTATE_STOPPED 1
  #define PSTATE_WAITING_INPUT 2
  #define PSTATE_OUTPUT 3

  struct program {
    long *program;
    int pc;
    int state;
    long base;
  };

  long paramref(struct program *program, int mode, int i) {
      if (mode == 0) {
          long val = program->program[i];
          if (val > MAX) die("param too big: mode=%d, i=%d, val=%ld", mode, i, val);
          return program->program[i];
      } else if (mode == 1) {
          return i;
      } else if (mode == 2) {
          long val = program->base + program->program[i];
          if (val > MAX) die("param too big");
          return val;
      } else {
          die("Invalid parameter mode");
      }
  }
  long param(struct program *program, int mode, int i) {
    long val = paramref(program, mode, i);
    if (val > MAX) die("param too big: mode=%d, i=%d, val=%ld", mode, i, val);
    return program->program[val];
  }

  long run(struct program *program, int input) {
    int stopper = 999999999;
    long *p = program->program;
    long lastoutput = -1;
    int i = program->pc;
    int usedinput = 0;
    while (stopper-- >= 0) {
       if (i > MAX-5) die("pc outside range");
        int opcode = p[i] % 100;
        int p1mode = (p[i] / 100) % 10;
        int p2mode = (p[i] / 1000) % 10;
        int p3mode = (p[i] / 10000) % 10;
        if (opcode == 99) {
          program->state = PSTATE_STOPPED;
          program->pc = i;
          return -1;
        } else if (opcode == 1) { // +
          info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          p[paramref(program, p3mode, i+3)] = param(program, p1mode, i+1) + param(program, p2mode, i+2);
          i += 4;
        } else if (opcode == 2) { // *
          info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          p[paramref(program, p3mode, i+3)] = param(program, p1mode, i+1) * param(program, p2mode, i+2);
          i += 4;
        } else if (opcode == 3) { // input
          info("%4d: %ld %ld\n", i, p[i], p[i+1]);
          if (usedinput) {
            program->state = PSTATE_WAITING_INPUT;
            program->pc = i;
            return -2;
          }
          p[paramref(program, p1mode, i+1)] = input;
          i += 2;
          usedinput = 1;
        } else if (opcode == 4) { // output
          info("%4d: %ld %ld\n", i, p[i], p[i+1]);
          lastoutput = param(program, p1mode, i+1);
          info("output %ld\n", lastoutput);
          i += 2;
          program->state = PSTATE_OUTPUT;
          program->pc = i;
          return lastoutput;
        } else if (opcode == 5) { // jump-if-true
          info("%4d: %ld %ld %ld\n", i, p[i], p[i+1], p[i+2]);
          if (0 != param(program, p1mode, i+1))
            i = param(program, p2mode, i+2);
          else
            i += 3;
        } else if (opcode == 6) { // jump-if-false
          info("%4d: %ld %ld %ld\n", i, p[i], p[i+1], p[i+2]);
          if (0 == param(program, p1mode, i+1))
            i = param(program, p2mode, i+2);
          else
            i += 3;
        } else if (opcode == 7) { // less than
          info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          if (param(program, p1mode, i+1) < param(program, p2mode, i+2))
            p[paramref(program, p3mode, i+3)] = 1;
          else
            p[paramref(program, p3mode, i+3)] = 0;
          i += 4;
        } else if (opcode == 8) { // equal to
          info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          if (param(program, p1mode, i+1) == param(program, p2mode, i+2))
            p[paramref(program, p3mode, i+3)] = 1;
          else
            p[paramref(program, p3mode, i+3)] = 0;
          i += 4;
        } else if (opcode == 9) {
          info("%4d: %ld %ld\n", i, p[i], p[i+1]);
          program->base += param(program, p1mode, i+1);
          i += 2;
        } else {
          info("%ld: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          die("Error: unknown opcode %d: %ld, %ld, %ld, %ld", i, p[i], p[i+1], p[i+2], p[i+3]);
          return -2;
        }
      }
      die("Error: program outside MAX: %d\n", i);
      return -3;
  }

  #define BUF 200
  int main(int argc, char **args) {
      long *positions = malloc(MAX * sizeof(long));
      //long positions[MAX] = {0};
      FILE *f = fopen("11.txt", "r");
      for (int i = 0; i < MAX; i++) {
          if (fscanf(f, "%ld", &positions[i]) != 1) break;
          fscanf(f, ",");
      }

      struct program prog;
      prog.pc = 0;
      prog.state = PSTATE_NOT_STARTED;
      prog.base = 0;
      prog.program = positions;

      char panels[BUF][BUF] = {0};
      int y = BUF/2, x = BUF/2, dir = 0;
      panels[y][x] = 1;

      while (prog.state != PSTATE_STOPPED) {
        long newcolor = run(&prog, panels[y][x]);
        if (prog.state != PSTATE_OUTPUT) break;
        panels[y][x] = newcolor;
        long turn = run(&prog, panels[y][x]);
        //printf("## %d,%d, newcolor=%d, turn=%d\n", x,y, newcolor, turn);
        if (turn == 0) dir--; else dir++;
        dir = (dir + 4) % 4;
        if (dir == 0) y--;
        else if (dir == 1) x++;
        else if (dir == 2) y++;
        else if (dir == 3) x--;
        if (x < 0 || x >= BUF || y < 0 || y >= BUF) die("outside BUF");
      }

      int minx = BUF, maxx = 0, miny = BUF, maxy = 0;
      for (int y = 0; y < BUF; y++) {
        for (int x = 0; x < BUF; x++) {
          if (panels[y][x]) {
            if (x < minx) minx = x;
            if (x > maxx) maxx = x;
            if (y < miny) miny = y;
            if (y > maxy) maxy = y;
          }
        }
      }

      for (int y = miny; y <= maxy; y++) {
        for (int x = minx; x <= maxx; x++) {
          if (panels[y][x]) printf("#"); else printf(".");
        }
        printf("\n");
      }
      return 0;
  }
#+END_SRC

#+RESULTS:
: ..##.#..#..##..###..###...##...##..#..#
: ...#.#..#.#..#.#..#.#..#.#..#.#..#.#..#
: ...#.####.#..#.#..#.###..#....#....#..#
: ...#.#..#.####.###..#..#.#.##.#....#..#
: #..#.#..#.#..#.#.#..#..#.#..#.#..#.#..#
: .##..#..#.#..#.#..#.###...###..##...##.

 - JHARBGCU correct <2019-12-15 Sun 08:51>
* day 12
** puzzle
--- Day 12: The N-Body Problem ---

The space near Jupiter is not a very safe place; you need to be careful of a big distracting red spot, extreme radiation, and a whole lot of moons swirling around. You decide to start by tracking the four largest moons: Io, Europa, Ganymede, and Callisto.

After a brief scan, you calculate the position of each moon (your puzzle input). You just need to simulate their motion so you can avoid them.

Each moon has a 3-dimensional position (x, y, and z) and a 3-dimensional velocity. The position of each moon is given in your scan; the x, y, and z velocity of each moon starts at 0.

Simulate the motion of the moons in time steps. Within each time step, first update the velocity of every moon by applying gravity. Then, once all moons' velocities have been updated, update the position of every moon by applying velocity. Time progresses by one step once all of the positions are updated.

To apply gravity, consider every pair of moons. On each axis (x, y, and z), the velocity of each moon changes by exactly +1 or -1 to pull the moons together. For example, if Ganymede has an x position of 3, and Callisto has a x position of 5, then Ganymede's x velocity changes by +1 (because 5 > 3) and Callisto's x velocity changes by -1 (because 3 < 5). However, if the positions on a given axis are the same, the velocity on that axis does not change for that pair of moons.

Once all gravity has been applied, apply velocity: simply add the velocity of each moon to its own position. For example, if Europa has a position of x=1, y=2, z=3 and a velocity of x=-2, y=0,z=3, then its new position would be x=-1, y=2, z=6. This process does not modify the velocity of any moon.

For example, suppose your scan reveals the following positions:

<x=-1, y=0, z=2>
<x=2, y=-10, z=-7>
<x=4, y=-8, z=8>
<x=3, y=5, z=-1>

Simulating the motion of these moons would produce the following:

After 0 steps:
pos=<x=-1, y=  0, z= 2>, vel=<x= 0, y= 0, z= 0>
pos=<x= 2, y=-10, z=-7>, vel=<x= 0, y= 0, z= 0>
pos=<x= 4, y= -8, z= 8>, vel=<x= 0, y= 0, z= 0>
pos=<x= 3, y=  5, z=-1>, vel=<x= 0, y= 0, z= 0>

After 1 step:
pos=<x= 2, y=-1, z= 1>, vel=<x= 3, y=-1, z=-1>
pos=<x= 3, y=-7, z=-4>, vel=<x= 1, y= 3, z= 3>
pos=<x= 1, y=-7, z= 5>, vel=<x=-3, y= 1, z=-3>
pos=<x= 2, y= 2, z= 0>, vel=<x=-1, y=-3, z= 1>

After 2 steps:
pos=<x= 5, y=-3, z=-1>, vel=<x= 3, y=-2, z=-2>
pos=<x= 1, y=-2, z= 2>, vel=<x=-2, y= 5, z= 6>
pos=<x= 1, y=-4, z=-1>, vel=<x= 0, y= 3, z=-6>
pos=<x= 1, y=-4, z= 2>, vel=<x=-1, y=-6, z= 2>

After 3 steps:
pos=<x= 5, y=-6, z=-1>, vel=<x= 0, y=-3, z= 0>
pos=<x= 0, y= 0, z= 6>, vel=<x=-1, y= 2, z= 4>
pos=<x= 2, y= 1, z=-5>, vel=<x= 1, y= 5, z=-4>
pos=<x= 1, y=-8, z= 2>, vel=<x= 0, y=-4, z= 0>

After 4 steps:
pos=<x= 2, y=-8, z= 0>, vel=<x=-3, y=-2, z= 1>
pos=<x= 2, y= 1, z= 7>, vel=<x= 2, y= 1, z= 1>
pos=<x= 2, y= 3, z=-6>, vel=<x= 0, y= 2, z=-1>
pos=<x= 2, y=-9, z= 1>, vel=<x= 1, y=-1, z=-1>

After 5 steps:
pos=<x=-1, y=-9, z= 2>, vel=<x=-3, y=-1, z= 2>
pos=<x= 4, y= 1, z= 5>, vel=<x= 2, y= 0, z=-2>
pos=<x= 2, y= 2, z=-4>, vel=<x= 0, y=-1, z= 2>
pos=<x= 3, y=-7, z=-1>, vel=<x= 1, y= 2, z=-2>

After 6 steps:
pos=<x=-1, y=-7, z= 3>, vel=<x= 0, y= 2, z= 1>
pos=<x= 3, y= 0, z= 0>, vel=<x=-1, y=-1, z=-5>
pos=<x= 3, y=-2, z= 1>, vel=<x= 1, y=-4, z= 5>
pos=<x= 3, y=-4, z=-2>, vel=<x= 0, y= 3, z=-1>

After 7 steps:
pos=<x= 2, y=-2, z= 1>, vel=<x= 3, y= 5, z=-2>
pos=<x= 1, y=-4, z=-4>, vel=<x=-2, y=-4, z=-4>
pos=<x= 3, y=-7, z= 5>, vel=<x= 0, y=-5, z= 4>
pos=<x= 2, y= 0, z= 0>, vel=<x=-1, y= 4, z= 2>

After 8 steps:
pos=<x= 5, y= 2, z=-2>, vel=<x= 3, y= 4, z=-3>
pos=<x= 2, y=-7, z=-5>, vel=<x= 1, y=-3, z=-1>
pos=<x= 0, y=-9, z= 6>, vel=<x=-3, y=-2, z= 1>
pos=<x= 1, y= 1, z= 3>, vel=<x=-1, y= 1, z= 3>

After 9 steps:
pos=<x= 5, y= 3, z=-4>, vel=<x= 0, y= 1, z=-2>
pos=<x= 2, y=-9, z=-3>, vel=<x= 0, y=-2, z= 2>
pos=<x= 0, y=-8, z= 4>, vel=<x= 0, y= 1, z=-2>
pos=<x= 1, y= 1, z= 5>, vel=<x= 0, y= 0, z= 2>

After 10 steps:
pos=<x= 2, y= 1, z=-3>, vel=<x=-3, y=-2, z= 1>
pos=<x= 1, y=-8, z= 0>, vel=<x=-1, y= 1, z= 3>
pos=<x= 3, y=-6, z= 1>, vel=<x= 3, y= 2, z=-3>
pos=<x= 2, y= 0, z= 4>, vel=<x= 1, y=-1, z=-1>

Then, it might help to calculate the total energy in the system. The total energy for a single moon is its potential energy multiplied by its kinetic energy. A moon's potential energy is the sum of the absolute values of its x, y, and z position coordinates. A moon's kinetic energy is the sum of the absolute values of its velocity coordinates. Below, each line shows the calculations for a moon's potential energy (pot), kinetic energy (kin), and total energy:

Energy after 10 steps:
pot: 2 + 1 + 3 =  6;   kin: 3 + 2 + 1 = 6;   total:  6 * 6 = 36
pot: 1 + 8 + 0 =  9;   kin: 1 + 1 + 3 = 5;   total:  9 * 5 = 45
pot: 3 + 6 + 1 = 10;   kin: 3 + 2 + 3 = 8;   total: 10 * 8 = 80
pot: 2 + 0 + 4 =  6;   kin: 1 + 1 + 1 = 3;   total:  6 * 3 = 18
Sum of total energy: 36 + 45 + 80 + 18 = 179

In the above example, adding together the total energy for all moons after 10 steps produces the total energy in the system, 179.

Here's a second example:

<x=-8, y=-10, z=0>
<x=5, y=5, z=10>
<x=2, y=-7, z=3>
<x=9, y=-8, z=-3>

Every ten steps of simulation for 100 steps produces:

After 0 steps:
pos=<x= -8, y=-10, z=  0>, vel=<x=  0, y=  0, z=  0>
pos=<x=  5, y=  5, z= 10>, vel=<x=  0, y=  0, z=  0>
pos=<x=  2, y= -7, z=  3>, vel=<x=  0, y=  0, z=  0>
pos=<x=  9, y= -8, z= -3>, vel=<x=  0, y=  0, z=  0>

After 10 steps:
pos=<x= -9, y=-10, z=  1>, vel=<x= -2, y= -2, z= -1>
pos=<x=  4, y= 10, z=  9>, vel=<x= -3, y=  7, z= -2>
pos=<x=  8, y=-10, z= -3>, vel=<x=  5, y= -1, z= -2>
pos=<x=  5, y=-10, z=  3>, vel=<x=  0, y= -4, z=  5>

After 20 steps:
pos=<x=-10, y=  3, z= -4>, vel=<x= -5, y=  2, z=  0>
pos=<x=  5, y=-25, z=  6>, vel=<x=  1, y=  1, z= -4>
pos=<x= 13, y=  1, z=  1>, vel=<x=  5, y= -2, z=  2>
pos=<x=  0, y=  1, z=  7>, vel=<x= -1, y= -1, z=  2>

After 30 steps:
pos=<x= 15, y= -6, z= -9>, vel=<x= -5, y=  4, z=  0>
pos=<x= -4, y=-11, z=  3>, vel=<x= -3, y=-10, z=  0>
pos=<x=  0, y= -1, z= 11>, vel=<x=  7, y=  4, z=  3>
pos=<x= -3, y= -2, z=  5>, vel=<x=  1, y=  2, z= -3>

After 40 steps:
pos=<x= 14, y=-12, z= -4>, vel=<x= 11, y=  3, z=  0>
pos=<x= -1, y= 18, z=  8>, vel=<x= -5, y=  2, z=  3>
pos=<x= -5, y=-14, z=  8>, vel=<x=  1, y= -2, z=  0>
pos=<x=  0, y=-12, z= -2>, vel=<x= -7, y= -3, z= -3>

After 50 steps:
pos=<x=-23, y=  4, z=  1>, vel=<x= -7, y= -1, z=  2>
pos=<x= 20, y=-31, z= 13>, vel=<x=  5, y=  3, z=  4>
pos=<x= -4, y=  6, z=  1>, vel=<x= -1, y=  1, z= -3>
pos=<x= 15, y=  1, z= -5>, vel=<x=  3, y= -3, z= -3>

After 60 steps:
pos=<x= 36, y=-10, z=  6>, vel=<x=  5, y=  0, z=  3>
pos=<x=-18, y= 10, z=  9>, vel=<x= -3, y= -7, z=  5>
pos=<x=  8, y=-12, z= -3>, vel=<x= -2, y=  1, z= -7>
pos=<x=-18, y= -8, z= -2>, vel=<x=  0, y=  6, z= -1>

After 70 steps:
pos=<x=-33, y= -6, z=  5>, vel=<x= -5, y= -4, z=  7>
pos=<x= 13, y= -9, z=  2>, vel=<x= -2, y= 11, z=  3>
pos=<x= 11, y= -8, z=  2>, vel=<x=  8, y= -6, z= -7>
pos=<x= 17, y=  3, z=  1>, vel=<x= -1, y= -1, z= -3>

After 80 steps:
pos=<x= 30, y= -8, z=  3>, vel=<x=  3, y=  3, z=  0>
pos=<x= -2, y= -4, z=  0>, vel=<x=  4, y=-13, z=  2>
pos=<x=-18, y= -7, z= 15>, vel=<x= -8, y=  2, z= -2>
pos=<x= -2, y= -1, z= -8>, vel=<x=  1, y=  8, z=  0>

After 90 steps:
pos=<x=-25, y= -1, z=  4>, vel=<x=  1, y= -3, z=  4>
pos=<x=  2, y= -9, z=  0>, vel=<x= -3, y= 13, z= -1>
pos=<x= 32, y= -8, z= 14>, vel=<x=  5, y= -4, z=  6>
pos=<x= -1, y= -2, z= -8>, vel=<x= -3, y= -6, z= -9>

After 100 steps:
pos=<x=  8, y=-12, z= -9>, vel=<x= -7, y=  3, z=  0>
pos=<x= 13, y= 16, z= -3>, vel=<x=  3, y=-11, z= -5>
pos=<x=-29, y=-11, z= -1>, vel=<x= -3, y=  7, z=  4>
pos=<x= 16, y=-13, z= 23>, vel=<x=  7, y=  1, z=  1>

Energy after 100 steps:
pot:  8 + 12 +  9 = 29;   kin: 7 +  3 + 0 = 10;   total: 29 * 10 = 290
pot: 13 + 16 +  3 = 32;   kin: 3 + 11 + 5 = 19;   total: 32 * 19 = 608
pot: 29 + 11 +  1 = 41;   kin: 3 +  7 + 4 = 14;   total: 41 * 14 = 574
pot: 16 + 13 + 23 = 52;   kin: 7 +  1 + 1 =  9;   total: 52 *  9 = 468
Sum of total energy: 290 + 608 + 574 + 468 = 1940

What is the total energy in the system after simulating the moons given in your scan for 1000 steps?

Your puzzle answer was 10028.
--- Part Two ---

All this drifting around in space makes you wonder about the nature of the universe. Does history really repeat itself? You're curious whether the moons will ever return to a previous state.

Determine the number of steps that must occur before all of the moons' positions and velocities exactly match a previous point in time.

For example, the first example above takes 2772 steps before they exactly match a previous point in time; it eventually returns to the initial state:

After 0 steps:
pos=<x= -1, y=  0, z=  2>, vel=<x=  0, y=  0, z=  0>
pos=<x=  2, y=-10, z= -7>, vel=<x=  0, y=  0, z=  0>
pos=<x=  4, y= -8, z=  8>, vel=<x=  0, y=  0, z=  0>
pos=<x=  3, y=  5, z= -1>, vel=<x=  0, y=  0, z=  0>

After 2770 steps:
pos=<x=  2, y= -1, z=  1>, vel=<x= -3, y=  2, z=  2>
pos=<x=  3, y= -7, z= -4>, vel=<x=  2, y= -5, z= -6>
pos=<x=  1, y= -7, z=  5>, vel=<x=  0, y= -3, z=  6>
pos=<x=  2, y=  2, z=  0>, vel=<x=  1, y=  6, z= -2>

After 2771 steps:
pos=<x= -1, y=  0, z=  2>, vel=<x= -3, y=  1, z=  1>
pos=<x=  2, y=-10, z= -7>, vel=<x= -1, y= -3, z= -3>
pos=<x=  4, y= -8, z=  8>, vel=<x=  3, y= -1, z=  3>
pos=<x=  3, y=  5, z= -1>, vel=<x=  1, y=  3, z= -1>

After 2772 steps:
pos=<x= -1, y=  0, z=  2>, vel=<x=  0, y=  0, z=  0>
pos=<x=  2, y=-10, z= -7>, vel=<x=  0, y=  0, z=  0>
pos=<x=  4, y= -8, z=  8>, vel=<x=  0, y=  0, z=  0>
pos=<x=  3, y=  5, z= -1>, vel=<x=  0, y=  0, z=  0>

Of course, the universe might last for a very long time before repeating. Here's a copy of the second example from above:

<x=-8, y=-10, z=0>
<x=5, y=5, z=10>
<x=2, y=-7, z=3>
<x=9, y=-8, z=-3>

This set of initial positions takes 4686774924 steps before it repeats a previous state! Clearly, you might need to find a more efficient way to simulate the universe.

How many steps does it take to reach the first state that exactly matches a previous state?

Your puzzle answer was 314610635824376.

Both parts of this puzzle are complete! They provide two gold stars: **
** part 1
 - <2019-12-15 Sun 18:59>
#+BEGIN_SRC C :results output
  #include <stdio.h>
  #define BUF 100
  int abs(int value) {
    return value < 0 ? -1 : value;
  }
  int main(int argc, char **args) {
    FILE *f = fopen("12.txt", "r");

    int xyzs[BUF] = {0};
    int xyzsc = 0;
    int x, y, z;
    while (3 == fscanf(f, "<x=%d, y=%d, z=%d>\n", &x, &y, &z)) {
      xyzs[xyzsc++] = x;
      xyzs[xyzsc++] = y;
      xyzs[xyzsc++] = z;
    }

    int speeds[BUF] = {0};

    for (int step = 0; step <= 1000; step++) {
      //printf("step %d\n", step);
      if (step > 0) {
      for (int i = 0; i < xyzsc; i += 3) {
        for (int j = i+3; j < xyzsc; j += 3) {
          for (int axis = 0; axis < 3; axis++) {
            if (xyzs[i+axis] < xyzs[j+axis]) { speeds[i+axis]++; speeds[j+axis]--; }
            else if (xyzs[i+axis] > xyzs[j+axis]) { speeds[i+axis]--; speeds[j+axis]++; }
          }
        }
      }

      for (int i = 0; i < xyzsc; i++) {
          xyzs[i] += speeds[i];
      }
      }
  
      for (int i = 0; i < xyzsc; i += 3) {
        /* printf("%3d,%3d,%3d, vel=%3d,%3d,%3d\n",  */
        /*        xyzs[i], xyzs[i+1], xyzs[i+2], */
        /*        speeds[i], speeds[i+1], speeds[i+2]); */
      }
    }

    int energy = 0;
    for (int i = 0; i < xyzsc; i+=3) {
      int pot = abs(xyzs[i]) + abs(xyzs[i+1]) + abs(xyzs[i+2]);
      int kin = abs(speeds[i]) + abs(speeds[i+1]) + abs(speeds[i+2]);
      energy += pot * kin;
    }

    printf("= %d\n", energy);
    return 0;
  }
#+END_SRC

#+RESULTS:
: = 10028

 - 10028 correct <2019-12-15 Sun 19:24>
** part 2
#+BEGIN_SRC C :results output
  #include <stdio.h>
  #define BUF 100
  long gcd(long a, long b) { 
    if (a == 0 || b == 0) return 0;
    else if (a == b) return a;
    else if (a > b) return gcd(a - b, b);
    else/*if (a < b)*/return gcd(a, b - a);
  }
  long abs(long value) {
    return value < 0 ? -1 : value;
  }
  int main(int argc, char **args) {
    FILE *f = fopen("12.txt", "r");

    int xyzs[BUF] = {0};
    int xyzsc = 0;
    int x, y, z;
    while (3 == fscanf(f, "<x=%d, y=%d, z=%d>\n", &x, &y, &z)) {
      xyzs[xyzsc++] = x;
      xyzs[xyzsc++] = y;
      xyzs[xyzsc++] = z;
    }

    int speeds[BUF] = {0};

    int hashes[100000] = {0};

    for (int step = 0; step <= 0; step++) {
      if (step > 0) {
      for (int i = 0; i < xyzsc; i += 3) {
        for (int j = i+3; j < xyzsc; j += 3) {
          for (int axis = 0; axis < 3; axis++) {
            if (xyzs[i+axis] < xyzs[j+axis]) { speeds[i+axis]++; speeds[j+axis]--; }
            else if (xyzs[i+axis] > xyzs[j+axis]) { speeds[i+axis]--; speeds[j+axis]++; }
          }
        }
      }

      for (int i = 0; i < xyzsc; i++) {
          xyzs[i] += speeds[i];
      }
      }

      int hash = 1;
      for (int i = 0; i < xyzsc; i+=3) {
        /* hash = (hash * 31 + xyzs[i]) * 31 + speeds[i]; */
        /* hash = (hash * 31 + xyzs[i+1]) * 31 + speeds[i+1]; */
        hash = (hash * 31 + xyzs[i+2]) * 31 + speeds[i+2];
      }
      if (step == 0) hashes[step] = hash;

      int p = 0;
      /* for (int i = 0; i < step; i++) { */
      { int i = 0;
        if (hash == hashes[i]) {
          printf("%d: both hashes matches step %d\n", step, i);
          p = 1;
        }
      }
      if (p || step == 23) {
        printf("step %d\n", step);
        for (int i = 0; i < xyzsc; i += 3) {
          printf("%3d,%3d,%3d, vel=%3d,%3d,%3d\n",
                 xyzs[i], xyzs[i+1], xyzs[i+2],
                 speeds[i], speeds[i+1], speeds[i+2]);
        }
      }
    }

    // 12b.txt
    /* int xrepeat = 2028; */
    /* int yrepeat = 5898; */
    /* int zrepeat = 4702; */

    int xrepeat = 186028;
    int yrepeat = 161428;
    int zrepeat = 167624;

    /* for (long s = yrepeat; 5686774924L; s += yrepeat) { */
    /*   if (s % xrepeat == 0 && s % zrepeat == 0) */
    /*     printf("= %ld\n", s); */
    /* } */

    /* for (long x = xrepeat; 1; x += xrepeat) { */
    /*   for (long y = yrepeat; 1; y += yrepeat) { */
    /*     if (x == y) { */
    /*       for (long z = zrepeat; 1; z += zrepeat) { */
    /*         if (x == z) printf("=%ld\n", x); */
    /* }}}} */

    long num = (long) xrepeat * yrepeat;
    if (num < 0) num *= -1;
    long lcm = num / gcd(xrepeat,  yrepeat);
    num = lcm * zrepeat;
    if (num < 0) num *= -1;
    lcm = num / gcd(lcm, zrepeat);

    printf("= %ld\n", lcm);
    return 0;
  }
#+END_SRC

#+RESULTS:
: 0: both hashes matches step 0
: step 0
: -14, -4,-11, vel=  0,  0,  0
:  -9,  6, -7, vel=  0,  0,  0
:   4,  1,  4, vel=  0,  0,  0
:   2,-14, -9, vel=  0,  0,  0
: = 314610635824376

 - ? <2019-12-15 Sun 19:43>
 - ! <2019-12-15 Sun 20:04>
 - 314610635824376 correct <2019-12-15 Sun 20:34>

* day 13
** puzzle
--- Day 13: Care Package ---

As you ponder the solitude of space and the ever-increasing three-hour roundtrip for messages between you and Earth, you notice that the Space Mail Indicator Light is blinking. To help keep you sane, the Elves have sent you a care package.

It's a new game for the ship's arcade cabinet! Unfortunately, the arcade is all the way on the other end of the ship. Surely, it won't be hard to build your own - the care package even comes with schematics.

The arcade cabinet runs Intcode software like the game the Elves sent (your puzzle input). It has a primitive screen capable of drawing square tiles on a grid. The software draws tiles to the screen with output instructions: every three output instructions specify the x position (distance from the left), y position (distance from the top), and tile id. The tile id is interpreted as follows:

    0 is an empty tile. No game object appears in this tile.
    1 is a wall tile. Walls are indestructible barriers.
    2 is a block tile. Blocks can be broken by the ball.
    3 is a horizontal paddle tile. The paddle is indestructible.
    4 is a ball tile. The ball moves diagonally and bounces off objects.

For example, a sequence of output values like 1,2,3,6,5,4 would draw a horizontal paddle tile (1 tile from the left and 2 tiles from the top) and a ball tile (6 tiles from the left and 5 tiles from the top).

Start the game. How many block tiles are on the screen when the game exits?

Your puzzle answer was 200.
--- Part Two ---

The game didn't run because you didn't put in any quarters. Unfortunately, you did not bring any quarters. Memory address 0 represents the number of quarters that have been inserted; set it to 2 to play for free.

The arcade cabinet has a joystick that can move left and right. The software reads the position of the joystick with input instructions:

    If the joystick is in the neutral position, provide 0.
    If the joystick is tilted to the left, provide -1.
    If the joystick is tilted to the right, provide 1.

The arcade cabinet also has a segment display capable of showing a single number that represents the player's current score. When three output instructions specify X=-1, Y=0, the third output instruction is not a tile; the value instead specifies the new score to show in the segment display. For example, a sequence of output values like -1,0,12345 would show 12345 as the player's current score.

Beat the game by breaking all the blocks. What is your score after the last block is broken?

Your puzzle answer was 9803.

Both parts of this puzzle are complete! They provide two gold stars: **
** part 1
 - <2019-12-17 Tue 18:17>
#+BEGIN_SRC C :results output
  #include <stdio.h>
  #include <stdlib.h>
  #include <stdarg.h>
  #define MAX 10000

  void die(const char *format, ...) {
    va_list arglist;
    va_start(arglist, format);
    vprintf(format, arglist);
    va_end(arglist);
    exit(0);
  }

  void info(const char * format, ...) {
    return;
    va_list arglist;
    va_start(arglist, format);
    vprintf(format, arglist);
    va_end(arglist);
  }

  #define PSTATE_NOT_STARTED 0
  #define PSTATE_STOPPED 1
  #define PSTATE_WAITING_INPUT 2
  #define PSTATE_OUTPUT 3

  struct program {
    long *program;
    int pc;
    int state;
    long base;
  };

  long paramref(struct program *program, int mode, int i) {
      if (mode == 0) {
          long val = program->program[i];
          if (val > MAX) die("param too big: mode=%d, i=%d, val=%ld", mode, i, val);
          return program->program[i];
      } else if (mode == 1) {
          return i;
      } else if (mode == 2) {
          long val = program->base + program->program[i];
          if (val > MAX) die("param too big");
          return val;
      } else {
          die("Invalid parameter mode");
      }
  }
  long param(struct program *program, int mode, int i) {
    long val = paramref(program, mode, i);
    if (val > MAX) die("param too big: mode=%d, i=%d, val=%ld", mode, i, val);
    return program->program[val];
  }

  long run(struct program *program, int input) {
    int stopper = 999999999;
    long *p = program->program;
    long lastoutput = -1;
    int i = program->pc;
    int usedinput = 0;
    while (stopper-- >= 0) {
       if (i > MAX-5) die("pc outside range");
        int opcode = p[i] % 100;
        int p1mode = (p[i] / 100) % 10;
        int p2mode = (p[i] / 1000) % 10;
        int p3mode = (p[i] / 10000) % 10;
        if (opcode == 99) {
          program->state = PSTATE_STOPPED;
          program->pc = i;
          return -1;
        } else if (opcode == 1) { // +
          info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          p[paramref(program, p3mode, i+3)] = param(program, p1mode, i+1) + param(program, p2mode, i+2);
          i += 4;
        } else if (opcode == 2) { // *
          info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          p[paramref(program, p3mode, i+3)] = param(program, p1mode, i+1) * param(program, p2mode, i+2);
          i += 4;
        } else if (opcode == 3) { // input
          info("%4d: %ld %ld\n", i, p[i], p[i+1]);
          if (usedinput) {
            program->state = PSTATE_WAITING_INPUT;
            program->pc = i;
            return -2;
          }
          p[paramref(program, p1mode, i+1)] = input;
          i += 2;
          usedinput = 1;
        } else if (opcode == 4) { // output
          info("%4d: %ld %ld\n", i, p[i], p[i+1]);
          lastoutput = param(program, p1mode, i+1);
          info("output %ld\n", lastoutput);
          i += 2;
          program->state = PSTATE_OUTPUT;
          program->pc = i;
          return lastoutput;
        } else if (opcode == 5) { // jump-if-true
          info("%4d: %ld %ld %ld\n", i, p[i], p[i+1], p[i+2]);
          if (0 != param(program, p1mode, i+1))
            i = param(program, p2mode, i+2);
          else
            i += 3;
        } else if (opcode == 6) { // jump-if-false
          info("%4d: %ld %ld %ld\n", i, p[i], p[i+1], p[i+2]);
          if (0 == param(program, p1mode, i+1))
            i = param(program, p2mode, i+2);
          else
            i += 3;
        } else if (opcode == 7) { // less than
          info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          if (param(program, p1mode, i+1) < param(program, p2mode, i+2))
            p[paramref(program, p3mode, i+3)] = 1;
          else
            p[paramref(program, p3mode, i+3)] = 0;
          i += 4;
        } else if (opcode == 8) { // equal to
          info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          if (param(program, p1mode, i+1) == param(program, p2mode, i+2))
            p[paramref(program, p3mode, i+3)] = 1;
          else
            p[paramref(program, p3mode, i+3)] = 0;
          i += 4;
        } else if (opcode == 9) {
          info("%4d: %ld %ld\n", i, p[i], p[i+1]);
          program->base += param(program, p1mode, i+1);
          i += 2;
        } else {
          info("%ld: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
          die("Error: unknown opcode %d: %ld, %ld, %ld, %ld", i, p[i], p[i+1], p[i+2], p[i+3]);
          return -2;
        }
      }
      die("Error: program outside MAX: %d\n", i);
      return -3;
  }

  #define BUF 200
  int main(int argc, char **args) {
      long *positions = malloc(MAX * sizeof(long));
      //long positions[MAX] = {0};
      FILE *f = fopen("13.txt", "r");
      for (int i = 0; i < MAX; i++) {
          if (fscanf(f, "%ld", &positions[i]) != 1) break;
          fscanf(f, ",");
      }

      struct program prog;
      prog.pc = 0;
      prog.state = PSTATE_NOT_STARTED;
      prog.base = 0;
      prog.program = positions;


      char yxs[BUF][BUF];
      for (int y = 0; y < BUF; y++)
        for (int x = 0; x < BUF; x++)
          yxs[y][x] = 5;

      while (prog.state != PSTATE_STOPPED) {
        long x = run(&prog, 0);
        long y = run(&prog, 0);
        long tile = run(&prog, 0);
        if (prog.state != PSTATE_OUTPUT) break;

        if (x < 0 || x >= BUF || y < 0 || y >= BUF) die("outside BUF");
        if (tile < 0 || tile > 4) die("bad tile");
        yxs[y][x] = (char) tile;
      }

      int minx = BUF, maxx = 0, miny = BUF, maxy = 0;
      for (int y = 0; y < BUF; y++) {
        for (int x = 0; x < BUF; x++) {
          if (yxs[y][x] != 5) {
            if (x < minx) minx = x;
            if (x > maxx) maxx = x;
            if (y < miny) miny = y;
            if (y > maxy) maxy = y;
          }
        }
      }

      long blocks = 0;
      char *tiles = ".WB-o.";
      for (int y = miny; y <= maxy; y++) {
        for (int x = minx; x <= maxx; x++) {
          printf("%c", tiles[yxs[y][x]]);
          if (yxs[y][x] == 2) blocks++;
        }
        printf("\n");
      }

      printf("= %d\n", blocks);
      return 0;
  }
#+END_SRC

#+RESULTS:
#+begin_example
WWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWW
W..........................................W
W..........BBB.BBBBBBB.....B.B........B..B.W
W......BB..B..B..BB..BB....B.BB..BBBB....B.W
W.BBB.BB....BB.B..BB.B.BB.B.B..BBB.......B.W
W.BBB.B.BB.B.B..BBB.B.BBBBBB.B..B..B.BB....W
W..BB.BBB.....B..BB....B.BB....B..BB..B.B..W
W...B..B.B..B.B.BB...B....BB...BBBB.....BB.W
W....B..B.BBBBB..B...B......B...BB.B..B....W
W...BB..B.B..BB.B.B..BBBBB..BB...B....BB...W
W.B.BBB.....B.B.......B.B.....BB.....BBB...W
W.....BBBBBBB....BB..........B..B.BB....B..W
W.B..B.BB.B.B.BB..B..BB.B.B.B....B....B.BB.W
W..B....B..BBBB.B.BBB..B......B..BB.B.BBBB.W
W..........................................W
W...................o......................W
W..........................................W
W..........................................W
W.....................-....................W
W..........................................W
= 200
#+end_example

 - 200 correct <2019-12-17 Tue 18:24>
** part 2
#+BEGIN_SRC C :results output
  #include <stdio.h>
  #include <stdlib.h>
  #include <stdarg.h>
  #define MAX 10000

  void die(const char *format, ...) {
      va_list arglist;
      va_start(arglist, format);
      vprintf(format, arglist);
      va_end(arglist);
      exit(0);
  }

  void info(const char * format, ...) {
      return;
      va_list arglist;
      va_start(arglist, format);
      vprintf(format, arglist);
      va_end(arglist);
  }

  #define PSTATE_NOT_STARTED 0
  #define PSTATE_STOPPED 1
  #define PSTATE_WAITING_INPUT 2
  #define PSTATE_OUTPUT 3

  struct program {
      long *program;
      int pc;
      int state;
      long base;
  };

  long paramref(struct program *program, int mode, int i) {
      if (mode == 0) {
          long val = program->program[i];
          if (val > MAX) die("param too big: mode=%d, i=%d, val=%ld", mode, i, val);
          return program->program[i];
      } else if (mode == 1) {
          return i;
      } else if (mode == 2) {
          long val = program->base + program->program[i];
          if (val > MAX) die("param too big");
          return val;
      } else {
          die("Invalid parameter mode");
      }
  }
  long param(struct program *program, int mode, int i) {
      long val = paramref(program, mode, i);
      if (val > MAX) die("param too big: mode=%d, i=%d, val=%ld", mode, i, val);
      return program->program[val];
  }

  long run(struct program *program, int input, int *readinput) {
      ,*readinput = 0;
      int stopper = 999999999;
      long *p = program->program;
      long lastoutput = -1;
      int i = program->pc;
      int usedinput = 0;
      while (stopper-- >= 0) {
          if (i > MAX-5) die("pc outside range");
          int opcode = p[i] % 100;
          int p1mode = (p[i] / 100) % 10;
          int p2mode = (p[i] / 1000) % 10;
          int p3mode = (p[i] / 10000) % 10;
          if (opcode == 99) {
              program->state = PSTATE_STOPPED;
              program->pc = i;
              return -1;
          } else if (opcode == 1) { // +
              info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
              p[paramref(program, p3mode, i+3)] = param(program, p1mode, i+1) + param(program, p2mode, i+2);
              i += 4;
          } else if (opcode == 2) { // *
              info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
              p[paramref(program, p3mode, i+3)] = param(program, p1mode, i+1) * param(program, p2mode, i+2);
              i += 4;
          } else if (opcode == 3) { // input
              info("%4d: %ld %ld\n", i, p[i], p[i+1]);
              if (usedinput) {
                  program->state = PSTATE_WAITING_INPUT;
                  program->pc = i;
                  return -2;
              }
              ,*readinput = 1;
              p[paramref(program, p1mode, i+1)] = input;
              i += 2;
              usedinput = 1;
          } else if (opcode == 4) { // output
              info("%4d: %ld %ld\n", i, p[i], p[i+1]);
              lastoutput = param(program, p1mode, i+1);
              info("output %ld\n", lastoutput);
              i += 2;
              program->state = PSTATE_OUTPUT;
              program->pc = i;
              return lastoutput;
          } else if (opcode == 5) { // jump-if-true
              info("%4d: %ld %ld %ld\n", i, p[i], p[i+1], p[i+2]);
              if (0 != param(program, p1mode, i+1))
                  i = param(program, p2mode, i+2);
              else
                  i += 3;
          } else if (opcode == 6) { // jump-if-false
              info("%4d: %ld %ld %ld\n", i, p[i], p[i+1], p[i+2]);
              if (0 == param(program, p1mode, i+1))
                  i = param(program, p2mode, i+2);
              else
                  i += 3;
          } else if (opcode == 7) { // less than
              info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
              if (param(program, p1mode, i+1) < param(program, p2mode, i+2))
                  p[paramref(program, p3mode, i+3)] = 1;
              else
                  p[paramref(program, p3mode, i+3)] = 0;
              i += 4;
          } else if (opcode == 8) { // equal to
              info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
              if (param(program, p1mode, i+1) == param(program, p2mode, i+2))
                  p[paramref(program, p3mode, i+3)] = 1;
              else
                  p[paramref(program, p3mode, i+3)] = 0;
              i += 4;
          } else if (opcode == 9) {
              info("%4d: %ld %ld\n", i, p[i], p[i+1]);
              program->base += param(program, p1mode, i+1);
              i += 2;
          } else {
              info("%ld: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
              die("Error: unknown opcode %d: %ld, %ld, %ld, %ld", i, p[i], p[i+1], p[i+2], p[i+3]);
              return -2;
          }
      }
      die("Error: program outside MAX: %d\n", i);
      return -3;
  }

  #define BUF 200
  int main(int argc, char **args) {
      long *positions = malloc(MAX * sizeof(long));
      //long positions[MAX] = {0};
      FILE *f = fopen("13.txt", "r");
      for (int i = 0; i < MAX; i++) {
          if (fscanf(f, "%ld", &positions[i]) != 1) break;
          fscanf(f, ",");
      }

      struct program prog;
      prog.pc = 0;
      prog.state = PSTATE_NOT_STARTED;
      prog.base = 0;
      prog.program = positions;
      prog.program[0] = 2;

      struct program prog2;
      prog2.program = positions;
      prog2.program[0] = 2;

      char yxs[BUF][BUF];
      for (int y = 0; y < BUF; y++)
          for (int x = 0; x < BUF; x++)
              yxs[y][x] = 5;

      int paddlex = -1;
      int move = 0;
      long score = -1;
      int ballx = -1, bally = -1;
      for (int step = 0; step < 10000; step++) {
        /* printf("## step %d\n", step); */
          while (prog.state != PSTATE_STOPPED) {
              int readinput = 0;

              move = ballx < paddlex ? -1 : (ballx > paddlex ? 1 : 0);
              long x = run(&prog, move, &readinput);
              if (readinput) paddlex += move;
              move = ballx < paddlex ? -1 : (ballx > paddlex ? 1 : 0);
              long y = run(&prog, move, &readinput);
              if (readinput) paddlex += move;
              move = ballx < paddlex ? -1 : (ballx > paddlex ? 1 : 0);
              long tile = run(&prog, move, &readinput);
              if (readinput) paddlex += move;
              move = ballx < paddlex ? -1 : (ballx > paddlex ? 1 : 0);
              if (prog.state != PSTATE_OUTPUT) break;

              if (x == -1 && y == 0) {
                  score = tile;
                  break;
              } else {
                  if (x < 0 || x >= BUF || y < 0 || y >= BUF) die("outside BUF");
                  if (tile < 0 || tile > 4) die("bad tile");
                  yxs[y][x] = (char) tile;
                  if (tile == 4) { ballx = x; bally = y; }
                  if (tile == 3) { paddlex = x; }
              }
              if (step >= 1 && tile == 4) break;
          }

          int minx = BUF, maxx = 0, miny = BUF, maxy = 0;
          for (int y = 0; y < BUF; y++) {
              for (int x = 0; x < BUF; x++) {
                  if (yxs[y][x] != 5) {
                      if (x < minx) minx = x;
                      if (x > maxx) maxx = x;
                      if (y < miny) miny = y;
                      if (y > maxy) maxy = y;
                  }
              }
          }

          /* printf("paddle = %d, ball = %d,%d\n", paddlex, ballx, bally); */

          long blocks = 0;
          char *tiles = ".WB-o.";
          /* printf("score: %ld\n", score); */
          for (int y = miny; y <= maxy; y++) {
              for (int x = minx; x <= maxx; x++) {
                  /* printf("%c", tiles[yxs[y][x]]); */
                  if (yxs[y][x] == 2) blocks++;
              }
              /* printf("\n"); */
          }
          if (blocks == 0) {
            printf("WON score=%d\n", score);
            break;
          }
          if (bally == maxy) {
            printf("game over\n");
            break;
          }
      }
      return 0;
  }
#+END_SRC

#+RESULTS:
: WON score=9803

 - correct 9803 <2019-12-17 Tue 19:03>
* day 14
** puzzle
--- Day 14: Space Stoichiometry ---

As you approach the rings of Saturn, your ship's low fuel indicator turns on. There isn't any fuel here, but the rings have plenty of raw material. Perhaps your ship's Inter-Stellar Refinery Union brand nanofactory can turn these raw materials into fuel.

You ask the nanofactory to produce a list of the reactions it can perform that are relevant to this process (your puzzle input). Every reaction turns some quantities of specific input chemicals into some quantity of an output chemical. Almost every chemical is produced by exactly one reaction; the only exception, ORE, is the raw material input to the entire process and is not produced by a reaction.

You just need to know how much ORE you'll need to collect before you can produce one unit of FUEL.

Each reaction gives specific quantities for its inputs and output; reactions cannot be partially run, so only whole integer multiples of these quantities can be used. (It's okay to have leftover chemicals when you're done, though.) For example, the reaction 1 A, 2 B, 3 C => 2 D means that exactly 2 units of chemical D can be produced by consuming exactly 1 A, 2 B and 3 C. You can run the full reaction as many times as necessary; for example, you could produce 10 D by consuming 5 A, 10 B, and 15 C.

Suppose your nanofactory produces the following list of reactions:

10 ORE => 10 A
1 ORE => 1 B
7 A, 1 B => 1 C
7 A, 1 C => 1 D
7 A, 1 D => 1 E
7 A, 1 E => 1 FUEL

The first two reactions use only ORE as inputs; they indicate that you can produce as much of chemical A as you want (in increments of 10 units, each 10 costing 10 ORE) and as much of chemical B as you want (each costing 1 ORE). To produce 1 FUEL, a total of 31 ORE is required: 1 ORE to produce 1 B, then 30 more ORE to produce the 7 + 7 + 7 + 7 = 28 A (with 2 extra A wasted) required in the reactions to convert the B into C, C into D, D into E, and finally E into FUEL. (30 A is produced because its reaction requires that it is created in increments of 10.)

Or, suppose you have the following list of reactions:

9 ORE => 2 A
8 ORE => 3 B
7 ORE => 5 C
3 A, 4 B => 1 AB
5 B, 7 C => 1 BC
4 C, 1 A => 1 CA
2 AB, 3 BC, 4 CA => 1 FUEL

The above list of reactions requires 165 ORE to produce 1 FUEL:

    Consume 45 ORE to produce 10 A.
    Consume 64 ORE to produce 24 B.
    Consume 56 ORE to produce 40 C.
    Consume 6 A, 8 B to produce 2 AB.
    Consume 15 B, 21 C to produce 3 BC.
    Consume 16 C, 4 A to produce 4 CA.
    Consume 2 AB, 3 BC, 4 CA to produce 1 FUEL.

Here are some larger examples:

    13312 ORE for 1 FUEL:

    157 ORE => 5 NZVS
    165 ORE => 6 DCFZ
    44 XJWVT, 5 KHKGT, 1 QDVJ, 29 NZVS, 9 GPVTF, 48 HKGWZ => 1 FUEL
    12 HKGWZ, 1 GPVTF, 8 PSHF => 9 QDVJ
    179 ORE => 7 PSHF
    177 ORE => 5 HKGWZ
    7 DCFZ, 7 PSHF => 2 XJWVT
    165 ORE => 2 GPVTF
    3 DCFZ, 7 NZVS, 5 HKGWZ, 10 PSHF => 8 KHKGT

    180697 ORE for 1 FUEL:

    2 VPVL, 7 FWMGM, 2 CXFTF, 11 MNCFX => 1 STKFG
    17 NVRVD, 3 JNWZP => 8 VPVL
    53 STKFG, 6 MNCFX, 46 VJHF, 81 HVMC, 68 CXFTF, 25 GNMV => 1 FUEL
    22 VJHF, 37 MNCFX => 5 FWMGM
    139 ORE => 4 NVRVD
    144 ORE => 7 JNWZP
    5 MNCFX, 7 RFSQX, 2 FWMGM, 2 VPVL, 19 CXFTF => 3 HVMC
    5 VJHF, 7 MNCFX, 9 VPVL, 37 CXFTF => 6 GNMV
    145 ORE => 6 MNCFX
    1 NVRVD => 8 CXFTF
    1 VJHF, 6 MNCFX => 4 RFSQX
    176 ORE => 6 VJHF

    2210736 ORE for 1 FUEL:

    171 ORE => 8 CNZTR
    7 ZLQW, 3 BMBT, 9 XCVML, 26 XMNCP, 1 WPTQ, 2 MZWV, 1 RJRHP => 4 PLWSL
    114 ORE => 4 BHXH
    14 VRPVC => 6 BMBT
    6 BHXH, 18 KTJDG, 12 WPTQ, 7 PLWSL, 31 FHTLT, 37 ZDVW => 1 FUEL
    6 WPTQ, 2 BMBT, 8 ZLQW, 18 KTJDG, 1 XMNCP, 6 MZWV, 1 RJRHP => 6 FHTLT
    15 XDBXC, 2 LTCX, 1 VRPVC => 6 ZLQW
    13 WPTQ, 10 LTCX, 3 RJRHP, 14 XMNCP, 2 MZWV, 1 ZLQW => 1 ZDVW
    5 BMBT => 4 WPTQ
    189 ORE => 9 KTJDG
    1 MZWV, 17 XDBXC, 3 XCVML => 2 XMNCP
    12 VRPVC, 27 CNZTR => 2 XDBXC
    15 KTJDG, 12 BHXH => 5 XCVML
    3 BHXH, 2 VRPVC => 7 MZWV
    121 ORE => 7 VRPVC
    7 XCVML => 6 RJRHP
    5 BHXH, 4 VRPVC => 5 LTCX

Given the list of reactions in your puzzle input, what is the minimum amount of ORE required to produce exactly 1 FUEL?

Your puzzle answer was 628586.
--- Part Two ---

After collecting ORE for a while, you check your cargo hold: 1 trillion (1000000000000) units of ORE.

With that much ore, given the examples above:

    The 13312 ORE-per-FUEL example could produce 82892753 FUEL.
    The 180697 ORE-per-FUEL example could produce 5586022 FUEL.
    The 2210736 ORE-per-FUEL example could produce 460664 FUEL.

Given 1 trillion ORE, what is the maximum amount of FUEL you can produce?

Your puzzle answer was 3209254.

Both parts of this puzzle are complete! They provide two gold stars: **
** part 1
 - <2019-12-17 Tue 19:35>
#+BEGIN_SRC C :results output
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <stdarg.h>
    struct reactioninput {
      int amount;
      char chemical[10];
    };

    struct reaction {
      int amount;
      char chemical[10];
      int inputc;
      struct reactioninput inputs[10];
    };

    void info(const char * format, ...) {
      return;
      va_list arglist;
      va_start(arglist, format);
      vprintf(format, arglist);
      va_end(arglist);
    }

    int main(int argc, char **args) {
      struct reaction reactions[1000];
      int reactionc = 0;
      FILE *f = fopen("14.txt", "r");
      char line[1000];
      while (NULL != fgets(line, sizeof(line), f)) {
        struct reaction *r = &reactions[reactionc];
        int inputc = 0;
        char *tmp = line;
        while (1) {
          r->inputs[inputc].amount = atoi(tmp);
          tmp = strchr(tmp, ' ');
          tmp++;
          int i;
          for (i = 0; tmp[i] != ',' && tmp[i] != ' '; i++)
            r->inputs[inputc].chemical[i] = tmp[i];
          r->inputs[inputc].chemical[i] = 0;
          inputc++;
          if (tmp[i] == ',') {
            tmp += i + 2;
            continue;
          } else
            tmp += i;
            break;
        }

        tmp += 4;
        r->amount = atoi(tmp);
        tmp = strchr(tmp, ' ');
        tmp++;
        {
          int i;
          for (i = 0; tmp[i] != '\n'; i++)
            r->chemical[i] = tmp[i];
          r->chemical[i] = 0;
        }
        r->inputc = inputc;
        reactionc++;
      }

      info("a\n");
      for (int i = 0; i < reactionc; i++) {
        for (int j = 0; j < reactions[i].inputc; j++)
          info("%d %s, ", reactions[i].inputs[j].amount, reactions[i].inputs[j].chemical);
        info("= %d %s\n", reactions[i].amount, reactions[i].chemical);
      }

      struct reactioninput need[10000];
      int needc = 1;
      need[0].amount = 1;
      strcpy(need[0].chemical, "FUEL");
        for (int i = 0; i < needc; i++) {
          if (need[i].amount <= 0) continue;
          info("NEED %d %s\n", need[i].amount, need[i].chemical);
          for (int j = 0; j < reactionc; j++) {
            if (0 == strcmp(need[i].chemical, reactions[j].chemical)) {
  //              && need[i].amount >= reactions[j].amount) {
              info("FOUND %d %s\n", reactions[j].amount, reactions[j].chemical);
              for (int k = 0; k < reactions[j].inputc; k++) {
                int updatedNeed = 0;
                for (int ii = 0; ii < needc; ii++) {
                  if (0 == strcmp(need[ii].chemical, reactions[j].inputs[k].chemical)) {
                    info("UPDATE1 %d %s +%d\n", need[ii].amount, 
                           need[ii].chemical, reactions[j].inputs[k].amount);
                    need[ii].amount += reactions[j].inputs[k].amount;
                    updatedNeed = 1;
                    break;
                  }
                }
                if (!updatedNeed) {
                  need[needc].amount = reactions[j].inputs[k].amount;
                  strcpy(need[needc].chemical, reactions[j].inputs[k].chemical);
                  needc++;
                  info("ADDED %d %s\n", reactions[j].inputs[k].amount, reactions[j].inputs[k].chemical);
                }
              }
              info("UPDATE2 %d %s -%d\n", need[i].amount, 
                     need[i].chemical, reactions[j].amount);
              need[i].amount -= reactions[j].amount;
              i = 0;
              break;
            }
          }
        }

      int ores = 0;
      for (int i = 0; i < needc; i++) {
        if (0 == strcmp("ORE", need[i].chemical)) ores += need[i].amount;
        info("%d %s\n", need[i].amount, need[i].chemical);
      }

      printf("= %d\n", ores);
      return 0;
    }
#+END_SRC

#+RESULTS:
: = 628586


 - 64117 too low <2019-12-17 Tue 20:44>
 - 628586 correct <2019-12-17 Tue 21:04>
** part 2
#+BEGIN_SRC C :results output
    #include <stdio.h>
    #include <stdlib.h>
    #include <string.h>
    #include <stdarg.h>
    struct reactioninput {
      long amount;
      char chemical[10];
    };

    struct reaction {
      long amount;
      char chemical[10];
      int inputc;
      struct reactioninput inputs[10];
    };

    void info(const char * format, ...) {
      return;
      va_list arglist;
      va_start(arglist, format);
      vprintf(format, arglist);
      va_end(arglist);
    }

    int main(int argc, char **args) {
      struct reaction reactions[1000];
      int reactionc = 0;
      FILE *f = fopen("14.txt", "r");
      char line[1000];
      while (NULL != fgets(line, sizeof(line), f)) {
        struct reaction *r = &reactions[reactionc];
        int inputc = 0;
        char *tmp = line;
        while (1) {
          r->inputs[inputc].amount = atol(tmp);
          tmp = strchr(tmp, ' ');
          tmp++;
          int i;
          for (i = 0; tmp[i] != ',' && tmp[i] != ' '; i++)
            r->inputs[inputc].chemical[i] = tmp[i];
          r->inputs[inputc].chemical[i] = 0;
          inputc++;
          if (tmp[i] == ',') {
            tmp += i + 2;
            continue;
          } else
            tmp += i;
            break;
        }

        tmp += 4;
        r->amount = atol(tmp);
        tmp = strchr(tmp, ' ');
        tmp++;
        {
          int i;
          for (i = 0; tmp[i] != '\n'; i++)
            r->chemical[i] = tmp[i];
          r->chemical[i] = 0;
        }
        r->inputc = inputc;
        reactionc++;
      }

      info("a\n");
      for (int i = 0; i < reactionc; i++) {
        for (int j = 0; j < reactions[i].inputc; j++)
          info("%ld %s, ", reactions[i].inputs[j].amount, reactions[i].inputs[j].chemical);
        info("= %ld %s\n", reactions[i].amount, reactions[i].chemical);
      }

      struct reactioninput need[10000];
      long fuel = 1;
      long mul = 1;
      for (int step = 0; step < 300; step++) {
        int needc = 1;
        need[0].amount = fuel;
        strcpy(need[0].chemical, "FUEL");
        for (int i = 0; i < needc; i++) {
          if (need[i].amount <= 0) continue;
          info("NEED %ld %s\n", need[i].amount, need[i].chemical);
          for (int j = 0; j < reactionc; j++) {
            if (0 == strcmp(need[i].chemical, reactions[j].chemical)) {
  //              && need[i].amount >= reactions[j].amount) {
              long amount = need[i].amount / reactions[j].amount;
              if (amount < 1) amount = 1;
              info("FOUND %ld*%ld %s\n", reactions[j].amount, amount, reactions[j].chemical);
              for (int k = 0; k < reactions[j].inputc; k++) {
                int updatedNeed = 0;
                for (int ii = 0; ii < needc; ii++) {
                  if (0 == strcmp(need[ii].chemical, reactions[j].inputs[k].chemical)) {
                    info("UPDATE1 %ld %s +%ld*%ld\n", need[ii].amount, 
                           need[ii].chemical, reactions[j].inputs[k].amount, amount);
                    need[ii].amount += reactions[j].inputs[k].amount * amount;
                    updatedNeed = 1;
                    break;
                  }
                }
                if (!updatedNeed) {
                  need[needc].amount = reactions[j].inputs[k].amount * amount;
                  strcpy(need[needc].chemical, reactions[j].inputs[k].chemical);
                  needc++;
                  info("ADDED %ld*%ld %s\n", reactions[j].inputs[k].amount, 
                       amount, reactions[j].inputs[k].chemical);
                }
              }
              info("UPDATE2 %ld %s -%ld*^d\n", need[i].amount, 
                     need[i].chemical, reactions[j].amount, amount);
              need[i].amount -= reactions[j].amount * amount;
              i = -1;
              break;
            }
          }
        }

      long ores = 0;
      for (int i = 0; i < needc; i++) {
        if (0 == strcmp("ORE", need[i].chemical)) ores += need[i].amount;
        info("%ld %s\n", need[i].amount, need[i].chemical);
      }
      //printf("fuel=%ld ores=%ld mul=%ld\n", fuel, ores, mul);
      if (ores < 1000000000000L) {
        fuel += mul;
        mul *= 2;
      } else {
        if (mul == 2) {
          printf("= %ld\n", fuel-1);
          return 0;
        }
        fuel -= mul / 2;
        mul = 1;
      }
}

      return 0;
    }
#+END_SRC

#+RESULTS:
: = 3209254

 - 3209254 correct <2019-12-17 Tue 21:29>
* day 15
** puzzle
--- Day 15: Oxygen System ---

Out here in deep space, many things can go wrong. Fortunately, many of those things have indicator lights. Unfortunately, one of those lights is lit: the oxygen system for part of the ship has failed!

According to the readouts, the oxygen system must have failed days ago after a rupture in oxygen tank two; that section of the ship was automatically sealed once oxygen levels went dangerously low. A single remotely-operated repair droid is your only option for fixing the oxygen system.

The Elves' care package included an Intcode program (your puzzle input) that you can use to remotely control the repair droid. By running that program, you can direct the repair droid to the oxygen system and fix the problem.

The remote control program executes the following steps in a loop forever:

    Accept a movement command via an input instruction.
    Send the movement command to the repair droid.
    Wait for the repair droid to finish the movement operation.
    Report on the status of the repair droid via an output instruction.

Only four movement commands are understood: north (1), south (2), west (3), and east (4). Any other command is invalid. The movements differ in direction, but not in distance: in a long enough east-west hallway, a series of commands like 4,4,4,4,3,3,3,3 would leave the repair droid back where it started.

The repair droid can reply with any of the following status codes:

    0: The repair droid hit a wall. Its position has not changed.
    1: The repair droid has moved one step in the requested direction.
    2: The repair droid has moved one step in the requested direction; its new position is the location of the oxygen system.

You don't know anything about the area around the repair droid, but you can figure it out by watching the status codes.

For example, we can draw the area using D for the droid, # for walls, . for locations the droid can traverse, and empty space for unexplored locations. Then, the initial state looks like this:

      
      
   D  
      
      

To make the droid go north, send it 1. If it replies with 0, you know that location is a wall and that the droid didn't move:

      
   #  
   D  
      
      

To move east, send 4; a reply of 1 means the movement was successful:

      
   #  
   .D 
      
      

Then, perhaps attempts to move north (1), south (2), and east (4) are all met with replies of 0:

      
   ## 
   .D#
    # 
      

Now, you know the repair droid is in a dead end. Backtrack with 3 (which you already know will get a reply of 1 because you already know that location is open):

      
   ## 
   D.#
    # 
      

Then, perhaps west (3) gets a reply of 0, south (2) gets a reply of 1, south again (2) gets a reply of 0, and then west (3) gets a reply of 2:

      
   ## 
  #..#
  D.# 
   #  

Now, because of the reply of 2, you know you've found the oxygen system! In this example, it was only 2 moves away from the repair droid's starting position.

What is the fewest number of movement commands required to move the repair droid from its starting position to the location of the oxygen system?

Your puzzle answer was 248.
--- Part Two ---

You quickly repair the oxygen system; oxygen gradually fills the area.

Oxygen starts in the location containing the repaired oxygen system. It takes one minute for oxygen to spread to all open locations that are adjacent to a location that already contains oxygen. Diagonal locations are not adjacent.

In the example above, suppose you've used the droid to explore the area fully and have the following map (where locations that currently contain oxygen are marked O):

 ##   
#..## 
#.#..#
#.O.# 
 ###  

Initially, the only location which contains oxygen is the location of the repaired oxygen system. However, after one minute, the oxygen spreads to all open (.) locations that are adjacent to a location containing oxygen:

 ##   
#..## 
#.#..#
#OOO# 
 ###  

After a total of two minutes, the map looks like this:

 ##   
#..## 
#O#O.#
#OOO# 
 ###  

After a total of three minutes:

 ##   
#O.## 
#O#OO#
#OOO# 
 ###  

And finally, the whole region is full of oxygen after a total of four minutes:

 ##   
#OO## 
#O#OO#
#OOO# 
 ###  

So, in this example, all locations contain oxygen after 4 minutes.

Use the repair droid to get a complete map of the area. How many minutes will it take to fill with oxygen?

Your puzzle answer was 382.

Both parts of this puzzle are complete! They provide two gold stars: **
** part 1
 - <2019-12-19 Thu 18:56>
#+BEGIN_SRC C :results output
    #include <stdio.h>
    #include <stdlib.h>
    #include <stdarg.h>
    #define MAX 10000

    void die(const char *format, ...) {
        va_list arglist;
        va_start(arglist, format);
        vprintf(format, arglist);
        va_end(arglist);
        exit(0);
    }

    void info(const char * format, ...) {
        return;
        va_list arglist;
        va_start(arglist, format);
        vprintf(format, arglist);
        va_end(arglist);
    }

    #define PSTATE_NOT_STARTED 0
    #define PSTATE_STOPPED 1
    #define PSTATE_WAITING_INPUT 2
    #define PSTATE_OUTPUT 3

    struct program {
        long *program;
        int pc;
        int state;
        long base;
    };

    long paramref(struct program *program, int mode, int i) {
        if (mode == 0) {
            long val = program->program[i];
            if (val > MAX) die("param too big: mode=%d, i=%d, val=%ld", mode, i, val);
            return program->program[i];
        } else if (mode == 1) {
            return i;
        } else if (mode == 2) {
            long val = program->base + program->program[i];
            if (val > MAX) die("param too big");
            return val;
        } else {
            die("Invalid parameter mode");
        }
    }
    long param(struct program *program, int mode, int i) {
        long val = paramref(program, mode, i);
        if (val > MAX) die("param too big: mode=%d, i=%d, val=%ld", mode, i, val);
        return program->program[val];
    }

    long run(struct program *program, int input, int *readinput) {
        ,*readinput = 0;
        int stopper = 999999999;
        long *p = program->program;
        long lastoutput = -1;
        int i = program->pc;
        int usedinput = 0;
        while (stopper-- >= 0) {
            if (i > MAX-5) die("pc outside range");
            int opcode = p[i] % 100;
            int p1mode = (p[i] / 100) % 10;
            int p2mode = (p[i] / 1000) % 10;
            int p3mode = (p[i] / 10000) % 10;
            if (opcode == 99) {
                program->state = PSTATE_STOPPED;
                program->pc = i;
                return -1;
            } else if (opcode == 1) { // +
                info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
                p[paramref(program, p3mode, i+3)] = param(program, p1mode, i+1) + param(program, p2mode, i+2);
                i += 4;
            } else if (opcode == 2) { // *
                info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
                p[paramref(program, p3mode, i+3)] = param(program, p1mode, i+1) * param(program, p2mode, i+2);
                i += 4;
            } else if (opcode == 3) { // input
                info("%4d: %ld %ld\n", i, p[i], p[i+1]);
                if (usedinput) {
                    program->state = PSTATE_WAITING_INPUT;
                    program->pc = i;
                    return -2;
                }
                ,*readinput = 1;
                p[paramref(program, p1mode, i+1)] = input;
                i += 2;
                usedinput = 1;
            } else if (opcode == 4) { // output
                info("%4d: %ld %ld\n", i, p[i], p[i+1]);
                lastoutput = param(program, p1mode, i+1);
                info("output %ld\n", lastoutput);
                i += 2;
                program->state = PSTATE_OUTPUT;
                program->pc = i;
                return lastoutput;
            } else if (opcode == 5) { // jump-if-true
                info("%4d: %ld %ld %ld\n", i, p[i], p[i+1], p[i+2]);
                if (0 != param(program, p1mode, i+1))
                    i = param(program, p2mode, i+2);
                else
                    i += 3;
            } else if (opcode == 6) { // jump-if-false
                info("%4d: %ld %ld %ld\n", i, p[i], p[i+1], p[i+2]);
                if (0 == param(program, p1mode, i+1))
                    i = param(program, p2mode, i+2);
                else
                    i += 3;
            } else if (opcode == 7) { // less than
                info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
                if (param(program, p1mode, i+1) < param(program, p2mode, i+2))
                    p[paramref(program, p3mode, i+3)] = 1;
                else
                    p[paramref(program, p3mode, i+3)] = 0;
                i += 4;
            } else if (opcode == 8) { // equal to
                info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
                if (param(program, p1mode, i+1) == param(program, p2mode, i+2))
                    p[paramref(program, p3mode, i+3)] = 1;
                else
                    p[paramref(program, p3mode, i+3)] = 0;
                i += 4;
            } else if (opcode == 9) {
                info("%4d: %ld %ld\n", i, p[i], p[i+1]);
                program->base += param(program, p1mode, i+1);
                i += 2;
            } else {
                info("%ld: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
                die("Error: unknown opcode %d: %ld, %ld, %ld, %ld", i, p[i], p[i+1], p[i+2], p[i+3]);
                return -2;
            }
        }
        die("Error: program outside MAX: %d\n", i);
        return -3;
    }

    #define BUF 200
    int main(int argc, char **args) {
        long *positions = malloc(MAX * sizeof(long));
        FILE *f = fopen("15.txt", "r");
        for (int i = 0; i < MAX; i++) {
            if (fscanf(f, "%ld", &positions[i]) != 1) break;
            fscanf(f, ",");
        }

        struct program prog;
        prog.pc = 0;
        prog.state = PSTATE_NOT_STARTED;
        prog.base = 0;
        prog.program = positions;

        char yxs[BUF][BUF];
        for (int y = 0; y < BUF; y++)
            for (int x = 0; x < BUF; x++)
                yxs[y][x] = 0;

        int rx = BUF/2, ry = BUF/2;
        yxs[ry][rx] = 1;
        long in = 1;

        int ins[100000] = {0};
        int inc = 0;
        for (int step = 0; step < 20000; step++) {
          if (ry < 1 || ry >= BUF-1 || rx < 1 || rx >= BUF-1) die("outside range %d, %d", rx, ry);
          int goingback = 0;
          if (yxs[ry-1][rx] == 0) in = 1;
          else if (yxs[ry+1][rx] == 0) in = 2;
          else if (yxs[ry][rx-1] == 0) in = 3;
          else if (yxs[ry][rx+1] == 0) in = 4;
          else {
            if (inc-1 < 0) break; //die("no more steps");
            goingback = 1;
            inc--;
            in = ins[inc]; // go back
            if (in == 1) in = 2;
            else if (in == 2) in = 1;
            else if (in == 3) in = 4;
            else if (in == 4) in = 3;
          }

          if (prog.state == PSTATE_STOPPED) die("stopped?");
          int readinput = 0;
          long status = run(&prog, in, &readinput);
          if (!readinput) die("no read input?");

          /* printf("%d: %d,%d: %ld -> %ld (inc=%d) (back=%d)\n",  */
          /*        step, rx, ry, in, status, inc, goingback); */
          int rx2 = rx, ry2 = ry;
          if (in == 1) ry2--;
          if (in == 2) ry2++;
          if (in == 3) rx2--;
          if (in == 4) rx2++;
          if (status == 0) {
            if (goingback) die("bad go back");
            yxs[ry2][rx2] = 2;
          } else {
            if (inc >= 100000) die("no more steps2");
            if (!goingback) ins[inc++] = in;
            rx = rx2;
            ry = ry2;
            if (status == 1) yxs[ry][rx] = 1;
            if (status == 2) yxs[ry][rx] = 3;
          }
          /* if (inc>4) printf("back: %d %d %d %d\n", ins[inc-1], ins[inc-2], ins[inc-3], ins[inc-4]); */

  }      
          {
            int minx = BUF, maxx = 0, miny = BUF, maxy = 0;
            for (int y = 0; y < BUF; y++) {
                for (int x = 0; x < BUF; x++) {
                    if (yxs[y][x] != 0) {
                        if (x < minx) minx = x;
                        if (x > maxx) maxx = x;
                        if (y < miny) miny = y;
                        if (y > maxy) maxy = y;
                    }
                }
            }

            char *tiles = " .#O";
            for (int y = miny; y <= maxy; y++) {
                for (int x = minx; x <= maxx; x++) {
                    if (y == ry && x == rx)
                      printf("R");
                    else
                      printf("%c", tiles[yxs[y][x]]);
                }
                printf("\n");
            }
          }

        int distyxs[BUF][BUF];
        for (int y = 0; y < BUF; y++)
            for (int x = 0; x < BUF; x++)
                distyxs[y][x] = -1;

        distyxs[ry][rx] = 0;

        int cloudx[10000];
        int cloudy[10000];
        int cloudc = 1;
        cloudx[0] = BUF/2;
        cloudy[0] = BUF/2;
        while (cloudc > 0) {
          int x = cloudx[cloudc-1];
          int y = cloudy[cloudc-1];
          cloudc--;
          for (int in = 1; in <= 4; in++) {
            int dx = 0, dy = 0;
            if (in == 1) dy--;
            if (in == 2) dy++;
            if (in == 3) dx--;
            if (in == 4) dx++;
            if ((yxs[y+dy][x+dx] == 1 || yxs[y+dy][x+dx] == 3) && distyxs[y+dy][x+dx] == -1) {
              distyxs[y+dy][x+dx] = distyxs[y][x] + 1;
              cloudx[cloudc] = x+dx;
              cloudy[cloudc] = y+dy;
              cloudc++;
              //printf("## %d: %d,%d (%d) add %d.%d\n", cloudc, x, y, distyxs[y][x], x+dx, y+dy);
            }
          }
        }

        for (int y = 0; y < BUF; y++)
          for (int x = 0; x < BUF; x++)
            if (yxs[y][x] == 3) {
              printf("= %d (%d,%d)\n", distyxs[y][x], x, y); return 0;
            }



        return 0;
    }
#+END_SRC

#+RESULTS:
#+begin_example
####### ### ##### ######### ########### 
#.......#...#.....#.........#...........#
#.###.###.#.#.###.#.#####.#.###########.#
#.#...#...#...#.#.......#.#.#...#.......#
#.#.###.#######.#########.#.#.#.#.#####.#
#.#.#...#...#.......#.....#...#.#.#...#.#
#.#.#.###.#.#.#.#####.#.#######.#.#.#.#.#
#.#.#...#.#...#.....#.#.#...#.....#.#...#
#.#.###.###########.#.###.#.#######.#### 
#O#...#.#.........#.#.....#...#.#...#...#
 ##.#.#.#.#######.#.#########.#.#.###.## 
#...#.#...#.....#.#.....#.....#.#.#.....#
#.###.#####.###.#.###.###.#####.#.#####.#
#...#.#.......#.#...#...#.#.....#.#.....#
 ##.#.#.#####.#####.###.#.###.###.#.#### 
#...#.#.#...#...........#...#.....#.....#
#.#####.#.#############.###.###.###.###.#
#.........#...#.....#.....#...#.#.....#.#
 ######.###.#.#.###.#########.#.#####.#.#
#.....#.#...#...#.............#...#...#.#
#.###.###.#####.#################.#####.#
#.#.#.#...#...#.#....R#.....#...#.#.....#
#.#.#.#.#.#.#.###.#####.###.#.#.#.#.#### 
#.#.....#.#.#.....#.....#.#.#.#...#.....#
#.#######.#.#######.#####.#.#.#####.###.#
#.......#.#.#...#.....#.....#.#...#...#.#
 ######.###.#.###.###.#######.#.#.#####.#
#.....#.#...#.#...#.#...#.....#.#.....#.#
#.#.###.#.###.#.###.###.#.#####.#####.#.#
#.#...#...#...........#.#.......#.#...#.#
#.###.#####.###########.#########.#.###.#
#...#.....#...#.#.....#.......#.....#...#
 ##.###.#.###.#.#.###.#.#######.#####.## 
#.#.#...#...#...#...#...#.....#...#.....#
#.#.#.#########.###.###.#.###.###.#####.#
#...#.........#.#...#...#.#.#.....#...#.#
#.## ########.#.#.###.###.#.#######.#.#.#
#...#.......#...#...#...#...#...#...#.#.#
 ##.###.###.#######.#######.#.#.#.###.#.#
#.......#.........#...........#...#.....#
 ####### ######### ########### ### ##### 
= 248 (80,88)
#+end_example

 - 248 correct <2019-12-19 Thu 20:08>
** part 2
#+BEGIN_SRC C :results output
    #include <stdio.h>
    #include <stdlib.h>
    #include <stdarg.h>
    #define MAX 10000

    void die(const char *format, ...) {
        va_list arglist;
        va_start(arglist, format);
        vprintf(format, arglist);
        va_end(arglist);
        exit(0);
    }

    void info(const char * format, ...) {
        return;
        va_list arglist;
        va_start(arglist, format);
        vprintf(format, arglist);
        va_end(arglist);
    }

    #define PSTATE_NOT_STARTED 0
    #define PSTATE_STOPPED 1
    #define PSTATE_WAITING_INPUT 2
    #define PSTATE_OUTPUT 3

    struct program {
        long *program;
        int pc;
        int state;
        long base;
    };

    long paramref(struct program *program, int mode, int i) {
        if (mode == 0) {
            long val = program->program[i];
            if (val > MAX) die("param too big: mode=%d, i=%d, val=%ld", mode, i, val);
            return program->program[i];
        } else if (mode == 1) {
            return i;
        } else if (mode == 2) {
            long val = program->base + program->program[i];
            if (val > MAX) die("param too big");
            return val;
        } else {
            die("Invalid parameter mode");
        }
    }
    long param(struct program *program, int mode, int i) {
        long val = paramref(program, mode, i);
        if (val > MAX) die("param too big: mode=%d, i=%d, val=%ld", mode, i, val);
        return program->program[val];
    }

    long run(struct program *program, int input, int *readinput) {
        ,*readinput = 0;
        int stopper = 999999999;
        long *p = program->program;
        long lastoutput = -1;
        int i = program->pc;
        int usedinput = 0;
        while (stopper-- >= 0) {
            if (i > MAX-5) die("pc outside range");
            int opcode = p[i] % 100;
            int p1mode = (p[i] / 100) % 10;
            int p2mode = (p[i] / 1000) % 10;
            int p3mode = (p[i] / 10000) % 10;
            if (opcode == 99) {
                program->state = PSTATE_STOPPED;
                program->pc = i;
                return -1;
            } else if (opcode == 1) { // +
                info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
                p[paramref(program, p3mode, i+3)] = param(program, p1mode, i+1) + param(program, p2mode, i+2);
                i += 4;
            } else if (opcode == 2) { // *
                info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
                p[paramref(program, p3mode, i+3)] = param(program, p1mode, i+1) * param(program, p2mode, i+2);
                i += 4;
            } else if (opcode == 3) { // input
                info("%4d: %ld %ld\n", i, p[i], p[i+1]);
                if (usedinput) {
                    program->state = PSTATE_WAITING_INPUT;
                    program->pc = i;
                    return -2;
                }
                ,*readinput = 1;
                p[paramref(program, p1mode, i+1)] = input;
                i += 2;
                usedinput = 1;
            } else if (opcode == 4) { // output
                info("%4d: %ld %ld\n", i, p[i], p[i+1]);
                lastoutput = param(program, p1mode, i+1);
                info("output %ld\n", lastoutput);
                i += 2;
                program->state = PSTATE_OUTPUT;
                program->pc = i;
                return lastoutput;
            } else if (opcode == 5) { // jump-if-true
                info("%4d: %ld %ld %ld\n", i, p[i], p[i+1], p[i+2]);
                if (0 != param(program, p1mode, i+1))
                    i = param(program, p2mode, i+2);
                else
                    i += 3;
            } else if (opcode == 6) { // jump-if-false
                info("%4d: %ld %ld %ld\n", i, p[i], p[i+1], p[i+2]);
                if (0 == param(program, p1mode, i+1))
                    i = param(program, p2mode, i+2);
                else
                    i += 3;
            } else if (opcode == 7) { // less than
                info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
                if (param(program, p1mode, i+1) < param(program, p2mode, i+2))
                    p[paramref(program, p3mode, i+3)] = 1;
                else
                    p[paramref(program, p3mode, i+3)] = 0;
                i += 4;
            } else if (opcode == 8) { // equal to
                info("%4d: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
                if (param(program, p1mode, i+1) == param(program, p2mode, i+2))
                    p[paramref(program, p3mode, i+3)] = 1;
                else
                    p[paramref(program, p3mode, i+3)] = 0;
                i += 4;
            } else if (opcode == 9) {
                info("%4d: %ld %ld\n", i, p[i], p[i+1]);
                program->base += param(program, p1mode, i+1);
                i += 2;
            } else {
                info("%ld: %ld %ld %ld %ld\n", i, p[i], p[i+1], p[i+2], p[i+3]);
                die("Error: unknown opcode %d: %ld, %ld, %ld, %ld", i, p[i], p[i+1], p[i+2], p[i+3]);
                return -2;
            }
        }
        die("Error: program outside MAX: %d\n", i);
        return -3;
    }

    #define BUF 200
    int main(int argc, char **args) {
        long *positions = malloc(MAX * sizeof(long));
        FILE *f = fopen("15.txt", "r");
        for (int i = 0; i < MAX; i++) {
            if (fscanf(f, "%ld", &positions[i]) != 1) break;
            fscanf(f, ",");
        }

        struct program prog;
        prog.pc = 0;
        prog.state = PSTATE_NOT_STARTED;
        prog.base = 0;
        prog.program = positions;

        char yxs[BUF][BUF];
        for (int y = 0; y < BUF; y++)
            for (int x = 0; x < BUF; x++)
                yxs[y][x] = 0;

        int rx = BUF/2, ry = BUF/2;
        yxs[ry][rx] = 1;
        long in = 1;

        int ins[100000] = {0};
        int inc = 0;
        for (int step = 0; step < 20000; step++) {
          if (ry < 1 || ry >= BUF-1 || rx < 1 || rx >= BUF-1) die("outside range %d, %d", rx, ry);
          int goingback = 0;
          if (yxs[ry-1][rx] == 0) in = 1;
          else if (yxs[ry+1][rx] == 0) in = 2;
          else if (yxs[ry][rx-1] == 0) in = 3;
          else if (yxs[ry][rx+1] == 0) in = 4;
          else {
            if (inc-1 < 0) break; //die("no more steps");
            goingback = 1;
            inc--;
            in = ins[inc]; // go back
            if (in == 1) in = 2;
            else if (in == 2) in = 1;
            else if (in == 3) in = 4;
            else if (in == 4) in = 3;
          }

          if (prog.state == PSTATE_STOPPED) die("stopped?");
          int readinput = 0;
          long status = run(&prog, in, &readinput);
          if (!readinput) die("no read input?");

          /* printf("%d: %d,%d: %ld -> %ld (inc=%d) (back=%d)\n",  */
          /*        step, rx, ry, in, status, inc, goingback); */
          int rx2 = rx, ry2 = ry;
          if (in == 1) ry2--;
          if (in == 2) ry2++;
          if (in == 3) rx2--;
          if (in == 4) rx2++;
          if (status == 0) {
            if (goingback) die("bad go back");
            yxs[ry2][rx2] = 2;
          } else {
            if (inc >= 100000) die("no more steps2");
            if (!goingback) ins[inc++] = in;
            rx = rx2;
            ry = ry2;
            if (status == 1) yxs[ry][rx] = 1;
            if (status == 2) yxs[ry][rx] = 3;
          }
          /* if (inc>4) printf("back: %d %d %d %d\n", ins[inc-1], ins[inc-2], ins[inc-3], ins[inc-4]); */

  }      
          {
            int minx = BUF, maxx = 0, miny = BUF, maxy = 0;
            for (int y = 0; y < BUF; y++) {
                for (int x = 0; x < BUF; x++) {
                    if (yxs[y][x] != 0) {
                        if (x < minx) minx = x;
                        if (x > maxx) maxx = x;
                        if (y < miny) miny = y;
                        if (y > maxy) maxy = y;
                    }
                }
            }

            char *tiles = " .#O";
            for (int y = miny; y <= maxy; y++) {
                for (int x = minx; x <= maxx; x++) {
                    if (y == ry && x == rx)
                      printf("R");
                    else
                      printf("%c", tiles[yxs[y][x]]);
                }
                printf("\n");
            }
          }

        int distyxs[BUF][BUF];
        for (int y = 0; y < BUF; y++)
            for (int x = 0; x < BUF; x++)
                distyxs[y][x] = -1;

        int cloudx[10000];
        int cloudy[10000];
        int cloudc = 1;
        cloudx[0] = 80; // x of oxygen
        cloudy[0] = 88; // y of oxygen
        distyxs[cloudy[0]][cloudx[0]] = 0;
        while (cloudc > 0) {
          int x = cloudx[cloudc-1];
          int y = cloudy[cloudc-1];
          cloudc--;
          for (int in = 1; in <= 4; in++) {
            int dx = 0, dy = 0;
            if (in == 1) dy--;
            if (in == 2) dy++;
            if (in == 3) dx--;
            if (in == 4) dx++;
            if ((yxs[y+dy][x+dx] == 1 || yxs[y+dy][x+dx] == 3) && distyxs[y+dy][x+dx] == -1) {
              distyxs[y+dy][x+dx] = distyxs[y][x] + 1;
              cloudx[cloudc] = x+dx;
              cloudy[cloudc] = y+dy;
              cloudc++;
              //printf("## %d: %d,%d (%d) add %d.%d\n", cloudc, x, y, distyxs[y][x], x+dx, y+dy);
            }
          }
        }

        int maxdist = 0;
        int ox = 0, oy = 0;
        for (int y = 0; y < BUF; y++)
          for (int x = 0; x < BUF; x++)
            if (distyxs[y][x] > maxdist) maxdist = distyxs[y][x];
        printf("= %d\n", maxdist); return 0;


        return 0;
    }
#+END_SRC

#+RESULTS:
#+begin_example
####### ### ##### ######### ########### 
#.......#...#.....#.........#...........#
#.###.###.#.#.###.#.#####.#.###########.#
#.#...#...#...#.#.......#.#.#...#.......#
#.#.###.#######.#########.#.#.#.#.#####.#
#.#.#...#...#.......#.....#...#.#.#...#.#
#.#.#.###.#.#.#.#####.#.#######.#.#.#.#.#
#.#.#...#.#...#.....#.#.#...#.....#.#...#
#.#.###.###########.#.###.#.#######.#### 
#O#...#.#.........#.#.....#...#.#...#...#
 ##.#.#.#.#######.#.#########.#.#.###.## 
#...#.#...#.....#.#.....#.....#.#.#.....#
#.###.#####.###.#.###.###.#####.#.#####.#
#...#.#.......#.#...#...#.#.....#.#.....#
 ##.#.#.#####.#####.###.#.###.###.#.#### 
#...#.#.#...#...........#...#.....#.....#
#.#####.#.#############.###.###.###.###.#
#.........#...#.....#.....#...#.#.....#.#
 ######.###.#.#.###.#########.#.#####.#.#
#.....#.#...#...#.............#...#...#.#
#.###.###.#####.#################.#####.#
#.#.#.#...#...#.#....R#.....#...#.#.....#
#.#.#.#.#.#.#.###.#####.###.#.#.#.#.#### 
#.#.....#.#.#.....#.....#.#.#.#...#.....#
#.#######.#.#######.#####.#.#.#####.###.#
#.......#.#.#...#.....#.....#.#...#...#.#
 ######.###.#.###.###.#######.#.#.#####.#
#.....#.#...#.#...#.#...#.....#.#.....#.#
#.#.###.#.###.#.###.###.#.#####.#####.#.#
#.#...#...#...........#.#.......#.#...#.#
#.###.#####.###########.#########.#.###.#
#...#.....#...#.#.....#.......#.....#...#
 ##.###.#.###.#.#.###.#.#######.#####.## 
#.#.#...#...#...#...#...#.....#...#.....#
#.#.#.#########.###.###.#.###.###.#####.#
#...#.........#.#...#...#.#.#.....#...#.#
#.## ########.#.#.###.###.#.#######.#.#.#
#...#.......#...#...#...#...#...#...#.#.#
 ##.###.###.#######.#######.#.#.#.###.#.#
#.......#.........#...........#...#.....#
 ####### ######### ########### ### ##### 
= 382
#+end_example

 - 381 too low <2019-12-19 Thu 20:11>
 - 382 correct <2019-12-19 Thu 20:14>
* day 16
** puzzle
--- Day 16: Flawed Frequency Transmission ---

You're 3/4ths of the way through the gas giants. Not only do roundtrip signals to Earth take five hours, but the signal quality is quite bad as well. You can clean up the signal with the Flawed Frequency Transmission algorithm, or FFT.

As input, FFT takes a list of numbers. In the signal you received (your puzzle input), each number is a single digit: data like 15243 represents the sequence 1, 5, 2, 4, 3.

FFT operates in repeated phases. In each phase, a new list is constructed with the same length as the input list. This new list is also used as the input for the next phase.

Each element in the new list is built by multiplying every value in the input list by a value in a repeating pattern and then adding up the results. So, if the input list were 9, 8, 7, 6, 5 and the pattern for a given element were 1, 2, 3, the result would be 9*1 + 8*2 + 7*3 + 6*1 + 5*2 (with each input element on the left and each value in the repeating pattern on the right of each multiplication). Then, only the ones digit is kept: 38 becomes 8, -17 becomes 7, and so on.

While each element in the output array uses all of the same input array elements, the actual repeating pattern to use depends on which output element is being calculated. The base pattern is 0, 1, 0, -1. Then, repeat each value in the pattern a number of times equal to the position in the output list being considered. Repeat once for the first element, twice for the second element, three times for the third element, and so on. So, if the third element of the output list is being calculated, repeating the values would produce: 0, 0, 0, 1, 1, 1, 0, 0, 0, -1, -1, -1.

When applying the pattern, skip the very first value exactly once. (In other words, offset the whole pattern left by one.) So, for the second element of the output list, the actual pattern used would be: 0, 1, 1, 0, 0, -1, -1, 0, 0, 1, 1, 0, 0, -1, -1, ....

After using this process to calculate each element of the output list, the phase is complete, and the output list of this phase is used as the new input list for the next phase, if any.

Given the input signal 12345678, below are four phases of FFT. Within each phase, each output digit is calculated on a single line with the result at the far right; each multiplication operation shows the input digit on the left and the pattern value on the right:

Input signal: 12345678

1*1  + 2*0  + 3*-1 + 4*0  + 5*1  + 6*0  + 7*-1 + 8*0  = 4
1*0  + 2*1  + 3*1  + 4*0  + 5*0  + 6*-1 + 7*-1 + 8*0  = 8
1*0  + 2*0  + 3*1  + 4*1  + 5*1  + 6*0  + 7*0  + 8*0  = 2
1*0  + 2*0  + 3*0  + 4*1  + 5*1  + 6*1  + 7*1  + 8*0  = 2
1*0  + 2*0  + 3*0  + 4*0  + 5*1  + 6*1  + 7*1  + 8*1  = 6
1*0  + 2*0  + 3*0  + 4*0  + 5*0  + 6*1  + 7*1  + 8*1  = 1
1*0  + 2*0  + 3*0  + 4*0  + 5*0  + 6*0  + 7*1  + 8*1  = 5
1*0  + 2*0  + 3*0  + 4*0  + 5*0  + 6*0  + 7*0  + 8*1  = 8

After 1 phase: 48226158

4*1  + 8*0  + 2*-1 + 2*0  + 6*1  + 1*0  + 5*-1 + 8*0  = 3
4*0  + 8*1  + 2*1  + 2*0  + 6*0  + 1*-1 + 5*-1 + 8*0  = 4
4*0  + 8*0  + 2*1  + 2*1  + 6*1  + 1*0  + 5*0  + 8*0  = 0
4*0  + 8*0  + 2*0  + 2*1  + 6*1  + 1*1  + 5*1  + 8*0  = 4
4*0  + 8*0  + 2*0  + 2*0  + 6*1  + 1*1  + 5*1  + 8*1  = 0
4*0  + 8*0  + 2*0  + 2*0  + 6*0  + 1*1  + 5*1  + 8*1  = 4
4*0  + 8*0  + 2*0  + 2*0  + 6*0  + 1*0  + 5*1  + 8*1  = 3
4*0  + 8*0  + 2*0  + 2*0  + 6*0  + 1*0  + 5*0  + 8*1  = 8

After 2 phases: 34040438

3*1  + 4*0  + 0*-1 + 4*0  + 0*1  + 4*0  + 3*-1 + 8*0  = 0
3*0  + 4*1  + 0*1  + 4*0  + 0*0  + 4*-1 + 3*-1 + 8*0  = 3
3*0  + 4*0  + 0*1  + 4*1  + 0*1  + 4*0  + 3*0  + 8*0  = 4
3*0  + 4*0  + 0*0  + 4*1  + 0*1  + 4*1  + 3*1  + 8*0  = 1
3*0  + 4*0  + 0*0  + 4*0  + 0*1  + 4*1  + 3*1  + 8*1  = 5
3*0  + 4*0  + 0*0  + 4*0  + 0*0  + 4*1  + 3*1  + 8*1  = 5
3*0  + 4*0  + 0*0  + 4*0  + 0*0  + 4*0  + 3*1  + 8*1  = 1
3*0  + 4*0  + 0*0  + 4*0  + 0*0  + 4*0  + 3*0  + 8*1  = 8

After 3 phases: 03415518

0*1  + 3*0  + 4*-1 + 1*0  + 5*1  + 5*0  + 1*-1 + 8*0  = 0
0*0  + 3*1  + 4*1  + 1*0  + 5*0  + 5*-1 + 1*-1 + 8*0  = 1
0*0  + 3*0  + 4*1  + 1*1  + 5*1  + 5*0  + 1*0  + 8*0  = 0
0*0  + 3*0  + 4*0  + 1*1  + 5*1  + 5*1  + 1*1  + 8*0  = 2
0*0  + 3*0  + 4*0  + 1*0  + 5*1  + 5*1  + 1*1  + 8*1  = 9
0*0  + 3*0  + 4*0  + 1*0  + 5*0  + 5*1  + 1*1  + 8*1  = 4
0*0  + 3*0  + 4*0  + 1*0  + 5*0  + 5*0  + 1*1  + 8*1  = 9
0*0  + 3*0  + 4*0  + 1*0  + 5*0  + 5*0  + 1*0  + 8*1  = 8

After 4 phases: 01029498

Here are the first eight digits of the final output list after 100 phases for some larger inputs:

    80871224585914546619083218645595 becomes 24176176.
    19617804207202209144916044189917 becomes 73745418.
    69317163492948606335995924319873 becomes 52432133.

After 100 phases of FFT, what are the first eight digits in the final output list?

Your puzzle answer was 29795507.
--- Part Two ---

Now that your FFT is working, you can decode the real signal.

The real signal is your puzzle input repeated 10000 times. Treat this new signal as a single input list. Patterns are still calculated as before, and 100 phases of FFT are still applied.

The first seven digits of your initial input signal also represent the message offset. The message offset is the location of the eight-digit message in the final output list. Specifically, the message offset indicates the number of digits to skip before reading the eight-digit message. For example, if the first seven digits of your initial input signal were 1234567, the eight-digit message would be the eight digits after skipping 1,234,567 digits of the final output list. Or, if the message offset were 7 and your final output list were 98765432109876543210, the eight-digit message would be 21098765. (Of course, your real message offset will be a seven-digit number, not a one-digit number like 7.)

Here is the eight-digit message in the final output list after 100 phases. The message offset given in each input has been highlighted. (Note that the inputs given below are repeated 10000 times to find the actual starting input lists.)

    03036732577212944063491565474664 becomes 84462026.
    02935109699940807407585447034323 becomes 78725270.
    03081770884921959731165446850517 becomes 53553731.

After repeating your input signal 10000 times and running 100 phases of FFT, what is the eight-digit message embedded in the final output list?

Your puzzle answer was 89568529.

Both parts of this puzzle are complete! They provide two gold stars: **
** part 1
 - <2019-12-21 Sat 07:16>
#+BEGIN_SRC C :results output
  #include <stdio.h>
  long abs(long val) {
    return val < 0 ? -val : val;
  }
  int main(int argc, char **args) {
    FILE *f = fopen("16.txt", "r");

    int list[1000] = {1, 2, 3, 4, 5, 6, 7, 8};
    int listc = 8;
    listc = 0;
    for (int b = fgetc(f); b >= '0' && b <= '9'; b = fgetc(f)) {
      list[listc++] = b - '0';
    }

    for (int step = 0; step < 100; step++) {
      /* printf("step %3d: ", step); */
      /* for (int i = 0; i < listc; i++) */
      /*   printf("%d", list[i]); */
      /* printf("\n"); */

      // 1: 0, 1, 0, -1
      // 2: 0, 0, 1, 1, 0, 0, -1, -1
      // 3: 0, 0, 0, 1, 1, 1, 0, 0, 0, -1, -1, -1
      int list2[1000];
      for (int i = 0; i < listc; i++) {
        long val = 0;
        for (int j = 0; j < listc; j++) {
          int pat = j+1;
          pat = pat % (4*(i+1));
          if (pat < i+1);
          else if (pat < 2*(i+1))
            val += list[j];
          else if (pat < 3*(i+1));
          else if (pat < 4*(i+1))
            val -= list[j];
          //printf("## i=%2d, j=%2d, pat=%2d, val=%ld\n", i, j, pat, val);
        }
        list2[i] = abs(val) % 10;
      }

      for (int i = 0; i < listc; i++)
        list[i] = list2[i];
    }

    printf("= ");
    for (int i = 0; i < 8; i++)
      printf("%d", list[i]);
    printf("\n");
    return 0;
  }
#+END_SRC

#+RESULTS:
: = 29795507

 - 29795507 correct <2019-12-21 Sat 07:46>
** part 2
#+BEGIN_SRC C :results output
  #include <stdio.h>
  #include <stdlib.h>
  #define BUF 10000000
  #define DUP 10000
  /* long abs(long val) { */
  /*   return val < 0 ? -val : val; */
  /* } */
  int main(int argc, char **args) {
    FILE *f = fopen("16.txt", "r");

    char *list = malloc(BUF);
    int listc = 0;
    for (int b = fgetc(f); b >= '0' && b <= '9'; b = fgetc(f)) {
      list[listc++] = b - '0';
    }
    int listc1 = listc;
    for (int i = 0; i < DUP; i++) {
      for (int j = 0; j < listc; j++) {
        list[i * listc + j] = list[j];
      }
    }
    listc = DUP * listc;

    char indexs[9];
    for (int i = 0; i < 7; i++)
      indexs[i] = '0'+list[i];
    indexs[7] = 0;
    int index = atoi(indexs);

    long *sum = malloc(sizeof(long) * (BUF+1));

    char *list2 = malloc(BUF);
    for (int step = 0; step <= 100; step++) {
      sum[0] = 0;
      for (int i = 0; i < listc; i++) sum[i+1] = sum[i] + list[i];
      //printf("... %d\n", step);
      if (step >= 1) {
      for (int i = 0; i < listc; i++) {
      //for (int i = 800; i < 805; i++) {
      //{ int i = 801;
        long val = 0;

        //printf("#0 %2d: patc=%d, listc1=%d\n", i, patc, listc1);
        if (1) {
          int patc = 4*(i+1);
          for (int j = 0; j < listc; j += patc) {
            int ones1start = j + 1*(i+1) - 1;
            int ones1end = j + 2*(i+1) - 1;
            if (ones1end >= listc) ones1end = listc;
            if (ones1start < ones1end)
              val += sum[ones1end] - sum[ones1start];

            int ones2start = j + 3*(i+1) - 1;
            int ones2end = j + 4*(i+1) - 1;
            if (ones2end >= listc) ones2end = listc;
            if (ones2start < ones2end)
              val -= sum[ones2end] - sum[ones2start];
            /* printf("#8 i=%d, j=%d, listc=%d, +=%d..%d=%ld, -=%d..%d=%d, val=%d\n", i, j, listc, ones1start, ones1end, sum[ones1end] - sum[ones1start], ones2start, ones2end, sum[ones2end] - sum[ones2start], val); */
            /* printf("  +: %d - %d  -: %d - %d\n", sum[ones1end], sum[ones1start], sum[ones2end], sum[ones2start]); */
          }
        /* } else if (5*(i+1) - 1 >= listc) { */
        /*   int ones1start = 1*(i+1) - 1; */
        /*   int ones1end = 2*(i+1) - 2; */
        /*   if (ones1end >= listc) ones1end = listc; */
        /*   if (ones1start < listc) */
        /*     val += sum[ones1end] - sum[ones1start-1]; */

        /*   int ones2start = 3*(i+1) - 1; */
        /*   int ones2end = 4*(i+1) - 2; */
        /*   if (ones2end >= listc) ones2end = listc; */
        /*   if (ones2start < listc) */
        /*     val -= sum[ones2end] - sum[ones2start-1]; */

          //printf("#8 i=%d, listc=%d, +=%d..%d=%ld, -=%d..%d=%d, val=%d\n", i, listc, ones1start, ones1end, sum[ones1end] - sum[ones1start], ones2start, ones2end, sum[ones2end] - sum[ones2start], val);
          //printf("  +: %d - %d  -: %d - %d\n", sum[ones1end], sum[ones1start], sum[ones2end], sum[ones2start]);
        /* } else { */
        /* if (i >= listc1) { */
        /*   int ones1start = 1*(i+1) - 1; */
        /*   int ones1end = 2*(i+1) - 1; */
        /*   int ones2start = 3*(i+1) - 1; */
        /*   int ones2end = 4*(i+1) - 1; */

        /*   int jmodval = 0; */
        /*   for (int j = ones1start; j < ones1end; j++) { */
        /*     val += list[j]; */
        /*     if (j > ones1start && (ones1start % listc1) == (j % listc1)) { */
        /*       int loops = (ones1end - ones1start) / listc1; */
        /*       val += jmodval * loops; */
        /*       printf("#6 start=%d, end=%d, loops=%d, len=%d, listc1=%d, val=%d\n",  */
        /*       ones1start, j, loops, ones1end - ones1start, listc1, jmodval); */
        /*       j += loops * listc1; */
        /*     } */
        /*     jmodval += list[j]; */
        /*     printf("#1 i=%2d, j=%2d, +1, listc1=%d, in=%d, val=%ld\n", i, j, j % listc1, list[j], val); */
        /*   } */
        /*   jmodval = 0; */
        /*   for (int j = ones2start; j < ones2end; j++) { */
        /*     val -= list[j]; */
        /*     if (j > ones2start && ones2start % listc1 == j % listc1) { */
        /*       int loops = (ones2end - ones2start) / listc1; */
        /*       val -= jmodval * loops; */
        /*       printf("#7 start=%d, end=%d, loops=%d, val=%d\n", ones2start, j, loops, jmodval); */
        /*       j += loops * listc1; */
        /*     } */
        /*     jmodval += list[j]; */
        /*     printf("#1 i=%2d, j=%2d, -1, listc1=%d, in=%d, val=%ld\n", i, j, j % listc1, list[j], val); */
        /*   } */
        /* } else { */
        /*   int firstPat = -1; */
        /*   int firstJc1 = -1; */
        /*   for (int j = 0; j < listc; j++) { */
        /*     int pat = j+1; */
        /*     pat = pat % (4*(i+1)); */

        /*     if (firstPat == -1) { */
        /*       firstPat = pat; */
        /*       firstJc1 = j % listc1; */
        /*     } else if (firstPat == pat && firstJc1 == (j % listc1)) { */
        /*       int jloops = listc / j; */
        /*       val *= jloops; */
        /*       //printf("#3 jloops=%d, left=%d, val=%ld\n", jloops, listc - j * jloops, val); */
        /*       j = j * jloops; */
        /*     } */

        /*     int a = 0; */
        /*     if (pat < i+1); */
        /*     else if (pat < 2*(i+1)) { */
        /*       val += list[j]; a = 1; */
        /*     } */
        /*     else if (pat < 3*(i+1)) a = 2; */
        /*     else if (pat < 4*(i+1)) { */
        /*       val -= list[j]; a = 3; */
        /*     } */
        /*     //printf("#1 i=%2d, j=%2d, pat=%2d, listc1=%d, in=%d, val=%ld, pat=%d, a=%d, sum=%ld\n", i, j, pat, j % listc1, list[j], val, pat / (i+1), a, sum[j]); */
        /*   } */
        }
        list2[i] = labs(val) % 10;
        //printf("#4 i=%2d, val=%ld, newval=%d\n", i, val, list2[i]);
      }

      for (int i = 0; i < listc; i++)
        list[i] = list2[i];
      }

      /* printf("%2d ", step); */
      /* for (int i = 0; i < 30; i++) { */
      /*   if (i % listc1 == 0) printf(" "); */
      /*   printf("%d", list[i]); */
      /* } */
      /* printf("\n"); */
    }


    if (index >= listc) { printf("index %d too big %d\n", index, listc); return 0; }
    for (int i = 0; i < 8; i++)
      indexs[i] = '0'+list[i + index];
    indexs[8] = 0;
    int msg = atoi(indexs);

    printf("= %d (%d)\n", msg, index);
    return 0;
  }
#+END_SRC

#+RESULTS:
: = 89568529 (5973181)

 - 89568529 correct <2019-12-21 Sat 18:16>
